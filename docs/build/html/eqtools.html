
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>eqtools package &#8212; eqtools 1.3.2 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="eqtools: Tools for interacting with magnetic equilibria" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="eqtools: Tools for interacting with magnetic equilibria"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">eqtools 1.3.2 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="eqtools-package">
<h1>eqtools package<a class="headerlink" href="#eqtools-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-eqtools.AUGData">
<span id="eqtools-augdata-module"></span><h2>eqtools.AUGData module<a class="headerlink" href="#module-eqtools.AUGData" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes inheriting <code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.Equilibrium</span></code> for
working with ASDEX Upgrade experimental data.</p>
<dl class="class">
<dt id="eqtools.AUGData.AUGDDData">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.AUGData.</code><code class="sig-name descname">AUGDDData</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">shotfile='EQH'</em>, <em class="sig-param">edition=0</em>, <em class="sig-param">shotfile2=None</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em>, <em class="sig-param">experiment='AUGD'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.Equilibrium</span></code></a></p>
<p>Inherits <code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.Equilibrium</span></code> class. Machine-specific data
handling class for ASDEX Upgrade. Pulls AFS data from selected location
and shotfile, stores as object attributes. Each data variable or set of
variables is recovered with a corresponding getter method. Essential data
for mapping are pulled on initialization (e.g. psirz grid). Additional
data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes ASDEX Upgrade version of the Equilibrium object.  Pulls data to
storage in instance attributes.  Core attributes are populated from the AFS
data on initialization.  Additional attributes are initialized as None,
filled on the first request to the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shot</strong> (<em>integer</em>) – ASDEX Upgrade shot index.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>shotfile</strong> (<em>string</em>) – Optional input for alternate shotfile, defaults to ‘EQH’
(i.e., CLISTE results are in EQH,EQI with other reconstructions
Available (FPP, EQE, ect.).</p></li>
<li><p><strong>edition</strong> (<em>integer</em>) – Describes the edition of the shotfile to be used</p></li>
<li><p><strong>shotfile2</strong> (<em>string</em>) – Describes companion 0D equilibrium data, will automatically
reference based off of shotfile, but can be manually specified for
unique reconstructions, etc.</p></li>
<li><p><strong>length_unit</strong> (<em>string</em>) – <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>tspline</strong> (<em>Boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>Boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
<li><p><strong>experiment</strong> – Used to describe the work space that the shotfile is located
It defaults to ‘AUGD’ but can be set to other values</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getInfo">
<code class="sig-name descname">getInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>returns namedtuple of shot information</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>namedtuple containing</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>shot</p></td>
<td><p>ASDEX Upgrage shot index (long)</p></td>
</tr>
<tr class="row-even"><td><p>tree</p></td>
<td><p>shotfile (string)</p></td>
</tr>
<tr class="row-odd"><td><p>nr</p></td>
<td><p>size of R-axis for spatial grid</p></td>
</tr>
<tr class="row-even"><td><p>nz</p></td>
<td><p>size of Z-axis for spatial grid</p></td>
</tr>
<tr class="row-odd"><td><p>nt</p></td>
<td><p>size of timebase for flux grid</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getTimeBase">
<code class="sig-name descname">getTimeBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>returns time base vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of time points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>time (array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns flux grid.</p>
<p>Note that this method preserves whatever sign convention is used in AFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,nz,nr] array of (non-normalized) flux on grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiRZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getRGrid">
<code class="sig-name descname">getRGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nr] array of R-axis of flux grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rGrid (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getZGrid">
<code class="sig-name descname">getZGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nz] array of Z-axis of flux grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>zGrid (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFluxAxis">
<code class="sig-name descname">getFluxAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi on magnetic axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of psi on magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiAxis (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFluxLCFS">
<code class="sig-name descname">getFluxLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi at separatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of psi at LCFS.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for plasma volume.  Defaults to 3,
indicating default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of volume within flux surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fluxVol (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getVolLCFS">
<code class="sig-name descname">getVolLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for LCFS volume.  Defaults to 3,
denoting default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of volume within LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>volLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of Rmid.  Defaults to 1, indicating
the default parameter unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of maximum (outboard) major radius of
flux surface psi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of R of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>RLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of Z of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ZLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.remapLCFS">
<code class="sig-name descname">remapLCFS</code><span class="sig-paren">(</span><em class="sig-param">mask=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites RLCFS, ZLCFS values pulled with explicitly-calculated
contour of psinorm=1 surface.  This is then masked down by the limiter
array using core.inPolygon, restricting the contour to the closed
plasma surface and the divertor legs.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>mask</strong> (<em>Boolean</em>) – Default False.  Set True to mask LCFS path to
limiter outline (using inPolygon).  Set False to draw full
contour of psi = psiLCFS.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NotImplementedError</strong> – if <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> is not loaded.</p></li>
<li><p><strong>ValueError</strong> – if limiter outline is not available.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getF">
<code class="sig-name descname">getF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov
solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of F=RB_{Phi}(Psi)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>F (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFluxPres">
<code class="sig-name descname">getFluxPres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>returns pressure at flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>p (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFPrime">
<code class="sig-name descname">getFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F’, often calculated for grad-shafranov
solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of F=RB_{Phi}(Psi)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>F (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFFPrime">
<code class="sig-name descname">getFFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF’ function used for grad-shafranov solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of FF’ fromgrad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>FFprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getPPrime">
<code class="sig-name descname">getPPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure gradient on flux surface
psi from grad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getElongation">
<code class="sig-name descname">getElongation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS elongation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS elongation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>kappa (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from AFS.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getUpperTriangularity">
<code class="sig-name descname">getUpperTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS upper triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS upper triangularity.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>deltau (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getLowerTriangularity">
<code class="sig-name descname">getLowerTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS lower triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS lower triangularity.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>deltal (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getShaping">
<code class="sig-name descname">getShaping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getShaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getShaping" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls LCFS elongation and upper/lower triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (kappa, delta_u, delta_l)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getMagR">
<code class="sig-name descname">getMagR</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis major radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of major radius of magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>magR (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getMagZ">
<code class="sig-name descname">getMagZ</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis Z.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of Z of magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>magZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getAreaLCFS">
<code class="sig-name descname">getAreaLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS cross-sectional area.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>2</em>) – unit for LCFS area.  Defaults to 2,
denoting default areal unit (typically m^2).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of LCFS area.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>areaLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getAOut">
<code class="sig-name descname">getAOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius at LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for minor radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of LCFS outboard-midplane minor radius.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>aOut (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getRmidOut">
<code class="sig-name descname">getRmidOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane major radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for major radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getGeometry">
<code class="sig-name descname">getGeometry</code><span class="sig-paren">(</span><em class="sig-param">length_unit=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls dimensional geometry parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (magR,magZ,areaLCFS,aOut,RmidOut)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>returns profile of safety factor q.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of q on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qpsi (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQ0">
<code class="sig-name descname">getQ0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on magnetic axis,q0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q(psi=0).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q0 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQ95">
<code class="sig-name descname">getQ95</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q at 95% flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q(psi=0.95).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q95 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQLCFS">
<code class="sig-name descname">getQLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on LCFS (interpolated).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQ1Surf">
<code class="sig-name descname">getQ1Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=1 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQ2Surf">
<code class="sig-name descname">getQ2Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=2 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQ3Surf">
<code class="sig-name descname">getQ3Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=3 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getQs">
<code class="sig-name descname">getQs</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls q values.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBtVac">
<code class="sig-name descname">getBtVac</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vacuum toroidal field on-axis. THIS MAY BE INCORRECT</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of vacuum toroidal field.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtVac (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBtPla">
<code class="sig-name descname">getBtPla</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>returns on-axis plasma toroidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBpAvg">
<code class="sig-name descname">getBpAvg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>returns average poloidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getFields">
<code class="sig-name descname">getFields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls vacuum and plasma toroidal field, avg poloidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getIpCalc">
<code class="sig-name descname">getIpCalc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Plasma Current, is the same as getIpMeas.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of the reconstructed plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpCalc (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getIpMeas">
<code class="sig-name descname">getIpMeas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetics-measured plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpMeas (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getJp">
<code class="sig-name descname">getJp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated plasma current density Jp on flux grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,nz,nr] array of current density.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Jp (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBetaT">
<code class="sig-name descname">getBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBetaP">
<code class="sig-name descname">getBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of the calculated average poloidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaP (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getLi">
<code class="sig-name descname">getLi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated internal inductance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of the calculated internal inductance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Li (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG afs system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBetas">
<code class="sig-name descname">getBetas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls calculated betap, betat, internal inductance.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getDiamagFlux">
<code class="sig-name descname">getDiamagFlux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the measured diamagnetic-loop flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getDiamagBetaT">
<code class="sig-name descname">getDiamagBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getDiamagBetaP">
<code class="sig-name descname">getDiamagBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop avg poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getDiamagTauE">
<code class="sig-name descname">getDiamagTauE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getDiamagWp">
<code class="sig-name descname">getDiamagWp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getDiamag">
<code class="sig-name descname">getDiamag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls diamagnetic flux measurements, toroidal and poloidal beta,
energy confinement time and stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getWMHD">
<code class="sig-name descname">getWMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns calculated MHD stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of the calculated stored energy.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>WMHD (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG afs system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getTauMHD">
<code class="sig-name descname">getTauMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated MHD energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getPinj">
<code class="sig-name descname">getPinj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the injected power.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p></li>
<li><p><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getWbdot">
<code class="sig-name descname">getWbdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated d/dt of magnetic stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getWpdot">
<code class="sig-name descname">getWpdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the calculated d/dt of plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getBCentr">
<code class="sig-name descname">getBCentr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getBCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getBCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Vacuum toroidal magnetic field at center of plasma</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of B_t at center [T]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>B_cent (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG afs system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getRCentr">
<code class="sig-name descname">getRCentr</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getRCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getRCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Radius of BCenter measurement</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Radial position where Bcent calculated [m]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getEnergy">
<code class="sig-name descname">getEnergy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls the calculated energy parameters - stored energy, tau_E,
injected power, d/dt of magnetic and plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for masking, plotting
routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<cite>R_limiter</cite>, <cite>Z_limiter</cite>)</p>
<ul class="simple">
<li><p><strong>R_limiter</strong> (<cite>Array</cite>) - [n] array of x-values for machine cross-section.</p></li>
<li><p><strong>Z_limiter</strong> (<cite>Array</cite>) - [n] array of y-values for machine cross-section.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getMachineCrossSectionFull">
<code class="sig-name descname">getMachineCrossSectionFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for plotting routines.</p>
<p>Absent additional vector-graphic data on machine cross-section, returns
<a class="reference internal" href="#eqtools.AUGData.AUGDDData.getMachineCrossSection" title="eqtools.AUGData.AUGDDData.getMachineCrossSection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getMachineCrossSection()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>result from getMachineCrossSection().</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getCurrentSign">
<code class="sig-name descname">getCurrentSign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the current, based on the check in Steve Wolfe’s
IDL implementation efit_rz2psi.pro.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1 for positive-direction current, -1 for negative.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>currentSign (Integer)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getParam">
<code class="sig-name descname">getParam</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Backup function, applying a direct path input for tree-like data
storage access for parameters not typically found in
<code class="xref py py-class docutils literal notranslate"><span class="pre">Equilbrium</span></code> object.
Directly calls attributes read from g/a-files in copy-safe manner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>String</em>) – Parameter name for value stored in EqdskReader
instance.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Not implemented on ASDEX-Upgrade reconstructions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.getSSQ">
<code class="sig-name descname">getSSQ</code><span class="sig-paren">(</span><em class="sig-param">inp</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.getSSQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.getSSQ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns single value quantities in the case SV file doesn’t exist
and coniditions the data in a way that is expected from a dd SV
shotfile. This seamlessly hides the lack of an SV file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>corresponding data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>signal (dd.signal Object)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from the AUG AFS system.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.rz2BR">
<code class="sig-name descname">rz2BR</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.rz2BR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.rz2BR" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the major radial component of the magnetic field at the given (R, Z, t) coordinates.</p>
<p>Uses</p>
<div class="math">
<p><img src="_images/math/551bd2506a6702b97f3ce0bb6af1ab14f56490bb.png" alt="B_R = -\frac{1}{2 \pi R}\frac{\partial \psi}{\partial Z}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to radial field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to radial field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>BR</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>BR</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>BR</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>BR</cite> or (<cite>BR</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>BR</strong> (<cite>Array or scalar float</cite>) - The major radial component of
the magnetic field. If all of the input arguments are scalar, then
a scalar is returned. Otherwise, a scipy Array is returned. If <cite>R</cite>
and <cite>Z</cite> both have the same shape then <cite>BR</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>BR</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>BR</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code> abstract class.</p>
<p>Find single BR value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find BR values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BR values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.AUGDDData.rz2BZ">
<code class="sig-name descname">rz2BZ</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDData.rz2BZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDData.rz2BZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the vertical component of the magnetic field at the given (R, Z, t) coordinates.</p>
<p>Uses</p>
<div class="math">
<p><img src="_images/math/e435ccdaa04982be4c9e9dd7423c106b71059906.png" alt="B_Z = \frac{1}{2 \pi R}\frac{\partial \psi}{\partial R}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to vertical field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to vertical field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>BZ</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>BZ</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>BZ</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>BZ</cite> or (<cite>BZ</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>BZ</strong> (<cite>Array or scalar float</cite>) - The vertical component of the
magnetic field. If all of the input arguments are scalar, then a
scalar is returned. Otherwise, a scipy Array is returned. If <cite>R</cite>
and <cite>Z</cite> both have the same shape then <cite>BZ</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>BZ</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>BZ</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code> abstract class.</p>
<p>Find single BZ value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find BZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BZ values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.AUGData.YGCAUGInterface">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.AUGData.</code><code class="sig-name descname">YGCAUGInterface</code><a class="reference internal" href="_modules/eqtools/AUGData.html#YGCAUGInterface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.YGCAUGInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="eqtools.AUGData.YGCAUGInterface.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><em class="sig-param">shot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#YGCAUGInterface.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.YGCAUGInterface.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for masking, plotting
routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<cite>R_limiter</cite>, <cite>Z_limiter</cite>)</p>
<ul class="simple">
<li><p><strong>R_limiter</strong> (<cite>Array</cite>) - [n] array of x-values for machine cross-section.</p></li>
<li><p><strong>Z_limiter</strong> (<cite>Array</cite>) - [n] array of y-values for machine cross-section.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.AUGData.YGCAUGInterface.getMachineCrossSectionFull">
<code class="sig-name descname">getMachineCrossSectionFull</code><span class="sig-paren">(</span><em class="sig-param">shot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#YGCAUGInterface.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.YGCAUGInterface.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for plotting routines.</p>
<p>Absent additional vector-graphic data on machine cross-section, returns
<a class="reference internal" href="#eqtools.AUGData.YGCAUGInterface.getMachineCrossSection" title="eqtools.AUGData.YGCAUGInterface.getMachineCrossSection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getMachineCrossSection()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>result from getMachineCrossSection().</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.AUGData.AUGDDDataProp">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.AUGData.</code><code class="sig-name descname">AUGDDDataProp</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">shotfile='EQH'</em>, <em class="sig-param">edition=0</em>, <em class="sig-param">shotfile2=None</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em>, <em class="sig-param">experiment='AUGD'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/AUGData.html#AUGDDDataProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.AUGData.AUGDDDataProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.AUGData.AUGDDData" title="eqtools.AUGData.AUGDDData"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.AUGData.AUGDDData</span></code></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.PropertyAccessMixin</span></code></a></p>
<p>AUGDDData with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools.CModEFIT">
<span id="eqtools-cmodefit-module"></span><h2>eqtools.CModEFIT module<a class="headerlink" href="#module-eqtools.CModEFIT" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes inheriting <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> for
working with C-Mod EFIT data.</p>
<dl class="class">
<dt id="eqtools.CModEFIT.CModEFITTree">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.CModEFIT.</code><code class="sig-name descname">CModEFITTree</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='ANALYSIS'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='g_eqdsk'</em>, <em class="sig-param">afile='a_eqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a></p>
<p>Inherits <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> class. Machine-specific data
handling class for Alcator C-Mod. Pulls EFIT data from selected MDS tree
and shot, stores as object attributes. Each EFIT variable or set of
variables is recovered with a corresponding getter method. Essential data
for EFIT mapping are pulled on initialization (e.g. psirz grid). Additional
data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes C-Mod version of EFITTree object.  Pulls data from MDS tree for
storage in instance attributes.  Core attributes are populated from the MDS
tree on initialization.  Additional attributes are initialized as None,
filled on the first request to the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shot</strong> (<em>integer</em>) – C-Mod shot index.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tree</strong> (<em>string</em>) – Optional input for EFIT tree, defaults to ‘ANALYSIS’
(i.e., EFIT data are under analysis::top.efit.results).
For any string TREE (such as ‘EFIT20’) other than ‘ANALYSIS’,
data are taken from TREE::top.results.</p></li>
<li><p><strong>length_unit</strong> (<em>string</em>) – <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>gfile</strong> (<em>string</em>) – Optional input for EFIT geqdsk location name,
defaults to ‘g_eqdsk’ (i.e., EFIT data are under
tree::top.results.G_EQDSK)</p></li>
<li><p><strong>afile</strong> (<em>string</em>) – Optional input for EFIT aeqdsk location name,
defaults to ‘a_eqdsk’ (i.e., EFIT data are under
tree::top.results.A_EQDSK)</p></li>
<li><p><strong>tspline</strong> (<em>Boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>Boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for plasma volume.  Defaults to 3,
indicating default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of volume within flux surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fluxVol (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of Rmid.  Defaults to 1, indicating
the default parameter unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of maximum (outboard) major radius of
flux surface psi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Value Error</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getF">
<code class="sig-name descname">getF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov
solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of F=RB_{Phi}(Psi)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>F (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getFluxPres">
<code class="sig-name descname">getFluxPres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>returns pressure at flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>p (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getFFPrime">
<code class="sig-name descname">getFFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF’ function used for grad-shafranov solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of FF’ fromgrad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>FFprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getPPrime">
<code class="sig-name descname">getPPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure gradient on flux surface
psi from grad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>returns profile of safety factor q.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of q on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qpsi (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of R of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>RLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of Z of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ZLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getMachineCrossSectionFull">
<code class="sig-name descname">getMachineCrossSectionFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls C-Mod cross-section data from tree, converts to plottable
vector format for use in other plotting routines</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<cite>x</cite>, <cite>y</cite>)</p>
<ul class="simple">
<li><p><strong>x</strong> (<cite>Array</cite>) - [n] array of x-values for machine cross-section.</p></li>
<li><p><strong>y</strong> (<cite>Array</cite>) - [n] array of y-values for machine cross-section.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getRCentr">
<code class="sig-name descname">getRCentr</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getRCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getRCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT radius where Bcentr evaluated</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Radial position where Bcent calculated [m]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.CModEFIT.CModEFITTreeProp">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.CModEFIT.</code><code class="sig-name descname">CModEFITTreeProp</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='ANALYSIS'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='g_eqdsk'</em>, <em class="sig-param">afile='a_eqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTreeProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTreeProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.CModEFIT.CModEFITTree" title="eqtools.CModEFIT.CModEFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.CModEFIT.CModEFITTree</span></code></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.PropertyAccessMixin</span></code></a></p>
<p>CModEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools.D3DEFIT">
<span id="eqtools-d3defit-module"></span><h2>eqtools.D3DEFIT module<a class="headerlink" href="#module-eqtools.D3DEFIT" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes inheriting <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> for
working with DIII-D EFIT data.</p>
<dl class="class">
<dt id="eqtools.D3DEFIT.D3DEFITTree">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.D3DEFIT.</code><code class="sig-name descname">D3DEFITTree</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='EFIT01'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='geqdsk'</em>, <em class="sig-param">afile='aeqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/D3DEFIT.html#D3DEFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.D3DEFIT.D3DEFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a></p>
<p>Inherits <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> class. Machine-specific data
handling class for DIII-D. Pulls EFIT data from selected MDS tree
and shot, stores as object attributes. Each EFIT variable or set of
variables is recovered with a corresponding getter method. Essential data
for EFIT mapping are pulled on initialization (e.g. psirz grid). Additional
data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes DIII-D version of EFITTree object.  Pulls data from MDS tree for
storage in instance attributes.  Core attributes are populated from the MDS
tree on initialization.  Additional attributes are initialized as None,
filled on the first request to the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shot</strong> (<em>integer</em>) – DIII-D shot index.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tree</strong> (<em>string</em>) – Optional input for EFIT tree, defaults to ‘EFIT01’
(i.e., EFIT data are under EFIT01::top.results).</p></li>
<li><p><strong>length_unit</strong> (<em>string</em>) – <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>gfile</strong> (<em>string</em>) – Optional input for EFIT geqdsk location name,
defaults to ‘geqdsk’ (i.e., EFIT data are under
tree::top.results.GEQDSK)</p></li>
<li><p><strong>afile</strong> (<em>string</em>) – Optional input for EFIT aeqdsk location name,
defaults to ‘aeqdsk’ (i.e., EFIT data are under
tree::top.results.AEQDSK)</p></li>
<li><p><strong>tspline</strong> (<em>Boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>Boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.D3DEFIT.D3DEFITTree.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/D3DEFIT.html#D3DEFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.D3DEFIT.D3DEFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented in D3DEFIT tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>volume within flux surface [psi,t]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.D3DEFIT.D3DEFITTree.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/D3DEFIT.html#D3DEFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.D3DEFIT.D3DEFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of Rmid.  Defaults to 1, indicating
the default parameter unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of maximum (outboard) major radius of
flux surface psi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Value Error</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.D3DEFIT.D3DEFITTreeProp">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.D3DEFIT.</code><code class="sig-name descname">D3DEFITTreeProp</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='EFIT01'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='geqdsk'</em>, <em class="sig-param">afile='aeqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/D3DEFIT.html#D3DEFITTreeProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.D3DEFIT.D3DEFITTreeProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.D3DEFIT.D3DEFITTree" title="eqtools.D3DEFIT.D3DEFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.D3DEFIT.D3DEFITTree</span></code></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.PropertyAccessMixin</span></code></a></p>
<p>D3DEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools.EFIT">
<span id="eqtools-efit-module"></span><h2>eqtools.EFIT module<a class="headerlink" href="#module-eqtools.EFIT" title="Permalink to this headline">¶</a></h2>
<p>Provides class inheriting <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.Equilibrium</span></code></a> for working
with EFIT data.</p>
<dl class="class">
<dt id="eqtools.EFIT.EFITTree">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.EFIT.</code><code class="sig-name descname">EFITTree</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree</em>, <em class="sig-param">root</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='g_eqdsk'</em>, <em class="sig-param">afile='a_eqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.Equilibrium</span></code></a></p>
<p>Inherits <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> class.
EFIT-specific data handling class for machines using standard EFIT tag
names/tree structure with MDSplus.  Constructor and/or data loading may
need overriding in a machine-specific implementation.  Pulls EFIT data
from selected MDS tree and shot, stores as object attributes.  Each EFIT
variable or set of variables is recovered with a corresponding getter
method.  Essential data for EFIT mapping are pulled on initialization
(e.g. psirz grid).  Additional data are pulled at the first request and
stored for subsequent usage.</p>
<p>Intializes <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">EFITTree</span></code></a> object. Pulls data from MDS tree for
storage in instance attributes. Core attributes are populated from the MDS
tree on initialization. Additional attributes are initialized as None,
filled on the first request to the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shot</strong> (<em>integer</em>) – Shot number</p></li>
<li><p><strong>tree</strong> (<em>string</em>) – MDSplus tree to open to fetch EFIT data.</p></li>
<li><p><strong>root</strong> (<em>string</em>) – Root path for EFIT data in MDSplus tree.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>length_unit</strong> (<em>string</em>) – <p>Sets the base unit used for any
quantity whose dimensions are length to any power.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>tspline</strong> (<em>boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be
monotonically increasing. Default is False (use slower,
safer method).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getInfo">
<code class="sig-name descname">getInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>returns namedtuple of shot information</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>namedtuple containing</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>shot</p></td>
<td><p>C-Mod shot index (long)</p></td>
</tr>
<tr class="row-even"><td><p>tree</p></td>
<td><p>EFIT tree (string)</p></td>
</tr>
<tr class="row-odd"><td><p>nr</p></td>
<td><p>size of R-axis for spatial grid</p></td>
</tr>
<tr class="row-even"><td><p>nz</p></td>
<td><p>size of Z-axis for spatial grid</p></td>
</tr>
<tr class="row-odd"><td><p>nt</p></td>
<td><p>size of timebase for flux grid</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getTimeBase">
<code class="sig-name descname">getTimeBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT time base vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of time points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>time (array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT flux grid.</p>
<p>Note that this method preserves whatever sign convention is used in the
tree. For C-Mod, this means that the result should be multiplied by
-1 * <a class="reference internal" href="#eqtools.EFIT.EFITTree.getCurrentSign" title="eqtools.EFIT.EFITTree.getCurrentSign"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCurrentSign()</span></code></a> in most cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,nz,nr] array of (non-normalized) flux on grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiRZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRGrid">
<code class="sig-name descname">getRGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT R-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nr] array of R-axis of flux grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rGrid (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getZGrid">
<code class="sig-name descname">getZGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT Z-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nz] array of Z-axis of flux grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>zGrid (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxAxis">
<code class="sig-name descname">getFluxAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi on magnetic axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of psi on magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiAxis (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxLCFS">
<code class="sig-name descname">getFluxLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi at separatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of psi at LCFS.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for plasma volume.  Defaults to 3,
indicating default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of volume within flux surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fluxVol (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getVolLCFS">
<code class="sig-name descname">getVolLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for LCFS volume.  Defaults to 3,
denoting default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of volume within LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>volLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of Rmid.  Defaults to 1, indicating
the default parameter unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of maximum (outboard) major radius of
flux surface psi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Value Error</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of R of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>RLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of Z of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ZLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.remapLCFS">
<code class="sig-name descname">remapLCFS</code><span class="sig-paren">(</span><em class="sig-param">mask=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites RLCFS, ZLCFS values pulled from EFIT with
explicitly-calculated contour of psinorm=1 surface.  This is then masked
down by the limiter array using core.inPolygon, restricting the contour
to the closed plasma surface and the divertor legs.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>mask</strong> (<em>Boolean</em>) – Default False.  Set True to mask LCFS path to
limiter outline (using inPolygon).  Set False to draw full
contour of psi = psiLCFS.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NotImplementedError</strong> – if <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> is not loaded.</p></li>
<li><p><strong>ValueError</strong> – if limiter outline is not available.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getF">
<code class="sig-name descname">getF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov
solutions.</p>
<p>Note that this method preserves whatever sign convention is used in the
tree. For C-Mod, this means that the result should be multiplied by
-1 * <a class="reference internal" href="#eqtools.EFIT.EFITTree.getCurrentSign" title="eqtools.EFIT.EFITTree.getCurrentSign"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCurrentSign()</span></code></a> in most cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of F=RB_{Phi}(Psi)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>F (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxPres">
<code class="sig-name descname">getFluxPres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>returns pressure at flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>p (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFFPrime">
<code class="sig-name descname">getFFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF’ function used for grad-shafranov solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of FF’ fromgrad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>FFprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getPPrime">
<code class="sig-name descname">getPPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure gradient on flux surface
psi from grad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getElongation">
<code class="sig-name descname">getElongation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS elongation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS elongation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>kappa (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getUpperTriangularity">
<code class="sig-name descname">getUpperTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS upper triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS upper triangularity.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>deltau (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getLowerTriangularity">
<code class="sig-name descname">getLowerTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS lower triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS lower triangularity.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>deltal (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getShaping">
<code class="sig-name descname">getShaping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getShaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getShaping" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls LCFS elongation and upper/lower triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (kappa, delta_u, delta_l)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMagR">
<code class="sig-name descname">getMagR</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis major radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of major radius of magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>magR (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMagZ">
<code class="sig-name descname">getMagZ</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis Z.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of Z of magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>magZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getAreaLCFS">
<code class="sig-name descname">getAreaLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS cross-sectional area.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>2</em>) – unit for LCFS area.  Defaults to 2,
denoting default areal unit (typically m^2).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of LCFS area.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>areaLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getAOut">
<code class="sig-name descname">getAOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius at LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for minor radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of LCFS outboard-midplane minor radius.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>aOut (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRmidOut">
<code class="sig-name descname">getRmidOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane major radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for major radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of major radius of LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>RmidOut (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getGeometry">
<code class="sig-name descname">getGeometry</code><span class="sig-paren">(</span><em class="sig-param">length_unit=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls dimensional geometry parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (magR,magZ,areaLCFS,aOut,RmidOut)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>returns profile of safety factor q.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of q on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qpsi (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ0">
<code class="sig-name descname">getQ0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on magnetic axis,q0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q(psi=0).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q0 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ95">
<code class="sig-name descname">getQ95</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q at 95% flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q(psi=0.95).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q95 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQLCFS">
<code class="sig-name descname">getQLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on LCFS (interpolated).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q* (interpolated).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ1Surf">
<code class="sig-name descname">getQ1Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=1 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for minor radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of minor radius of q=1 surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>qr1 (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ2Surf">
<code class="sig-name descname">getQ2Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=2 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for minor radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of minor radius of q=2 surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>qr2 (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ3Surf">
<code class="sig-name descname">getQ3Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=3 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for minor radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of minor radius of q=3 surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>qr3 (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQs">
<code class="sig-name descname">getQs</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls q values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (q0,q95,qLCFS,rq1,rq2,rq3).</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBtVac">
<code class="sig-name descname">getBtVac</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vacuum toroidal field on-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of vacuum toroidal field.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtVac (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBtPla">
<code class="sig-name descname">getBtPla</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>returns on-axis plasma toroidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of toroidal field including plasma effects.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtPla (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBpAvg">
<code class="sig-name descname">getBpAvg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>returns average poloidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of average poloidal field.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BpAvg (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFields">
<code class="sig-name descname">getFields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls vacuum and plasma toroidal field, avg poloidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (btaxv,btaxp,bpolav).</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getIpCalc">
<code class="sig-name descname">getIpCalc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-reconstructed plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpCalc (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getIpMeas">
<code class="sig-name descname">getIpMeas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetics-measured plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpMeas (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getJp">
<code class="sig-name descname">getJp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current density Jp on flux grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,nz,nr] array of current density.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Jp (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBetaT">
<code class="sig-name descname">getBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-calculated average toroidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaT (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBetaP">
<code class="sig-name descname">getBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-calculated average poloidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaP (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getLi">
<code class="sig-name descname">getLi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated internal inductance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-calculated internal inductance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Li (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBetas">
<code class="sig-name descname">getBetas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls calculated betap, betat, internal inductance</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (betat,betap,Li)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagFlux">
<code class="sig-name descname">getDiamagFlux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>returns measured diamagnetic-loop flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of diamagnetic-loop flux.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Flux (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagBetaT">
<code class="sig-name descname">getDiamagBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured toroidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaT (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagBetaP">
<code class="sig-name descname">getDiamagBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop avg poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured poloidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaP (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagTauE">
<code class="sig-name descname">getDiamagTauE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured energy confinement time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tauE (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagWp">
<code class="sig-name descname">getDiamagWp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured plasma stored energy.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Wp (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamag">
<code class="sig-name descname">getDiamag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls diamagnetic flux measurements, toroidal and poloidal beta,
energy confinement time and stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (diamag. flux, betatd, betapd, tauDiamag, WDiamag)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getWMHD">
<code class="sig-name descname">getWMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated MHD stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-calculated stored energy.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>WMHD (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getTauMHD">
<code class="sig-name descname">getTauMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated MHD energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-calculated energy confinement time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tauMHD (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getPinj">
<code class="sig-name descname">getPinj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated injected power.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-reconstructed injected power.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Pinj (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getWbdot">
<code class="sig-name descname">getWbdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated d/dt of magnetic stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of d(Wb)/dt</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dWdt (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getWpdot">
<code class="sig-name descname">getWpdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated d/dt of plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of d(Wp)/dt</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dWdt (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBCentr">
<code class="sig-name descname">getBCentr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-Vacuum toroidal magnetic field in Tesla at Rcentr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of B_t at center [T]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>B_cent (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRCentr">
<code class="sig-name descname">getRCentr</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT radius where Bcentr evaluated</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Radial position where Bcent calculated [m]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getEnergy">
<code class="sig-name descname">getEnergy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls EFIT-calculated energy parameters - stored energy, tau_E,
injected power, d/dt of magnetic and plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing (WMHD,tauMHD,Pinj,Wbdot,Wpdot)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for masking, plotting
routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<cite>R_limiter</cite>, <cite>Z_limiter</cite>)</p>
<ul class="simple">
<li><p><strong>R_limiter</strong> (<cite>Array</cite>) - [n] array of x-values for machine cross-section.</p></li>
<li><p><strong>Z_limiter</strong> (<cite>Array</cite>) - [n] array of y-values for machine cross-section.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMachineCrossSectionFull">
<code class="sig-name descname">getMachineCrossSectionFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for plotting routines.</p>
<p>Absent additional vector-graphic data on machine cross-section, returns
<a class="reference internal" href="#eqtools.EFIT.EFITTree.getMachineCrossSection" title="eqtools.EFIT.EFITTree.getMachineCrossSection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getMachineCrossSection()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>result from getMachineCrossSection().</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getCurrentSign">
<code class="sig-name descname">getCurrentSign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the current, based on the check in Steve Wolfe’s
IDL implementation efit_rz2psi.pro.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1 for positive-direction current, -1 for negative.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>currentSign (Integer)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getParam">
<code class="sig-name descname">getParam</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Backup function, applying a direct path input for tree-like data
storage access for parameters not typically found in
<code class="xref py py-class docutils literal notranslate"><span class="pre">Equilbrium</span></code> object.
Directly calls attributes read from g/a-files in copy-safe manner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>String</em>) – Parameter name for value stored in EqdskReader
instance.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AttributeError</strong> – raised if no attribute is found.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.FromArrays">
<span id="eqtools-fromarrays-module"></span><h2>eqtools.FromArrays module<a class="headerlink" href="#module-eqtools.FromArrays" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="eqtools.FromArrays.ArrayEquilibrium">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.FromArrays.</code><code class="sig-name descname">ArrayEquilibrium</code><span class="sig-paren">(</span><em class="sig-param">psiRZ</em>, <em class="sig-param">rGrid</em>, <em class="sig-param">zGrid</em>, <em class="sig-param">time</em>, <em class="sig-param">q</em>, <em class="sig-param">fluxVol</em>, <em class="sig-param">psiLCFS</em>, <em class="sig-param">psiAxis</em>, <em class="sig-param">rmag</em>, <em class="sig-param">zmag</em>, <em class="sig-param">Rout</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.Equilibrium</span></code></a></p>
<p>Class to represent an equilibrium specified as arrays of data.</p>
<p>Create ArrayEquilibrium instance from arrays of data.</p>
<p>Has very little checking on the shape/type of the arrays at this point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psiRZ</strong> – Array-like, (M, N, P).
Flux values at M times, N Z locations and P R locations.</p></li>
<li><p><strong>rGrid</strong> – Array-like, (P,).
R coordinates that psiRZ is given at.</p></li>
<li><p><strong>zGrid</strong> – Array-like, (N,).
Z coordinates that psiRZ is given at.</p></li>
<li><p><strong>time</strong> – Array-like, (M,).
Times that psiRZ is given at.</p></li>
<li><p><strong>q</strong> – Array-like, (S, M).
q profile evaluated at S values of psinorm from 0 to 1, given at M
times.</p></li>
<li><p><strong>fluxVol</strong> – Array-like, (S, M).
Flux surface volumes evaluated at S values of psinorm from 0 to 1,
given at M times.</p></li>
<li><p><strong>psiLCFS</strong> – Array-like, (M,).
Flux at the last closed flux surface, given at M times.</p></li>
<li><p><strong>psiAxis</strong> – Array-like, (M,).
Flux at the magnetic axis, given at M times.</p></li>
<li><p><strong>rmag</strong> – Array-like, (M,).
Radial coordinate of the magnetic axis, given at M times.</p></li>
<li><p><strong>zmag</strong> – Array-like, (M,).
Vertical coordinate of the magnetic axis, given at M times.</p></li>
<li><p><strong>Rout</strong> – Outboard midplane radius of the last closed flux surface.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>length_unit</strong> – <p>String.
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>tspline</strong> – Boolean.
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> – Boolean.
Sets whether or not the “monotonic” form of time window
finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
<li><p><strong>verbose</strong> – Boolean.
Allows or blocks console readout during operation.  Defaults to True,
displaying useful information for the user.  Set to False for quiet
usage or to avoid console clutter for multiple instances.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getTimeBase">
<code class="sig-name descname">getTimeBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the time base vector, array dimensions are (M,).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the flux array, dimensions are (M, N, P), corresponding to (time, Z, R).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getRGrid">
<code class="sig-name descname">getRGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the radial grid, dimensions are (P,).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getZGrid">
<code class="sig-name descname">getZGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the vertical grid, dimensions are (N,).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q profile (over Q values of psinorm from 0 to 1), dimensions are (Q, M)</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxLCFS">
<code class="sig-name descname">getFluxLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi at separatrix [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxAxis">
<code class="sig-name descname">getFluxAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi on magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getMagR">
<code class="sig-name descname">getMagR</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getMagZ">
<code class="sig-name descname">getMagZ</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis Z [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getRmidOut">
<code class="sig-name descname">getRmidOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns R-positions (n points) mapping LCFS [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns Z-positions (n points) mapping LCFS [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getCurrentSign">
<code class="sig-name descname">getCurrentSign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated current direction, where CCW = +</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.NSTXEFIT">
<span id="eqtools-nstxefit-module"></span><h2>eqtools.NSTXEFIT module<a class="headerlink" href="#module-eqtools.NSTXEFIT" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes inheriting <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> for
working with NSTX EFIT data.</p>
<dl class="class">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.NSTXEFIT.</code><code class="sig-name descname">NSTXEFITTree</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='EFIT01'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='geqdsk'</em>, <em class="sig-param">afile='aeqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a></p>
<p>Inherits <code class="xref py py-class docutils literal notranslate"><span class="pre">EFITTree</span></code> class. Machine-specific data
handling class for the National Spherical Torus Experiment (NSTX). Pulls EFIT
data from selected MDS tree and shot, stores as object attributes. Each EFIT
variable or set of variables is recovered with a corresponding getter method.
Essential data for EFIT mapping are pulled on initialization (e.g. psirz grid).
Additional data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes NSTX version of EFITTree object.  Pulls data from MDS tree for storage
in instance attributes.  Core attributes are populated from the MDS tree on initialization.
Additional attributes are initialized as None, filled on the first request to the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shot</strong> (<em>integer</em>) – NSTX shot index (long)</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tree</strong> (<em>string</em>) – Optional input for EFIT tree, defaults to ‘EFIT01’
(i.e., EFIT data are under EFIT01::top.results).</p></li>
<li><p><strong>length_unit</strong> (<em>string</em>) – <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>gfile</strong> (<em>string</em>) – Optional input for EFIT geqdsk location name,
defaults to ‘geqdsk’ (i.e., EFIT data are under
tree::top.results.GEQDSK)</p></li>
<li><p><strong>afile</strong> (<em>string</em>) – Optional input for EFIT aeqdsk location name,
defaults to ‘aeqdsk’ (i.e., EFIT data are under
tree::top.results.AEQDSK)</p></li>
<li><p><strong>tspline</strong> (<em>Boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>Boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT flux grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,nz,nr] array of (non-normalized) flux on grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiRZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for masking, plotting routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The requested data.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented in NSTXEFIT tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>volume within flux surface [psi,t]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of Rmid.  Defaults to 1, indicating
the default parameter unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of maximum (outboard) major radius of
flux surface psi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Value Error</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getIpCalc">
<code class="sig-name descname">getIpCalc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-reconstructed plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpCalc (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getVolLCFS">
<code class="sig-name descname">getVolLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for LCFS volume.  Defaults to 3,
denoting default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of volume within LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>volLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getJp">
<code class="sig-name descname">getJp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented in NSTXEFIT tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>EFIT-calculated plasma current density Jp on flux grid [t,r,z]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.rz2volnorm">
<code class="sig-name descname">rz2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.rz2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.rz2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculated normalized volume of flux surfaces not stored in NSTX EFIT.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All mapping with Volnorm not implemented</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.psinorm2volnorm">
<code class="sig-name descname">psinorm2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.psinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.psinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculated normalized volume of flux surfaces not stored in NSTX EFIT.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All maping with Volnorm not implemented</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.NSTXEFIT.NSTXEFITTreeProp">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.NSTXEFIT.</code><code class="sig-name descname">NSTXEFITTreeProp</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='EFIT01'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='geqdsk'</em>, <em class="sig-param">afile='aeqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTreeProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTreeProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.NSTXEFIT.NSTXEFITTree" title="eqtools.NSTXEFIT.NSTXEFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.NSTXEFIT.NSTXEFITTree</span></code></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.PropertyAccessMixin</span></code></a></p>
<p>NSTXEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools.TCVLIUQE">
<span id="eqtools-tcvliuqe-module"></span><h2>eqtools.TCVLIUQE module<a class="headerlink" href="#module-eqtools.TCVLIUQE" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes inheriting <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> for
working with TCV LIUQE Equilibrium.</p>
<dl class="function">
<dt id="eqtools.TCVLIUQE.greenArea">
<code class="sig-prename descclassname">eqtools.TCVLIUQE.</code><code class="sig-name descname">greenArea</code><span class="sig-paren">(</span><em class="sig-param">vs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#greenArea"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.greenArea" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.TCVLIUQE.</code><code class="sig-name descname">TCVLIUQETree</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='tcv_shot'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='g_eqdsk'</em>, <em class="sig-param">afile='a_eqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a></p>
<p>Inherits <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.EFIT.EFITTree</span></code></a> class. Machine-specific data
handling class for TCV Machine. Pulls LIUQUE data from selected MDS tree
and shot, stores as object attributes eventually transforming it in the
equivalent quantity for EFIT. Each  variable or set of
variables is recovered with a corresponding getter method. Essential data
for LIUQUE mapping are pulled on initialization (e.g. psirz grid). Additional
data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes TCV version of EFITTree object.  Pulls data from MDS tree for
storage in instance attributes.  Core attributes are populated from the MDS
tree on initialization.  Additional attributes are initialized as None,
filled on the first request to the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shot</strong> (<em>integer</em>) – TCV shot index.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tree</strong> (<em>string</em>) – Optional input for LIUQE tree, defaults to ‘RESULTS’
(i.e., LIUQE data are under results::).</p></li>
<li><p><strong>length_unit</strong> (<em>string</em>) – <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>gfile</strong> (<em>string</em>) – Optional input for EFIT geqdsk location name,
defaults to ‘g_eqdsk’ (i.e., EFIT data are under
tree::top.results.G_EQDSK)</p></li>
<li><p><strong>afile</strong> (<em>string</em>) – Optional input for EFIT aeqdsk location name,
defaults to ‘a_eqdsk’ (i.e., EFIT data are under
tree::top.results.A_EQDSK)</p></li>
<li><p><strong>tspline</strong> (<em>Boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>Boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getInfo">
<code class="sig-name descname">getInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>returns namedtuple of shot information</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>namedtuple containing</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>shot</p></td>
<td><p>TCV shot index (long)</p></td>
</tr>
<tr class="row-even"><td><p>tree</p></td>
<td><p>LIUQE tree (string)</p></td>
</tr>
<tr class="row-odd"><td><p>nr</p></td>
<td><p>size of R-axis for spatial grid</p></td>
</tr>
<tr class="row-even"><td><p>nz</p></td>
<td><p>size of Z-axis for spatial grid</p></td>
</tr>
<tr class="row-odd"><td><p>nt</p></td>
<td><p>size of timebase for flux grid</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getTimeBase">
<code class="sig-name descname">getTimeBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE time base vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of time points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>time (array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE flux grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,nz,nr] array of (non-normalized) flux on grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiRZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getRGrid">
<code class="sig-name descname">getRGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE R-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nr] array of R-axis of flux grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rGrid (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getZGrid">
<code class="sig-name descname">getZGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE Z-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nz] array of Z-axis of flux grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>zGrid (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getFluxAxis">
<code class="sig-name descname">getFluxAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi on magnetic axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of psi on magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiAxis (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getFluxLCFS">
<code class="sig-name descname">getFluxLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi at separatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of psi at LCFS.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface. This is not implemented in LIUQE
as default output. So we use contour and GREEN theorem to get the area
within a default grid of the PSI. Then we compute the volume by multipling
for 2pi * VolLCFS / AreaLCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for plasma volume.  Defaults to 3,
indicating default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of volume within flux surface.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fluxVol (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getVolLCFS">
<code class="sig-name descname">getVolLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>3</em>) – unit for LCFS volume.  Defaults to 3,
denoting default volumetric unit (typically m^3).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of volume within LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>volLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of Rmid.  Defaults to 1, indicating
the default parameter unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt,npsi] array of maximum (outboard) major radius of
flux surface psi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Value Error</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of R of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>RLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-values of LCFS position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,n] array of Z of LCFS points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ZLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getF">
<code class="sig-name descname">getF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov
solutions. Not implemented on LIUQE</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of F=RB_{Phi}(Psi)
Not stored on LIUQE nodes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>F (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getFluxPres">
<code class="sig-name descname">getFluxPres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>returns pressure at flux surface. Not implemented. We have pressure</dt><dd><p>saved on the same grid of psi</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure on flux surface psi.
Not implemented on LIUQE nodes. We have pressure on the grid use for psi</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>p (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getFFPrime">
<code class="sig-name descname">getFFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF’ function used for grad-shafranov solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of FF’ fromgrad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>FFprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getPPrime">
<code class="sig-name descname">getPPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of pressure gradient on flux surface
psi from grad-shafranov solution.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pprime (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getElongation">
<code class="sig-name descname">getElongation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS elongation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS elongation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>kappa (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getUpperTriangularity">
<code class="sig-name descname">getUpperTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS upper triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS upper triangularity.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>deltau (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getLowerTriangularity">
<code class="sig-name descname">getLowerTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS lower triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LCFS lower triangularity.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>deltal (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getMagR">
<code class="sig-name descname">getMagR</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis major radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of major radius of magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>magR (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getMagZ">
<code class="sig-name descname">getMagZ</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis Z.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of Z of magnetic axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>magZ (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getAreaLCFS">
<code class="sig-name descname">getAreaLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS cross-sectional area.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>2</em>) – unit for LCFS area.  Defaults to 2,
denoting default areal unit (typically m^2).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of LCFS area.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>areaLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getAOut">
<code class="sig-name descname">getAOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>returns outboard-midplane minor radius at LCFS. In LIUQE it is the last value</dt><dd><p>of</p>
</dd>
</dl>
<p>esults::r_max_psi</p>
<blockquote>
<div><dl class="simple">
<dt>Keyword Args:</dt><dd><dl class="simple">
<dt>length_unit (String or 1): unit for minor radius.  Defaults to 1,</dt><dd><p>denoting default length unit (typically m).</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>aOut (Array): [nt] array of LCFS outboard-midplane minor radius.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getRmidOut">
<code class="sig-name descname">getRmidOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane major radius. It uses getA</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit for major radius.  Defaults to 1,
denoting default length unit (typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[nt] array of major radius of LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>RmidOut (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>returns profile of safety factor q.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt,npsi] array of q on flux surface psi.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qpsi (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getQ0">
<code class="sig-name descname">getQ0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on magnetic axis,q0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q(psi=0).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q0 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getQ95">
<code class="sig-name descname">getQ95</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q at 95% flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q(psi=0.95).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q95 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getQLCFS">
<code class="sig-name descname">getQLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on LCFS (interpolated).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of q* (interpolated).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getBtVac">
<code class="sig-name descname">getBtVac</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vacuum toroidal field on-axis. We use MDSplus.Connection
for a proper use of the TDI function tcv_eq()</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of vacuum toroidal field.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtVac (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getBtPla">
<code class="sig-name descname">getBtPla</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>returns on-axis plasma toroidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of toroidal field including plasma effects.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtPla (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getIpCalc">
<code class="sig-name descname">getIpCalc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of EFIT-reconstructed plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpCalc (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getIpMeas">
<code class="sig-name descname">getIpMeas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetics-measured plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured plasma current.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpMeas (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getBetaT">
<code class="sig-name descname">getBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE-calculated toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LIUQE-calculated average toroidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaT (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getBetaP">
<code class="sig-name descname">getBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE-calculated poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LIUQE-calculated average poloidal beta.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaP (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getLi">
<code class="sig-name descname">getLi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE-calculated internal inductance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LIUQE-calculated internal inductance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Li (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getDiamagWp">
<code class="sig-name descname">getDiamagWp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of measured plasma stored energy.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Wp (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getTauMHD">
<code class="sig-name descname">getTauMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LIUQE-calculated MHD energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of LIUQE-calculated energy confinement time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tauMHD (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls TCV cross-section data from tree, converts to plottable
vector format for use in other plotting routines</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<cite>x</cite>, <cite>y</cite>)</p>
<ul class="simple">
<li><p><strong>x</strong> (<cite>Array</cite>) - [n] array of x-values for machine cross-section.</p></li>
<li><p><strong>y</strong> (<cite>Array</cite>) - [n] array of y-values for machine cross-section.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.getMachineCrossSectionPatch">
<code class="sig-name descname">getMachineCrossSectionPatch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.getMachineCrossSectionPatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.getMachineCrossSectionPatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls TCV cross-section data from tree, converts it directly to
a matplotlib patch which can be simply added to the approriate axes
call in plotFlux()</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>tiles matplotlib Patch, vessel matplotlib Patch</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.TCVLIUQE.TCVLIUQETree.plotFlux">
<code class="sig-name descname">plotFlux</code><span class="sig-paren">(</span><em class="sig-param">fill=True</em>, <em class="sig-param">mask=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETree.plotFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETree.plotFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots LIQUE TCV flux contours directly from psi grid.</p>
<p>Returns the Figure instance created and the time slider widget (in case
you need to modify the callback). <cite>f.axes</cite> contains the contour plot as
the first element and the time slice slider as the second element.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>fill</strong> (<em>Boolean</em>) – Set True to plot filled contours.  Set False (default) to plot white-background
color contours.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.TCVLIUQE.TCVLIUQETreeProp">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.TCVLIUQE.</code><code class="sig-name descname">TCVLIUQETreeProp</code><span class="sig-paren">(</span><em class="sig-param">shot</em>, <em class="sig-param">tree='tcv_shot'</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">gfile='g_eqdsk'</em>, <em class="sig-param">afile='a_eqdsk'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/TCVLIUQE.html#TCVLIUQETreeProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.TCVLIUQE.TCVLIUQETreeProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.TCVLIUQE.TCVLIUQETree" title="eqtools.TCVLIUQE.TCVLIUQETree"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.TCVLIUQE.TCVLIUQETree</span></code></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.PropertyAccessMixin</span></code></a></p>
<p>TCVLIUQETree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools.afilereader">
<span id="eqtools-afilereader-module"></span><h2>eqtools.afilereader module<a class="headerlink" href="#module-eqtools.afilereader" title="Permalink to this headline">¶</a></h2>
<p>This module contains the AFileReader class, a lightweight data
handler for a-file (time-history) datasets.</p>
<dl class="simple">
<dt>Classes:</dt><dd><dl class="simple">
<dt>AFileReader:</dt><dd><p>Data-storage class for a-file data.  Reads
data from ASCII a-file, storing as copy-safe object
attributes.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="eqtools.afilereader.AFileReader">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.afilereader.</code><code class="sig-name descname">AFileReader</code><span class="sig-paren">(</span><em class="sig-param">afile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/afilereader.html#AFileReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.afilereader.AFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to read ASCII a-file (time-history data storage) into lightweight,
user-friendly data structure.</p>
<p>A-files store data blocks of scalar time-history data for EFIT
plasma equilibrium.  Each parameter is read into a pseudo-private object
attribute (marked by a leading underscore), followed by the standard
EFIT variable names.</p>
<p>initialize object, reading from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>afile</strong> (<em>String</em>) – file path to a-file</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Load a-file data located at <cite>file_path</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">afr</span> <span class="o">=</span> <span class="n">eqtools</span><span class="o">.</span><span class="n">AFileReader</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
</pre></div>
</div>
<p>Recover a datapoint (for example, <cite>shot</cite>, stored as <cite>afr._shot</cite>),
using copy-protected __getattribute__ method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shot</span> <span class="o">=</span> <span class="n">afr</span><span class="o">.</span><span class="n">shot</span>
</pre></div>
</div>
<p>Assign a new attribute to afr – note that this will raise an
AttributeError if attempting to overwrite a previously-stored
attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">afr</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">val</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-eqtools.core">
<span id="eqtools-core-module"></span><h2>eqtools.core module<a class="headerlink" href="#module-eqtools.core" title="Permalink to this headline">¶</a></h2>
<p>This module provides the core classes for <a class="reference internal" href="#module-eqtools" title="eqtools"><code class="xref py py-mod docutils literal notranslate"><span class="pre">eqtools</span></code></a>, including the
base <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> class.</p>
<dl class="exception">
<dt id="eqtools.core.ModuleWarning">
<em class="property">exception </em><code class="sig-prename descclassname">eqtools.core.</code><code class="sig-name descname">ModuleWarning</code><a class="reference internal" href="_modules/eqtools/core.html#ModuleWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.ModuleWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Warning class to notify the user of unavailable modules.</p>
</dd></dl>

<dl class="class">
<dt id="eqtools.core.PropertyAccessMixin">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.core.</code><code class="sig-name descname">PropertyAccessMixin</code><a class="reference internal" href="_modules/eqtools/core.html#PropertyAccessMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.PropertyAccessMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin to implement access of getter methods through a property-type
interface without the need to apply a decorator to every property.</p>
<p>For any getter <cite>obj.getSomething()</cite>, the call <cite>obj.Something</cite> will do the
same thing.</p>
<p>This is accomplished by overriding <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> such that if
an attribute <cite>ATTR</cite> does not exist it then attempts to call <cite>self.getATTR()</cite>.
If <cite>self.getATTR()</cite> does not exist, an <code class="xref py py-class docutils literal notranslate"><span class="pre">AttributeError</span></code> will be
raised as usual.</p>
<p>Also overrides <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> such that it will raise an
<code class="xref py py-class docutils literal notranslate"><span class="pre">AttributeError</span></code> when attempting to write an attribute <cite>ATTR</cite> for
which there is already a method <cite>getATTR</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="eqtools.core.inPolygon">
<code class="sig-prename descclassname">eqtools.core.</code><code class="sig-name descname">inPolygon</code><span class="sig-paren">(</span><em class="sig-param">polyx</em>, <em class="sig-param">polyy</em>, <em class="sig-param">pointx</em>, <em class="sig-param">pointy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#inPolygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.inPolygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating whether a given point is within a 2D polygon.</p>
<p>Given an array of X,Y coordinates describing a 2D polygon, checks whether a
point given by x,y coordinates lies within the polygon. Operates via a
ray-casting approach - the function projects a semi-infinite ray parallel to
the positive horizontal axis, and counts how many edges of the polygon this
ray intersects. For a simply-connected polygon, this determines whether the
point is inside (even number of crossings) or outside (odd number of
crossings) the polygon, by the Jordan Curve Theorem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polyx</strong> (<em>Array-like</em>) – Array of x-coordinates of the vertices of the polygon.</p></li>
<li><p><strong>polyy</strong> (<em>Array-like</em>) – Array of y-coordinates of the vertices of the polygon.</p></li>
<li><p><strong>pointx</strong> (<em>Int</em><em> or </em><em>float</em>) – x-coordinate of test point.</p></li>
<li><p><strong>pointy</strong> (<em>Int</em><em> or </em><em>float</em>) – y-coordinate of test point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True/False result for whether the point is contained within the polygon.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>result (Boolean)</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="eqtools.core.Equilibrium">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.core.</code><code class="sig-name descname">Equilibrium</code><span class="sig-paren">(</span><em class="sig-param">length_unit='m'</em>, <em class="sig-param">tspline=False</em>, <em class="sig-param">monotonic=True</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract class of data handling object for magnetic reconstruction outputs.</p>
<p>Defines the mapping routines and method fingerprints necessary. Each
variable or set of variables is recovered with a corresponding getter method.
Essential data for mapping are pulled on initialization (psirz grid, for
example) to frontload overhead. Additional data are pulled at the first
request and stored for subsequent usage.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This abstract class should not be used directly. Device- and code-
specific subclasses are set up to account for inter-device/-code
differences in data storage.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length_unit</strong> (<em>String</em>) – <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is ‘m’ (all units taken and returned in meters).</p>
</p></li>
<li><p><strong>tspline</strong> (<em>Boolean</em>) – Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor interpolation.
Tricubic spline interpolation requires at least four complete
equilibria at different times. It is also assumed that they are
functionally correlated, and that parameters do not vary out of
their boundaries (derivative = 0 boundary condition). Default is
False (use nearest-neighbor interpolation).</p></li>
<li><p><strong>monotonic</strong> (<em>Boolean</em>) – Sets whether or not the “monotonic” form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</p></li>
<li><p><strong>verbose</strong> (<em>Boolean</em>) – Allows or blocks console readout during operation.
Defaults to True, displaying useful information for the user. Set to
False for quiet usage or to avoid console clutter for multiple
instances.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>length_unit</cite> is not a valid unit specifier.</p></li>
<li><p><strong>ValueError</strong> – If <cite>tspline</cite> is True but module trispline did not load
    successfully.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.core.Equilibrium.rho2rho">
<code class="sig-name descname">rho2rho</code><span class="sig-paren">(</span><em class="sig-param">origin</em>, <em class="sig-param">destination</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rho2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rho2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from one coordinate to another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>String</em>) – <p>Indicates which coordinates the data are given in.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>RZ</p></td>
<td><p>R,Z coordinates</p></td>
</tr>
<tr class="row-even"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-even"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-odd"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-even"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>destination</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-even"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-odd"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
<tr class="row-even"><td><p>q</p></td>
<td><p>Safety factor</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-even"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-odd"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-even"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-odd"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>rho</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the starting coordinate
to map to the new coordinate. Will be two arguments <cite>R</cite>, <cite>Z</cite> if
<cite>origin</cite> is ‘RZ’.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>rho</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>rho</cite> (or the meshgrid of <cite>R</cite>
and <cite>Z</cite> if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of <cite>rho</cite>. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>rho</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>rho</cite> or be
a scalar. Default is True (evaluate ALL <cite>rho</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Only applicable if <cite>origin</cite> is ‘RZ’. Set to
True to pass <cite>R</cite> and <cite>Z</cite> through <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code>
before evaluating. If this is set to True, <cite>R</cite> and <cite>Z</cite> must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid when <cite>destination</cite> is Rmid. Default is False
(return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that quantities are
given/returned in, as applicable. If a string is given, it must
be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>origin</cite> is not one of the supported values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2psi">
<code class="sig-name descname">rz2psi</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2psi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the passed R, Z, t arrays to psi (unnormalized poloidal flux) values.</p>
<p>What is usually returned by EFIT is the stream function,
<img class="math" src="_images/math/b54db9491b92022e6090866ffd8196d856fc7e7e.png" alt="\psi=\psi_p/(2\pi)"/> which has units of Wb/rad.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to poloidal flux. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to poloidal flux. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psi</cite> or (<cite>psi</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psi</strong> (<cite>Array or scalar float</cite>) - The unnormalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>psi</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>psi</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psi</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psi value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2psinorm">
<code class="sig-name descname">rz2psinorm</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">sqrt=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux at the given (R, Z, t).</p>
<p>Uses the definition:</p>
<div class="math">
<p><img src="_images/math/4e65498890f7e906998889a8593a862b902ffe4b.png" alt="\texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to psinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to psinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The normalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>psinorm</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>psinorm</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2phinorm">
<code class="sig-name descname">rz2phinorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux.</p>
<p>Uses the definitions:</p>
<div class="math">
<p><img src="_images/math/3fea3cea57d8b7a9bc94dbe2b95fdb0531129c0d.png" alt="\texttt{phi} &amp;= \int q(\psi)\,d\psi\\
\texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}"/></p>
</div><p>This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to phinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to phinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting psinorm to phinorm.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The normalized toroidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>phinorm</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>phinorm</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2volnorm">
<code class="sig-name descname">rz2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume.</p>
<p>Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to volnorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to volnorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting psinorm to volnorm.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The normalized volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>volnorm</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>volnorm</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2rmid">
<code class="sig-name descname">rz2rmid</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given points to the outboard midplane major radius, Rmid.</p>
<p>Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to Rmid. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to Rmid. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in,
AND that <cite>Rmid</cite> is returned in. If a string is given, it must
be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting psinorm to Rmid.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The outboard midplan major
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>Rmid</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>Rmid</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single Rmid value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find Rmid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2roa">
<code class="sig-name descname">rz2roa</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given points to the normalized minor radius, r/a.</p>
<p>Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to r/a. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to r/a. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting psinorm to Rmid.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>roa</strong> (<cite>Array or scalar float</cite>) - The normalized minor radius.
If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>roa</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>roa</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single r/a value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2rho">
<code class="sig-name descname">rz2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R, Z, t) coordinates into one of several coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to. Valid
options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-even"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-odd"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
<tr class="row-even"><td><p>q</p></td>
<td><p>Safety factor</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-even"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-odd"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-even"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-odd"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to <cite>rho</cite>. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to <cite>rho</cite>. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of <cite>rho</cite>.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid when <cite>destination</cite> is Rmid. Default is False
(return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in,
AND that <cite>Rmid</cite> is returned in. If a string is given, it must
be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>method</cite> is not one of the supported values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2roa">
<code class="sig-name descname">rmid2roa</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">sqrt=False</em>, <em class="sig-param">blob=None</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R_mid, t) coordinates into r/a.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to r/a.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>roa</strong> (<cite>Array or scalar float</cite>) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single r/a value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find roa values at R_mid points 0.6m and 0.8m at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find roa values at R_mid of 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2psinorm">
<code class="sig-name descname">rmid2psinorm</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to psinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - Normalized poloidal flux.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2phinorm">
<code class="sig-name descname">rmid2phinorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux.</p>
<p>Uses the definitions:</p>
<div class="math">
<p><img src="_images/math/9dbb7f2563fabf7aa01024a1ea4d71c43f80a806.png" alt="\texttt{phi} &amp;= \int q(\psi)\,d\psi

\texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}"/></p>
</div><p>This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to phinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - Normalized toroidal flux.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single phinorm value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at R_mid points 0.6m and 0.8m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at R_mid point 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (R, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2volnorm">
<code class="sig-name descname">rmid2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume.</p>
<p>Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to volnorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - Normalized volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single volnorm value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at R_mid points 0.6m and 0.8m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at R_mid points 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2rho">
<code class="sig-name descname">rmid2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R_mid, t) coordinates into one of several coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to. Valid
options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-even"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-even"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-odd"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-even"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-odd"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to rho.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of rho.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid points 0.6m and 0.8m at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid of 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2rmid">
<code class="sig-name descname">roa2rmid</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">blob=None</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into Rmid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to Rmid.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single R_mid value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find R_mid values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2psinorm">
<code class="sig-name descname">roa2psinorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into psinorm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to psinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2phinorm">
<code class="sig-name descname">roa2phinorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into phinorm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to phinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single phinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2volnorm">
<code class="sig-name descname">roa2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into volnorm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to volnorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single volnorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2rho">
<code class="sig-name descname">roa2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into one of several coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-even"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-odd"><td><p>q</p></td>
<td><p>Safety factor</p></td>
</tr>
<tr class="row-even"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-odd"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-even"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-odd"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-even"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to rho.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of rho.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2rmid">
<code class="sig-name descname">psinorm2rmid</code><span class="sig-paren">(</span><em class="sig-param">psi_norm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outboard R_mid location corresponding to the passed psinorm (normalized poloidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to Rmid.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of Rmid. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single R_mid value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find R_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2roa">
<code class="sig-name descname">psinorm2roa</code><span class="sig-paren">(</span><em class="sig-param">psi_norm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized minor radius location corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to r/a.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of r/a. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>roa</strong> (<cite>Array or scalar float</cite>) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single r/a value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2volnorm">
<code class="sig-name descname">psinorm2volnorm</code><span class="sig-paren">(</span><em class="sig-param">psi_norm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized volume corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to volnorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of volnorm. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single volnorm value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2phinorm">
<code class="sig-name descname">psinorm2phinorm</code><span class="sig-paren">(</span><em class="sig-param">psi_norm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to phinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of phinorm. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single phinorm value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2rho">
<code class="sig-name descname">psinorm2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (psinorm, t) coordinates into one of several coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-even"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-odd"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-even"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
<tr class="row-odd"><td><p>q</p></td>
<td><p>Safety factor</p></td>
</tr>
<tr class="row-even"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-odd"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-even"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-odd"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-even"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to rho.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>method</cite> is not one of the supported values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single phinorm value at psinorm=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at phinorm of 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psinorm of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2psinorm">
<code class="sig-name descname">phinorm2psinorm</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to psinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2volnorm">
<code class="sig-name descname">phinorm2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to volnorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single volnorm value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2rmid">
<code class="sig-name descname">phinorm2rmid</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mapped outboard midplane major radius corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to Rmid.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single Rmid value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find Rmid values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2roa">
<code class="sig-name descname">phinorm2roa</code><span class="sig-paren">(</span><em class="sig-param">phi_norm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized minor radius corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to r/a.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>roa</strong> (<cite>Array or scalar float</cite>) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single r/a value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2rho">
<code class="sig-name descname">phinorm2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (phinorm, t) coordinates into one of several coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
<tr class="row-odd"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-even"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
<tr class="row-odd"><td><p>q</p></td>
<td><p>Safety factor</p></td>
</tr>
<tr class="row-even"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-odd"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-even"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-odd"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-even"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to rho.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite> or be
a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>method</cite> is not one of the supported values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at phinorm=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm of 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2psinorm">
<code class="sig-name descname">volnorm2psinorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to psinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2phinorm">
<code class="sig-name descname">volnorm2phinorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to phinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single phinorm value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2rmid">
<code class="sig-name descname">volnorm2rmid</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mapped outboard midplane major radius corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to Rmid.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single Rmid value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find Rmid values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2roa">
<code class="sig-name descname">volnorm2roa</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized minor radius corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to r/a.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>roa</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single r/a value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2rho">
<code class="sig-name descname">volnorm2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (volnorm, t) coordinates into one of several coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>Rmid</p></td>
<td><p>Midplane major radius</p></td>
</tr>
<tr class="row-even"><td><p>r/a</p></td>
<td><p>Normalized minor radius</p></td>
</tr>
<tr class="row-odd"><td><p>q</p></td>
<td><p>Safety factor</p></td>
</tr>
<tr class="row-even"><td><p>F</p></td>
<td><p>Flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/></p></td>
</tr>
<tr class="row-odd"><td><p>FFPrime</p></td>
<td><p>Flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/></p></td>
</tr>
<tr class="row-even"><td><p>p</p></td>
<td><p>Pressure</p></td>
</tr>
<tr class="row-odd"><td><p>pprime</p></td>
<td><p>Pressure gradient</p></td>
</tr>
<tr class="row-even"><td><p>v</p></td>
<td><p>Flux surface volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with ‘sqrt’
to specify the square root of the desired unit.</p>
</p></li>
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to rho.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite> or be
a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>method</cite> is not one of the supported values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value at volnorm=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm of 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2q">
<code class="sig-name descname">rz2q</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the safety factor (“q”) at the given (R, Z, t).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to q. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to q. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of q.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>q</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>q</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>q</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>q</cite> or (<cite>q</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>q</strong> (<cite>Array or scalar float</cite>) - The safety factor (“q”). If all
of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>q</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>q</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>q</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single q value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2q</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2q</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find q values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2q</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2q">
<code class="sig-name descname">rmid2q</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the safety factor (“q”) corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to q.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of q.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>q</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>q</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>q</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>q</cite> or (<cite>q</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>q</strong> (<cite>Array or scalar float</cite>) - The safety factor (“q”).
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>q</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single q value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2q</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2q</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2q</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find q values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2q">
<code class="sig-name descname">roa2q</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into safety factor (“q”).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to q.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of q.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>q</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>q</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>q</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>q</cite> or (<cite>q</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>q</strong> (<cite>Array or scalar float</cite>) - The safety factor (“q”). If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>q</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single q value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2q</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2q</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find q values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2q">
<code class="sig-name descname">psinorm2q</code><span class="sig-paren">(</span><em class="sig-param">psinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the safety factor (“q”) corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to q.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of q. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>q</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>q</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>q</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>q</cite> or (<cite>q</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>q</strong> (<cite>Array or scalar float</cite>) - The safety factor (“q”). If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>q</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single q value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2q</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2q</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2q</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find q values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2q">
<code class="sig-name descname">phinorm2q</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the safety factor (“q”) corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to q.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of q.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>q</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>q</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>q</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>q</cite> or (<cite>q</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>q</strong> (<cite>Array or scalar float</cite>) - The safety factor (“q”). If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>q</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single q value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2q</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2q</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2q</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find q values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2q">
<code class="sig-name descname">volnorm2q</code><span class="sig-paren">(</span><em class="sig-param">volnorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the safety factor (“q”) corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to q.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of q.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>q</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>q</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>q</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>q</cite> or (<cite>q</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>q</strong> (<cite>Array or scalar float</cite>) - The safety factor (“q”). If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>q</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single q value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2q</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2q</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find q values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2q</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find q values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2q</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2F">
<code class="sig-name descname">rz2F</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2F" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/> at the given (R, Z, t).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to F. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to F. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of F.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>F</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>F</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>F</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>F</cite> or (<cite>F</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>F</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>F</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>F</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>F</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single F value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find F values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2F">
<code class="sig-name descname">rmid2F</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2F" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/> corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to F.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of F.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>F</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>F</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>F</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>F</cite> or (<cite>F</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>F</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>F</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single F value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2F</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2F</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find F values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2F">
<code class="sig-name descname">roa2F</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2F" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into the flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to F.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of F.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>F</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>F</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>F</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>F</cite> or (<cite>F</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>F</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>F</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single F value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2F</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2F</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find F values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2F">
<code class="sig-name descname">psinorm2F</code><span class="sig-paren">(</span><em class="sig-param">psinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2F" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/> corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to F.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of F. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>F</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>F</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>F</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>F</cite> or (<cite>F</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>F</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>F</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single F value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2F</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2F</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find F values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2F">
<code class="sig-name descname">phinorm2F</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2F" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/> corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to F.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of F.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>F</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>F</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>F</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>F</cite> or (<cite>F</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>F</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>F</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single F value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2F</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2F</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find F values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2F">
<code class="sig-name descname">volnorm2F</code><span class="sig-paren">(</span><em class="sig-param">volnorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2F" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/> corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to F.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of F.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>F</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>F</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>F</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>F</cite> or (<cite>F</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>F</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>F</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single F value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2F</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2F</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find F values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find F values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2F</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.Fnorm2psinorm">
<code class="sig-name descname">Fnorm2psinorm</code><span class="sig-paren">(</span><em class="sig-param">F</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.Fnorm2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.Fnorm2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the psinorm (normalized poloidal flux) corresponding to the passed normalized flux function <img class="math" src="_images/math/f228551be7879ec108f79f2b1e0fc75133de2408.png" alt="F=RB_{\phi}"/> values.</p>
<p>This is provided as a convenience method to plot current lines with the
correct spacing: current lines launched from a grid uniformly-spaced in
Fnorm will have spacing directly proportional to the magnitude.</p>
<p>By default, EFIT only computes this inside the LCFS. Furthermore, it is
truncated at the radius at which is becomes non-monotonic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of F to map to psinorm.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>F</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>F</cite> or be a
scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH element
in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>psinorm</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>psinorm</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>psinorm</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The normalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single psinorm value for F=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">F2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at F values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">F2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at F=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">F2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (F, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">F2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2FFPrime">
<code class="sig-name descname">rz2FFPrime</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2FFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2FFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/> at the given (R, Z, t).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to FFPrime. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to FFPrime. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of FFPrime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>FFPrime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>FFPrime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>FFPrime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>FFPrime</cite> or (<cite>FFPrime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>FFPrime</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>FFPrime</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>FFPrime</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>FFPrime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single FFPrime value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find FFPrime values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2FFPrime">
<code class="sig-name descname">rmid2FFPrime</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2FFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2FFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/> corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to FFPrime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of FFPrime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>FFPrime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>FFPrime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>FFPrime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>FFPrime</cite> or (<cite>FFPrime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>FFPrime</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>FFPrime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single FFPrime value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2FFPrime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2FFPrime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2FFPrime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find FFPrime values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2FFPrime">
<code class="sig-name descname">roa2FFPrime</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2FFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2FFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into the flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to FFPrime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of FFPrime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>FFPrime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>FFPrime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>FFPrime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>FFPrime</cite> or (<cite>FFPrime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>FFPrime</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>FFPrime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single FFPrime value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2FFPrime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2FFPrime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find FFPrime values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2FFPrime">
<code class="sig-name descname">psinorm2FFPrime</code><span class="sig-paren">(</span><em class="sig-param">psinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2FFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2FFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/> corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to FFPrime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of FFPrime. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>FFPrime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>FFPrime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>FFPrime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>FFPrime</cite> or (<cite>FFPrime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>FFPrime</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>FFPrime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single FFPrime value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2FFPrime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2FFPrime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2FFPrime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find FFPrime values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2FFPrime">
<code class="sig-name descname">phinorm2FFPrime</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2FFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2FFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/> corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to FFPrime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of FFPrime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>FFPrime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>FFPrime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>FFPrime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>FFPrime</cite> or (<cite>FFPrime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>FFPrime</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>FFPrime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single FFPrime value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2FFPrime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2FFPrime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2FFPrime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find FFPrime values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2FFPrime">
<code class="sig-name descname">volnorm2FFPrime</code><span class="sig-paren">(</span><em class="sig-param">volnorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2FFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2FFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/> corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to FFPrime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of FFPrime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>FFPrime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>FFPrime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>FFPrime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>FFPrime</cite> or (<cite>FFPrime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>FFPrime</strong> (<cite>Array or scalar float</cite>) - The flux function <img class="math" src="_images/math/a8b16cc61bb6e9b00d93b0b9793e3e3a4cc8d869.png" alt="FF'"/>.
If all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>FFPrime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single FFPrime value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2FFPrime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2FFPrime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find FFPrime values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2FFPrime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find FFPrime values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FFPrime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2FFPrime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2p">
<code class="sig-name descname">rz2p</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure at the given (R, Z, t).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to p. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to p. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of p.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>p</cite> or (<cite>p</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>p</strong> (<cite>Array or scalar float</cite>) - The pressure. If all
of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>p</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>p</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>p</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single p value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2p</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2p</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find p values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2p</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2p">
<code class="sig-name descname">rmid2p</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to p.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of p.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>p</cite> or (<cite>p</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>p</strong> (<cite>Array or scalar float</cite>) - The pressure.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>p</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single p value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2p</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2p</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find p values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2p">
<code class="sig-name descname">roa2p</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into pressure.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to p.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of p.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>p</cite> or (<cite>p</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>p</strong> (<cite>Array or scalar float</cite>) - The pressure. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>p</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single p value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2p</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2p</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find p values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2p">
<code class="sig-name descname">psinorm2p</code><span class="sig-paren">(</span><em class="sig-param">psinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to p.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of p. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>p</cite> or (<cite>p</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>p</strong> (<cite>Array or scalar float</cite>) - The pressure. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>p</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single p value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2p</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2p</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find p values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2p">
<code class="sig-name descname">phinorm2p</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to p.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of p.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>p</cite> or (<cite>p</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>p</strong> (<cite>Array or scalar float</cite>) - The pressure. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>p</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single p value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2p</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2p</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find p values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2p">
<code class="sig-name descname">volnorm2p</code><span class="sig-paren">(</span><em class="sig-param">volnorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to p.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of p.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>p</cite> or (<cite>p</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>p</strong> (<cite>Array or scalar float</cite>) - The pressure. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>p</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single p value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2p</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2p</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find p values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find p values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2p</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2pprime">
<code class="sig-name descname">rz2pprime</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2pprime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2pprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure gradient at the given (R, Z, t).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to pprime. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to pprime. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of pprime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>pprime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>pprime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>pprime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>pprime</cite> or (<cite>pprime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>pprime</strong> (<cite>Array or scalar float</cite>) - The pressure gradient. If
all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>p</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>p</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>pprime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single pprime value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find pprime values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2pprime">
<code class="sig-name descname">rmid2pprime</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2pprime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2pprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure gradient corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to pprime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of pprime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>pprime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>pprime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>pprime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>pprime</cite> or (<cite>pprime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>pprime</strong> (<cite>Array or scalar float</cite>) - The pressure gradient.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>pprime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single pprime value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2pprime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2pprime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2pprime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find pprime values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2pprime">
<code class="sig-name descname">roa2pprime</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2pprime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2pprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into pressure gradient.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to pprime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of pprime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>pprime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>pprime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>pprime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>pprime</cite> or (<cite>pprime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>pprime</strong> (<cite>Array or scalar float</cite>) - The pressure gradient. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>pprime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single pprime value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2pprime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2pprime</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find pprime values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2pprime">
<code class="sig-name descname">psinorm2pprime</code><span class="sig-paren">(</span><em class="sig-param">psinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2pprime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2pprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure gradient corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to pprime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of pprime. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>pprime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>pprime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>pprime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>pprime</cite> or (<cite>pprime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>pprime</strong> (<cite>Array or scalar float</cite>) - The pressure gradient. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>pprime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single pprime value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2pprime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2pprime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2pprime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find pprime values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2pprime">
<code class="sig-name descname">phinorm2pprime</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2pprime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2pprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure gradient corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to pprime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of pprime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>pprime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>pprime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>pprime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>pprime</cite> or (<cite>pprime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>pprime</strong> (<cite>Array or scalar float</cite>) - The pressure gradient. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>pprime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single pprime value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2pprime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2pprime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2pprime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find pprime values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2pprime">
<code class="sig-name descname">volnorm2pprime</code><span class="sig-paren">(</span><em class="sig-param">volnorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2pprime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2pprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pressure gradient corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to pprime.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of pprime.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>pprime</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>pprime</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>pprime</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>pprime</cite> or (<cite>pprime</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>pprime</strong> (<cite>Array or scalar float</cite>) - The pressure gradient. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>pprime</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single pprime value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2pprime</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2pprime</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find pprime values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2pprime</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find pprime values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprime_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2pprime</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2v">
<code class="sig-name descname">rz2v</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux surface volume at the given (R, Z, t).</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to v. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to v. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of v.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>v</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>v</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>v</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>v</cite> or (<cite>v</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>v</strong> (<cite>Array or scalar float</cite>) - The flux surface volume. If all
of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>v</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>v</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>v</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single v value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2v</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2v</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find v values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2v</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2v">
<code class="sig-name descname">rmid2v</code><span class="sig-paren">(</span><em class="sig-param">R_mid</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux surface volume corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_mid</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the outboard midplane
major radius to map to v.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of v.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>p</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>p</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>p</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>v</cite> or (<cite>v</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>v</strong> (<cite>Array or scalar float</cite>) - The flux surface volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>v</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single v value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2v</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2v</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2v</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find v values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2v">
<code class="sig-name descname">roa2v</code><span class="sig-paren">(</span><em class="sig-param">roa</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into flux surface volume.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roa</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized minor
radius to map to v.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of v.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>v</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>v</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>v</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>v</cite> or (<cite>v</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>v</strong> (<cite>Array or scalar float</cite>) - The flux surface volume. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>v</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single v value at r/a=0.6, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2v</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2v</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find v values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2v">
<code class="sig-name descname">psinorm2v</code><span class="sig-paren">(</span><em class="sig-param">psinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux surface volume corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to v.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of v. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe’s IDL
implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>v</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>v</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>v</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>v</cite> or (<cite>v</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>v</strong> (<cite>Array or scalar float</cite>) - The pressure. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>v</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single v value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2v</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2v</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2v</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find v values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2v">
<code class="sig-name descname">phinorm2v</code><span class="sig-paren">(</span><em class="sig-param">phinorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phinorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
toroidal flux to map to v.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of v.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>v</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>v</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>v</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>v</cite> or (<cite>v</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>v</strong> (<cite>Array or scalar float</cite>) - The flux surface volume. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>v</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single v value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2v</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2v</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2v</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find v values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2v">
<code class="sig-name descname">volnorm2v</code><span class="sig-paren">(</span><em class="sig-param">volnorm</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux surface volume corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<p>By default, EFIT only computes this inside the LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volnorm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
flux surface volume to map to v.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of v.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe’s
IDL implementation efit_rz2rho.pro. Default is False.</p></li>
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>v</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>v</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>v</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>v</cite> or (<cite>v</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>v</strong> (<cite>Array or scalar float</cite>) - The flux surface volume. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>v</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single v value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2p</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2v</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find v values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2v</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find v values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2v</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2BR">
<code class="sig-name descname">rz2BR</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2BR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2BR" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the major radial component of the magnetic field at the given (R, Z, t) coordinates.</p>
<p>Uses</p>
<div class="math">
<p><img src="_images/math/c99e8ba39f4b2f58a187fed0cfd9398bbd12f25e.png" alt="B_R = -\frac{1}{R}\frac{\partial \psi}{\partial Z}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to radial field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to radial field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>BR</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>BR</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>BR</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>BR</cite> or (<cite>BR</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>BR</strong> (<cite>Array or scalar float</cite>) - The major radial component of
the magnetic field. If all of the input arguments are scalar, then
a scalar is returned. Otherwise, a scipy Array is returned. If <cite>R</cite>
and <cite>Z</cite> both have the same shape then <cite>BR</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>BR</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>BR</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single BR value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find BR values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BR values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BR_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2BZ">
<code class="sig-name descname">rz2BZ</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">return_t=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">each_t=True</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2BZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2BZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the vertical component of the magnetic field at the given (R, Z, t) coordinates.</p>
<p>Uses</p>
<div class="math">
<p><img src="_images/math/45351df348bec895879674437cbdf141bfc7f549.png" alt="B_Z = \frac{1}{R}\frac{\partial \psi}{\partial R}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to vertical field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to vertical field. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>BZ</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>BZ</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>BZ</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>BZ</cite> or (<cite>BZ</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>BZ</strong> (<cite>Array or scalar float</cite>) - The vertical component of the
magnetic field. If all of the input arguments are scalar, then a
scalar is returned. Otherwise, a scipy Array is returned. If <cite>R</cite>
and <cite>Z</cite> both have the same shape then <cite>BZ</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>BZ</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>BZ</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single BZ value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find BZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BZ values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BZ_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2BT">
<code class="sig-name descname">rz2BT</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2BT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2BT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the toroidal component of the magnetic field at the given (R, Z, t).</p>
<p>Uses <img class="math" src="_images/math/7680a16b9a6160a0772c94edabd1edeeef03c1df.png" alt="B_\phi = F / R"/>.</p>
<p>By default, EFIT only computes this inside the LCFS. To approximate the
field outside of the LCFS, <img class="math" src="_images/math/d2cdf4f6cde69cfc4de2ea6a1a3bdcd3723e9d7c.png" alt="B_\phi \approx B_{t, vac} R_0 / R"/> is
used, where <img class="math" src="_images/math/04954de9f032b49df7f69c1c24ae9c868eddf932.png" alt="B_{t, vac}"/> is obtained with <a class="reference internal" href="#eqtools.core.Equilibrium.getBtVac" title="eqtools.core.Equilibrium.getBtVac"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getBtVac()</span></code></a> and
<img class="math" src="_images/math/def0a5fde1c0fe96e791603b65ed60363924aee0.png" alt="R_0"/> is the major radius of the magnetic axis obtained from
<a class="reference internal" href="#eqtools.core.Equilibrium.getMagR" title="eqtools.core.Equilibrium.getMagR"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getMagR()</span></code></a>.</p>
<p>The coordinate system used is right-handed, such that “forward” field on
Alcator C-Mod (clockwise when seen from above) has negative BT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to BT. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to BT. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>BT</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>BT</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>BT</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>BT</cite> or (<cite>BT</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>BT</strong> (<cite>Array or scalar float</cite>) - The toroidal magnetic field.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>BT</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>BT</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>BT</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single BT value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BT_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BT values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BT_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BT values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BT_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find BT values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BT_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find BT values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BT_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2B">
<code class="sig-name descname">rz2B</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2B" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude of the magnetic field at the given (R, Z, t).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to B. If <cite>R</cite> and <cite>Z</cite> are both scalar values, they are used
as the coordinate pair for all of the values in <cite>t</cite>. Must have
the same shape as <cite>Z</cite> unless the <cite>make_grid</cite> keyword is set. If
the <cite>make_grid</cite> keyword is True, <cite>R</cite> must have exactly one
dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to B. If <cite>R</cite> and <cite>Z</cite> are both scalar values, they are used
as the coordinate pair for all of the values in <cite>t</cite>. Must have
the same shape as <cite>R</cite> unless the <cite>make_grid</cite> keyword is set. If
the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must have exactly one
dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>B</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>B</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>B</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>B</cite> or (<cite>B</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>B</strong> (<cite>Array or scalar float</cite>) - The magnitude of the magnetic
field. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>B</cite> has this shape as well, unless
the <cite>make_grid</cite> keyword was True, in which case <cite>B</cite> has shape
(len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>B</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single B value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2B</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find B values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2B</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find B values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2B</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find B values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2B</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find B values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2B</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2jR">
<code class="sig-name descname">rz2jR</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2jR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2jR" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the major radial component of the current density at the given (R, Z, t) coordinates.</p>
<div class="math">
<p><img src="_images/math/f579de5a6b751365727e11681e6ded14ad12d421.png" alt="j_R = -\frac{1}{\mu_0 R}F'\frac{\partial \psi}{\partial Z} = \frac{F' B_R}{\mu_0}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to radial current density. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>R</cite> must have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to radial current density. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>R</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>Z</cite> must have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>jR</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>jR</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>jR</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>jR</cite> or (<cite>jR</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>jR</strong> (<cite>Array or scalar float</cite>) - The major radial component of
the current density. If all of the input arguments are scalar, then
a scalar is returned. Otherwise, a scipy Array is returned. If <cite>R</cite>
and <cite>Z</cite> both have the same shape then <cite>jR</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>jR</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>jR</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single jR value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jR_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find jR values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jR_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jR values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jR_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2jZ">
<code class="sig-name descname">rz2jZ</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2jZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2jZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the vertical component of the current density at the given (R, Z, t) coordinates.</p>
<p>Uses</p>
<div class="math">
<p><img src="_images/math/4dbd3865ae305a2bb57976b599653d6df9a05b49.png" alt="j_Z = \frac{1}{\mu_0 R}F'\frac{\partial \psi}{\partial R} = \frac{F' B_Z}{\mu_0}"/></p>
</div><p>Note that this function includes a factor of -1 to correct the FF’ from
Alcator C-Mod’s EFIT implementation. You should check the sign of your
data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to vertical current density. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>R</cite> must have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to vertical current density. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>R</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>Z</cite> must have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>jZ</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>jZ</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>jZ</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>jZ</cite> or (<cite>jZ</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>jZ</strong> (<cite>Array or scalar float</cite>) - The vertical component of the
current density. If all of the input arguments are scalar, then a
scalar is returned. Otherwise, a scipy Array is returned. If <cite>R</cite>
and <cite>Z</cite> both have the same shape then <cite>jZ</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>jZ</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>jZ</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single jZ value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jZ_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find jZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jZ_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jZ values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jZ_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2jT">
<code class="sig-name descname">rz2jT</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2jT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2jT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the toroidal component of the current density at the given (R, Z, t) coordinates.</p>
<p>Uses</p>
<div class="math">
<p><img src="_images/math/111aa0b82d7399dde7b74fd5a125cc950eca531b.png" alt="j_\phi = Rp' + \frac{FF'}{\mu_0 R}"/></p>
</div><p>The coordinate system used is right-handed, such that “forward” field on
Alcator C-Mod (clockwise when seen from above) has negative jT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to toroidal current density. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>R</cite> must have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to toroidal current density. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>R</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>Z</cite> must have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>jT</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>jT</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>jT</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>jT</cite> or (<cite>jT</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>jT</strong> (<cite>Array or scalar float</cite>) - The major radial component of
the current density. If all of the input arguments are scalar,
then a scalar is returned. Otherwise, a scipy Array is returned.
If <cite>R</cite> and <cite>Z</cite> both have the same shape then <cite>jT</cite> has this shape
as well, unless the <cite>make_grid</cite> keyword was True, in which case
<cite>jT</cite> has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>jT</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single jT value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jT_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jT values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jT_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jT values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jT_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find jT values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jT_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find jT values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jT_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2j">
<code class="sig-name descname">rz2j</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2j" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude of the current density at the given (R, Z, t) coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to current density magnitude. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>R</cite> must have exactly one dimension.</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to current density magnitude. If <cite>R</cite> and <cite>Z</cite> are both scalar
values, they are used as the coordinate pair for all of the
values in <cite>t</cite>. Must have the same shape as <cite>R</cite> unless the
<cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite> keyword is True,
<cite>Z</cite> must have exactly one dimension.</p></li>
<li><p><strong>t</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>each_t</strong> (<em>Boolean</em>) – When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.meshgrid()</span></code> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</p></li>
<li><p><strong>return_t</strong> (<em>Boolean</em>) – Set to True to return a tuple of (<cite>j</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>j</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>j</cite>).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>j</cite> or (<cite>j</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><p><strong>j</strong> (<cite>Array or scalar float</cite>) - The magnitude of the current
density. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>j</cite> has this shape as well, unless
the <cite>make_grid</cite> keyword was True, in which case <cite>j</cite> has shape
(len(<cite>Z</cite>), len(<cite>R</cite>)).</p></li>
<li><p><strong>time_idxs</strong> (Array with same shape as <cite>j</cite>) - The indices
(in <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.getTimeBase()</span></code>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class.</p>
<p>Find single j value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2j</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find j values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2j</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find j values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2j</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find j values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2j</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find j values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2j</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2FieldLineTrace">
<code class="sig-name descname">rz2FieldLineTrace</code><span class="sig-paren">(</span><em class="sig-param">R0</em>, <em class="sig-param">Z0</em>, <em class="sig-param">t</em>, <em class="sig-param">phi0=0.0</em>, <em class="sig-param">field='B'</em>, <em class="sig-param">num_rev=1.0</em>, <em class="sig-param">rev_method='toroidal'</em>, <em class="sig-param">dphi=0.06283185307179587</em>, <em class="sig-param">integrator='dopri5'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2FieldLineTrace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2FieldLineTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace a field line starting from a given (R, phi, Z) point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R0</strong> (<em>float</em>) – Major radial coordinate of starting point.</p></li>
<li><p><strong>Z0</strong> (<em>float</em>) – Vertical coordinate of starting point.</p></li>
<li><p><strong>t</strong> (<em>float</em>) – Time to trace field line at.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>phi0</strong> (<em>float</em>) – Toroidal angle of starting point in radians. Default
is 0.0.</p></li>
<li><p><strong>field</strong> (<em>{'B'</em><em>, </em><em>'j'}</em>) – The field to use. Can be magnetic field (‘B’) or
current density (‘j’). Default is ‘B’ (magnetic field).</p></li>
<li><p><strong>num_rev</strong> (<em>float</em>) – The number of revolutions to trace the field line
through. Whether this refers to toroidal or poloidal revolutions
is determined by the <cite>rev_method</cite> keyword. Default is 1.0.</p></li>
<li><p><strong>rev_method</strong> (<em>'toroidal'</em><em>, </em><em>'poloidal'</em>) – Whether <cite>num_rev</cite> refers to the
number of toroidal or poloidal revolutions the field line should
make. Note that ‘poloidal’ only makes sense for close field
lines. Default is ‘toroidal’.</p></li>
<li><p><strong>dphi</strong> (<em>float</em>) – Toroidal step size, in radians. Default is 0.02*pi.
The number of steps taken is then 2*pi times the number of
toroidal rotations divided by dphi. This can be negative to
trace a field line clockwise instead of counterclockwise.</p></li>
<li><p><strong>integrator</strong> (<em>str</em>) – The integrator to use with
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.integrate.ode</span></code>. Default is ‘dopri5’ (explicit
Dormand-Prince of order (4)5). Can also be an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.integrate.ode</span></code> for which the integrator and its
options has been set.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Containing the (R, Z, phi) coordinates.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array, (<cite>nsteps</cite> + 1, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rho2FieldLineTrace">
<code class="sig-name descname">rho2FieldLineTrace</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">t</em>, <em class="sig-param">origin='psinorm'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rho2FieldLineTrace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rho2FieldLineTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace a field line starting from a given normalized coordinate point.</p>
<p>The field line is started at the outboard midplane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>float</em>) – Flux surface label of starting point.</p></li>
<li><p><strong>t</strong> (<em>float</em>) – Time to trace field line at.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>origin</strong> (<em>{'psinorm'</em><em>, </em><em>'phinorm'</em><em>, </em><em>'volnorm'</em><em>, </em><em>'r/a'</em><em>, </em><em>'Rmid'</em><em>, </em><em>'Fnorm'}</em>) – The flux surface coordinates which <cite>rhovals</cite> is given in.
Default is ‘psinorm’.</p></li>
<li><p><strong>phi0</strong> (<em>float</em>) – Toroidal angle of starting point in radians. Default
is 0.0.</p></li>
<li><p><strong>field</strong> (<em>{'B'</em><em>, </em><em>'j'}</em>) – The field to use. Can be magnetic field (‘B’) or
current density (‘j’). Default is ‘B’ (magnetic field).</p></li>
<li><p><strong>num_rev</strong> (<em>float</em>) – The number of revolutions to trace the field line
through. Whether this refers to toroidal or poloidal revolutions
is determined by the <cite>rev_method</cite> keyword. Default is 1.0.</p></li>
<li><p><strong>rev_method</strong> (<em>'toroidal'</em><em>, </em><em>'poloidal'</em>) – Whether <cite>num_rev</cite> refers to the
number of toroidal or poloidal revolutions the field line should
make. Note that ‘poloidal’ only makes sense for close field
lines. Default is ‘toroidal’.</p></li>
<li><p><strong>dphi</strong> (<em>float</em>) – Toroidal step size, in radians. Default is 0.02*pi.
The number of steps taken is then 2*pi times the number of
toroidal rotations divided by dphi. This can be negative to
trace a field line clockwise instead of counterclockwise.</p></li>
<li><p><strong>integrator</strong> (<em>str</em>) – The integrator to use with
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.integrate.ode</span></code>. Default is ‘dopri5’ (explicit
Dormand-Prince of order (4)5). Can also be an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.integrate.ode</span></code> for which the integrator and its
options has been set.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Containing the (R, Z, phi) coordinates.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array, (<cite>nsteps</cite> + 1, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.plotField">
<code class="sig-name descname">plotField</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">rhovals=6</em>, <em class="sig-param">rhomin=0.05</em>, <em class="sig-param">rhomax=0.95</em>, <em class="sig-param">color='b'</em>, <em class="sig-param">cmap='plasma'</em>, <em class="sig-param">alpha=0.5</em>, <em class="sig-param">arrows=True</em>, <em class="sig-param">linewidth=1.0</em>, <em class="sig-param">arrowlinewidth=3.0</em>, <em class="sig-param">a=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.plotField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.plotField" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the field lines starting from a number of points.</p>
<p>The field lines are started at the outboard midplane.</p>
<p>If uniformly-spaced psinorm points are used, the spacing of the magnetic
field lines will be directly proportional to the field strength,
assuming a sufficient number of revolutions is traced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em>) – Time to trace field line at.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>rhovals</strong> (<em>int</em><em> or </em><em>array of int</em>) – The number of uniformly-spaced rho
points between <cite>rhomin</cite> and <cite>rhomax</cite> to use, or an explicit grid of rho
points to use. Default is 6.</p></li>
<li><p><strong>rhomin</strong> (<em>float</em>) – The minimum value of rho to use when using a
uniformly-spaced grid. Default is 0.05.</p></li>
<li><p><strong>rhomax</strong> (<em>float</em>) – The maximum value of rho to use when using a
uniformly-spaced grid. Default is 0.95.</p></li>
<li><p><strong>color</strong> (<em>str</em>) – The color to plot the field lines in. Default is ‘b’.
If set to ‘sequential’, each field line will be a different
color, in the sequence matplotlib assigns them. If set to
‘magnitude’, the coloring will be proportional to the magnitude
of the field. Note that this is very time-consuming, as the
limitations of matplotlib mean that each line segment must be
plotted individually.</p></li>
<li><p><strong>cmap</strong> (<em>str</em>) – The colormap to use when <cite>color</cite> is ‘magnitude’. Default
is ‘plasma’, a perceptually uniform sequential colormap.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The transparency to plot the field lines with.
Default is 0.5.</p></li>
<li><p><strong>arrows</strong> (<em>bool</em>) – If True, an arrowhead indicating the field direction
will be drawn at the start of each field line. Default is True.</p></li>
<li><p><strong>linewidth</strong> (<em>float</em>) – The line width to use when plotting the field
lines. Default is 1.0.</p></li>
<li><p><strong>arrowlinewidth</strong> (<em>float</em>) – The line width to use when plotting the
arrows. Default is 3.0</p></li>
<li><p><strong>a</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes._subplots.Axes3DSubplot</span></code>) – The axes to
plot the field lines on. Default is to make a new figure. Note
that a colorbar will be drawn when <cite>color</cite> is magnitude, but
only if <cite>a</cite> is not provided.</p></li>
<li><p><strong>origin</strong> (<em>{'psinorm'</em><em>, </em><em>'phinorm'</em><em>, </em><em>'volnorm'</em><em>, </em><em>'r/a'</em><em>, </em><em>'Rmid'</em><em>, </em><em>'Fnorm'}</em>) – The flux surface coordinates which <cite>rhovals</cite> is given in.
Default is ‘psinorm’.</p></li>
<li><p><strong>phi0</strong> (<em>float</em>) – Toroidal angle of starting point in radians. Default
is 0.0.</p></li>
<li><p><strong>field</strong> (<em>{'B'</em><em>, </em><em>'j'}</em>) – The field to use. Can be magnetic field (‘B’) or
current density (‘j’). Default is ‘B’ (magnetic field).</p></li>
<li><p><strong>num_rev</strong> (<em>float</em>) – The number of revolutions to trace the field line
through. Whether this refers to toroidal or poloidal revolutions
is determined by the <cite>rev_method</cite> keyword. Default is 1.0.</p></li>
<li><p><strong>rev_method</strong> (<em>'toroidal'</em><em>, </em><em>'poloidal'</em>) – Whether <cite>num_rev</cite> refers to the
number of toroidal or poloidal revolutions the field line should
make. Note that ‘poloidal’ only makes sense for close field
lines. Default is ‘toroidal’.</p></li>
<li><p><strong>dphi</strong> (<em>float</em>) – Toroidal step size, in radians. Default is 0.02*pi.
The number of steps taken is then 2*pi times the number of
toroidal rotations divided by dphi. This can be negative to
trace a field line clockwise instead of counterclockwise.</p></li>
<li><p><strong>integrator</strong> (<em>str</em>) – The integrator to use with
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.integrate.ode</span></code>. Default is ‘dopri5’ (explicit
Dormand-Prince of order (4)5). Can also be an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.integrate.ode</span></code> for which the integrator and its
options has been set.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The figure and axis which the field lines were plotted in.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(figure, axis)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagRSpline">
<code class="sig-name descname">getMagRSpline</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em>, <em class="sig-param">kind='nearest'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagRSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagRSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate R_mag as a function of time.</p>
<p>Only used if the instance was created with keyword tspline=True.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that R_mag is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_out returned in meters).</p>
</p></li>
<li><p><strong>kind</strong> (<em>String</em><em> or </em><em>non-negative int</em>) – Specifies the type of interpolation to be performed in getting
from t to R_mag. This is passed to
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code>. Valid options are:
‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is ‘cubic’ (3rd order spline interpolation) when
<cite>trispline</cite> is True, ‘nearest’ otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">trispline.UnivariateInterpolator</span></code> or</dt><dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> to convert from t to MagR.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagZSpline">
<code class="sig-name descname">getMagZSpline</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em>, <em class="sig-param">kind='nearest'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagZSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagZSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate Z_mag as a function of time.</p>
<p>Generated for completeness of the core position calculation when using
tspline = True</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that R_mag is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_out returned in meters).</p>
</p></li>
<li><p><strong>kind</strong> (<em>String</em><em> or </em><em>non-negative int</em>) – Specifies the type of interpolation to be performed in getting
from t to Z_mag. This is passed to
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code>. Valid options are:
‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is ‘cubic’ (3rd order spline interpolation) when
<cite>trispline</cite> is True, ‘nearest’ otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">trispline.UnivariateInterpolator</span></code> or</dt><dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> to convert from t to MagZ.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRmidOutSpline">
<code class="sig-name descname">getRmidOutSpline</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em>, <em class="sig-param">kind='nearest'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRmidOutSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRmidOutSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate R_mid_out as a function of time.</p>
<p>Generated for completeness of the core position calculation when using
tspline = True</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that R_mag is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_out returned in meters).</p>
</p></li>
<li><p><strong>kind</strong> (<em>String</em><em> or </em><em>non-negative int</em>) – Specifies the type of interpolation to be performed in getting
from t to R_mid_out. This is passed to
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code>. Valid options are:
‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is ‘cubic’ (3rd order spline interpolation) when
<cite>trispline</cite> is True, ‘nearest’ otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">trispline.UnivariateInterpolator</span></code> or</dt><dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> to convert from t to R_mid.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getAOutSpline">
<code class="sig-name descname">getAOutSpline</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em>, <em class="sig-param">kind='nearest'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getAOutSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getAOutSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate a_out as a function of time.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that a_out is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If <cite>length_unit</cite> is 1 or None, meters are assumed. The default
value is 1 (a_out returned in meters).</p>
</p></li>
<li><p><strong>kind</strong> (<em>String</em><em> or </em><em>non-negative int</em>) – Specifies the type of interpolation to be performed in getting
from t to a_out. This is passed to
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code>. Valid options are:
‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is ‘cubic’ (3rd order spline interpolation) when
<cite>trispline</cite> is True, ‘nearest’ otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">trispline.UnivariateInterpolator</span></code> or</dt><dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> to convert from t to a_out.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBtVacSpline">
<code class="sig-name descname">getBtVacSpline</code><span class="sig-paren">(</span><em class="sig-param">kind='nearest'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBtVacSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBtVacSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate BtVac as a function of time.</p>
<p>Only used if the instance was created with keyword tspline=True.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>kind</strong> (<em>String</em><em> or </em><em>non-negative int</em>) – Specifies the type of interpolation to be performed in getting
from t to BtVac. This is passed to
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code>. Valid options are:
‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is ‘cubic’ (3rd order spline interpolation) when
<cite>trispline</cite> is True, ‘nearest’ otherwise.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">trispline.UnivariateInterpolator</span></code> or</dt><dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> to convert from t to BtVac.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getInfo">
<code class="sig-name descname">getInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns namedtuple of instance parameters (shot, equilibrium type, size, timebase, etc.)</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getTimeBase">
<code class="sig-name descname">getTimeBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns timebase array [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<dl class="simple">
<dt>returns 3D grid of psi(r,z,t)</dt><dd><dl class="simple">
<dt>The array returned should have the following dimensions:</dt><dd><p>First dimension: time
Second dimension: Z
Third dimension: R</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRGrid">
<code class="sig-name descname">getRGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns vector of R-values for psiRZ grid [r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getZGrid">
<code class="sig-name descname">getZGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns vector of Z-values for psiRZ grid [z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxAxis">
<code class="sig-name descname">getFluxAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns psi at magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxLCFS">
<code class="sig-name descname">getFluxLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns psi a separatrix [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns R-positions (n points) mapping LCFS [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns Z-positions (n points) mapping LCFS [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.remapLCFS">
<code class="sig-name descname">remapLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Overwrites stored R,Z positions of LCFS with explicitly calculated psinorm=1
surface.  This surface is then masked using core.inPolygon() to only draw within
vacuum vessel, the end result replacing RLCFS, ZLCFS with an R,Z array showing
the divertor legs of the flux surface in addition to the core-enclosing closed
flux surface.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns volume contained within flux surface as function of psi [psi,t].
Psi assumed to be evenly-spaced grid on [0,1]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getVolLCFS">
<code class="sig-name descname">getVolLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns plasma volume within LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane major radius of flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getF">
<code class="sig-name descname">getF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns F=RB_{Phi}(Psi), often calculated for grad-shafranov solutions  [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxPres">
<code class="sig-name descname">getFluxPres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated pressure profile [psi,t].
Psi assumed to be evenly-spaced grid on [0,1]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFFPrime">
<code class="sig-name descname">getFFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns FF’ function used for grad-shafranov solutions [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getPPrime">
<code class="sig-name descname">getPPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns plasma pressure gradient as a function of psi [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getElongation">
<code class="sig-name descname">getElongation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS elongation [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getUpperTriangularity">
<code class="sig-name descname">getUpperTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS upper triangularity [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getLowerTriangularity">
<code class="sig-name descname">getLowerTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS lower triangularity [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getShaping">
<code class="sig-name descname">getShaping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getShaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getShaping" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns dimensionless shaping parameters for plasma.
Namedtuple containing {LCFS elongation, LCFS upper/lower triangularity}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagR">
<code class="sig-name descname">getMagR</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns magnetic-axis major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagZ">
<code class="sig-name descname">getMagZ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns magnetic-axis Z [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getAreaLCFS">
<code class="sig-name descname">getAreaLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS surface area [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getAOut">
<code class="sig-name descname">getAOut</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRmidOut">
<code class="sig-name descname">getRmidOut</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getGeometry">
<code class="sig-name descname">getGeometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns dimensional geometry parameters
Namedtuple containing {mag axis R,Z, LCFS area, volume, outboard-midplane major radius}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns safety factor q profile [psi,t]
Psi assumed to be evenly-spaced grid on [0,1]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ0">
<code class="sig-name descname">getQ0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns q on magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ95">
<code class="sig-name descname">getQ95</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns q on 95% flux surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQLCFS">
<code class="sig-name descname">getQLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns q on LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ1Surf">
<code class="sig-name descname">getQ1Surf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius of q=1 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ2Surf">
<code class="sig-name descname">getQ2Surf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius of q=2 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ3Surf">
<code class="sig-name descname">getQ3Surf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius of q=3 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQs">
<code class="sig-name descname">getQs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns specific q-profile values.
Namedtuple containing {q0, q95, qLCFS, minor radius of q=1,2,3 surfaces}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBtVac">
<code class="sig-name descname">getBtVac</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns vacuum on-axis toroidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBtPla">
<code class="sig-name descname">getBtPla</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns plasma on-axis toroidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBpAvg">
<code class="sig-name descname">getBpAvg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns average poloidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFields">
<code class="sig-name descname">getFields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns magnetic-field values.
Namedtuple containing {Btor on magnetic axis (plasma and vacuum), avg Bpol}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getIpCalc">
<code class="sig-name descname">getIpCalc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getIpMeas">
<code class="sig-name descname">getIpMeas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns measured plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getJp">
<code class="sig-name descname">getJp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns grid of calculated toroidal current density [t,z,r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBetaT">
<code class="sig-name descname">getBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated global toroidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBetaP">
<code class="sig-name descname">getBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated global poloidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getLi">
<code class="sig-name descname">getLi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated internal inductance of plasma [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBetas">
<code class="sig-name descname">getBetas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated betas and inductance.
Namedtuple of {betat,betap,Li}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagFlux">
<code class="sig-name descname">getDiamagFlux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic flux [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagBetaT">
<code class="sig-name descname">getDiamagBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop toroidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagBetaP">
<code class="sig-name descname">getDiamagBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop poloidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagTauE">
<code class="sig-name descname">getDiamagTauE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop energy confinement time [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagWp">
<code class="sig-name descname">getDiamagWp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop plasma stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamag">
<code class="sig-name descname">getDiamag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic measurements of plasma parameters.
Namedtuple of {diamag. flux, betat, betap from coils, tau_E from diamag., diamag. stored energy}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getWMHD">
<code class="sig-name descname">getWMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated MHD stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getTauMHD">
<code class="sig-name descname">getTauMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated MHD energy confinement time [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getPinj">
<code class="sig-name descname">getPinj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated injected power [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getCurrentSign">
<code class="sig-name descname">getCurrentSign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated current direction, where CCW = +</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getWbdot">
<code class="sig-name descname">getWbdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated d/dt of magnetic stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getWpdot">
<code class="sig-name descname">getWpdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated d/dt of plasma stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBCentr">
<code class="sig-name descname">getBCentr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns Vacuum Toroidal magnetic field at Rcent point [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRCentr">
<code class="sig-name descname">getRCentr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Radial position for Vacuum Toroidal magnetic field calculation</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getEnergy">
<code class="sig-name descname">getEnergy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns stored-energy parameters.
Namedtuple of {stored energy, confinement time, injected power, d/dt of magnetic, plasma stored energy}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getParam">
<code class="sig-name descname">getParam</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Backup function: takes parameter name for variable, returns variable directly.
Acts as wrapper to direct data-access routines from within object.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns (R,Z) coordinates of vacuum wall cross-section for plotting/masking routines.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMachineCrossSectionFull">
<code class="sig-name descname">getMachineCrossSectionFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns (R,Z) coordinates of machine wall cross-section for plotting routines.
Returns a more detailed cross-section than getLimiter(), generally a vector map
displaying non-critical cross-section information.  If this is unavailable, this
should point to self.getMachineCrossSection(), which pulls the limiter outline
stored by default in data files e.g. g-eqdsk files.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.gfile">
<code class="sig-name descname">gfile</code><span class="sig-paren">(</span><em class="sig-param">time=None</em>, <em class="sig-param">nw=None</em>, <em class="sig-param">nh=None</em>, <em class="sig-param">shot=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">tunit='ms'</em>, <em class="sig-param">title='EQTOOLS'</em>, <em class="sig-param">nbbbs=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.gfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.gfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an EFIT gfile with gfile naming convention</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<em>scalar float</em>) – Time of equilibrium to
generate the gfile from. This will use the specified
spline functionality to do so. Allows for it to be
unspecified for single-time-frame equilibria.</p></li>
<li><p><strong>nw</strong> (<em>scalar integer</em>) – Number of points in R.
R is the major radius, and describes the ‘width’ of the
gfile.</p></li>
<li><p><strong>nh</strong> (<em>scalar integer</em>) – Number of points in Z. In cylindrical
coordinates Z is the height, and nh describes the ‘height’
of the gfile.</p></li>
<li><p><strong>shot</strong> (<em>scalar integer</em>) – The shot numer of the equilibrium.
Used to help generate the gfile name if unspecified.</p></li>
<li><p><strong>name</strong> (<em>String</em>) – Name of the gfile.  If unspecified, will follow
standard gfile naming convention (g+shot.time) under current
python operating directory.  This allows for it to be saved
in other directories, etc.</p></li>
<li><p><strong>tunit</strong> (<em>String</em>) – Specified unit for tin. It can only be ‘ms’ for
milliseconds or ‘s’ for seconds.</p></li>
<li><p><strong>title</strong> (<em>String</em>) – Title of the gfile on the first line. Name cannot
exceed 10 digits. This is so that the style of the first line
is preserved.</p></li>
<li><p><strong>nbbbs</strong> (<em>scalar integer</em>) – Number of points to define the plasma
seperatrix within the gfile.  The points are defined equally
spaced in angle about the plasma center.  This will cause the
x-point to be poorly defined.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If title is longer than 10 characters.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> abstract class (example
shot number of 1001).</p>
<p>Generate a gfile at t=0.26s, output of g1001.26:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Eq_instance</span><span class="o">.</span><span class="n">gfile</span><span class="p">(</span><span class="o">.</span><span class="mi">26</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.plotFlux">
<code class="sig-name descname">plotFlux</code><span class="sig-paren">(</span><em class="sig-param">fill=True</em>, <em class="sig-param">mask=True</em>, <em class="sig-param">lw=3.0</em>, <em class="sig-param">add_title=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.plotFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.plotFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots flux contours directly from psi grid.</p>
<p>Returns the Figure instance created and the time slider widget (in case
you need to modify the callback). <cite>f.axes</cite> contains the contour plot as
the first element and the time slice slider as the second element.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill</strong> (<em>Boolean</em>) – Set True to plot filled contours.  Set False (default) to plot white-background
color contours.</p></li>
<li><p><strong>mask</strong> (<em>Boolean</em>) – Set True (default) to mask the contours according to the vacuum
vessel outline.</p></li>
<li><p><strong>lw</strong> (<em>float</em>) – Linewidth when plotting LCFS. Default is 3.0.</p></li>
<li><p><strong>add_title</strong> (<em>Boolean</em>) – Set True (default) to add a figure title with the time indicated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.eqdskreader">
<span id="eqtools-eqdskreader-module"></span><h2>eqtools.eqdskreader module<a class="headerlink" href="#module-eqtools.eqdskreader" title="Permalink to this headline">¶</a></h2>
<p>This module contains the EqdskReader class, which creates Equilibrium class
functionality for equilibria stored in eqdsk files from EFIT(a- and g-files).</p>
<dl class="simple">
<dt>Classes:</dt><dd><dl class="simple">
<dt>EqdskReader:</dt><dd><p>Class inheriting Equilibrium reading g- and a-files for
equilibrium data.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="eqtools.eqdskreader.EqdskReader">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.eqdskreader.</code><code class="sig-name descname">EqdskReader</code><span class="sig-paren">(</span><em class="sig-param">shot=None</em>, <em class="sig-param">time=None</em>, <em class="sig-param">gfile=None</em>, <em class="sig-param">afile=None</em>, <em class="sig-param">length_unit='m'</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">eqtools.core.Equilibrium</span></code></a></p>
<p>Equilibrium subclass working from eqdsk ASCII-file equilibria.</p>
<p>Inherits mapping and structural data from Equilibrium, populates equilibrium
and profile data from g- and a-files for a selected shot and time window.</p>
<p>Create instance of EqdskReader.</p>
<p>Generates object and reads data from selected g-file (either manually set or
autodetected based on user shot and time selection), storing as object
attributes for usage in Equilibrium mapping methods.</p>
<p>Calling structure - user may call class with shot and time (ms) values, set
by keywords (or positional placement allows calling without explicit keyword
syntax).  EqdskReader then attempts to construct filenames from the
shot/time, of the form ‘g[shot].[time]’ and ‘a[shot].[time]’.  Alternately,
the user may skip this input and explicitly set paths to the g- and/or
a-files, using the gfile and afile keyword arguments.  If both types of
calls are set, the explicit g-file and a-file paths override the
auto-generated filenames from the shot and time.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shot</strong> (<em>Integer</em>) – Shot index.</p></li>
<li><p><strong>time</strong> (<em>Integer</em>) – Time index (typically ms).  Shot and Time used to
autogenerate filenames.</p></li>
<li><p><strong>gfile</strong> (<em>String</em>) – Manually selects ASCII file for equilibrium read.</p></li>
<li><p><strong>afile</strong> (<em>String</em>) – Manually selects ASCII file for time-history read.</p></li>
<li><p><strong>length_unit</strong> (<em>String</em>) – Flag setting length unit for equilibrium scales.
Defaults to ‘m’ for lengths in meters.</p></li>
<li><p><strong>verbose</strong> (<em>Boolean</em>) – When set to False, suppresses terminal outputs during
CSV read.  Defaults to True (prints terminal output).</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IOError</strong> – if both name/shot and explicit filenames are not set.</p></li>
<li><p><strong>ValueError</strong> – if the g-file cannot be found, or if multiple valid
    g/a-files are found.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Instantiate EqdskReader for a given <cite>shot</cite> and <cite>time</cite> – will search current
working directory for files of the form g[shot].[time] and
a[shot].[time], suppressing terminal outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">edr</span> <span class="o">=</span> <span class="n">eqtools</span><span class="o">.</span><span class="n">EqdskReader</span><span class="p">(</span><span class="n">shot</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">edr</span> <span class="o">=</span> <span class="n">eqtools</span><span class="o">.</span><span class="n">EqdskReader</span><span class="p">(</span><span class="n">shot</span><span class="o">=</span><span class="n">shot</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Instantiate EqdskReader with explicit file paths <cite>gfile_path</cite> and
<cite>afile_path</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">edr</span> <span class="o">=</span> <span class="n">eqtools</span><span class="o">.</span><span class="n">EqdskReader</span><span class="p">(</span><span class="n">gfile</span><span class="o">=</span><span class="n">gfile_path</span><span class="p">,</span><span class="n">afile</span><span class="o">=</span><span class="n">afile_path</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getInfo">
<code class="sig-name descname">getInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>returns namedtuple of equilibrium information</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>namedtuple containing</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>shot</p></td>
<td><p>shot index</p></td>
</tr>
<tr class="row-even"><td><p>time</p></td>
<td><p>time point of g-file</p></td>
</tr>
<tr class="row-odd"><td><p>nr</p></td>
<td><p>size of R-axis of spatial grid</p></td>
</tr>
<tr class="row-even"><td><p>nz</p></td>
<td><p>size of Z-axis of spatial grid</p></td>
</tr>
<tr class="row-odd"><td><p>efittype</p></td>
<td><p>EFIT calculation type (magnetic, kinetic, MSE)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.readAFile">
<code class="sig-name descname">readAFile</code><span class="sig-paren">(</span><em class="sig-param">afile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.readAFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.readAFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a-file (scalar time-history data) to pull additional
equilibrium data not found in g-file, populates remaining data
(initialized as None) in object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>afile</strong> (<em>String</em>) – Path to ASCII a-file.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IOError</strong> – If afile is not found.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2psi">
<code class="sig-name descname">rz2psi</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2psi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the non-normalized poloidal flux at the given (<cite>R</cite>, <cite>Z</cite>).
Wrapper for
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2psi" title="eqtools.core.Equilibrium.rz2psi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2psi</span></code></a> masking
out timebase dependence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to poloidal flux.  If <cite>R</cite> and <cite>Z</cite> are both scalar, then a
scalar <cite>psi</cite> is returned.  <cite>R</cite> and <cite>Z</cite> must have the same shape
unless the <cite>make_grid</cite> keyword is set.  If <cite>make_grid</cite> is True,
<cite>R</cite> must have shape (<cite>len_R</cite>,).</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to poloidal flux.  If <cite>R</cite> and <cite>Z</cite> are both scalar, then a
scalar <cite>psi</cite> is returned.  <cite>R</cite> and <cite>Z</cite> must have the same shape
unless the <cite>make_grid</cite> keyword is set.  If <cite>make_grid</cite> is True,
<cite>Z</cite> must have shape (<cite>len_Z</cite>,).</p></li>
</ul>
</dd>
</dl>
<p>All keyword arguments are passed to the parent
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2psi" title="eqtools.core.Equilibrium.rz2psi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2psi</span></code></a>.
Remaining arguments in *args are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>non-normalized poloidal flux.  If
all input arguments are scalar, then <cite>psi</cite> is scalar.  IF <cite>R</cite> and <cite>Z</cite>
have the same shape, then <cite>psi</cite> has this shape as well.  If <cite>make_grid</cite>
is True, then <cite>psi</cite> has the shape (<cite>len_R</cite>, <cite>len_Z</cite>).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psi (Array-like or scalar float)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance EqdskReader:</p>
<p>Find single psi value at R=0.6m, Z=0.0m:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psi values on grid defined by 1D vector of radial positions
R and 1D vector of vertical positions Z:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2psinorm">
<code class="sig-name descname">rz2psinorm</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux at the given (R,Z).
Wrapper for
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2psinorm" title="eqtools.core.Equilibrium.rz2psinorm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2psinorm</span></code></a>
masking out timebase dependence.</p>
<p>Uses the definition:</p>
<div class="math">
<p><img src="_images/math/4e65498890f7e906998889a8593a862b902ffe4b.png" alt="\texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}"/></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to normalized poloidal flux.  Must have the same shape as
<cite>Z</cite> unless the <cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite>
keyword is True, <cite>R</cite> must have shape (<cite>len_R</cite>,).</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to normalized poloidal flux.  Must have the same shape as
<cite>R</cite> unless the <cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite>
keyword is True, <cite>Z</cite> must have shape (<cite>len_Z</cite>,).</p></li>
</ul>
</dd>
</dl>
<p>All keyword arguments are passed to the parent
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2psinorm" title="eqtools.core.Equilibrium.rz2psinorm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2psinorm</span></code></a>.
Remaining arguments in *args are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>non-normalized poloidal flux.  If
all input arguments are scalar, then <cite>psinorm</cite> is scalar.  IF <cite>R</cite> and <cite>Z</cite>
have the same shape, then <cite>psinorm</cite> has this shape as well.  If <cite>make_grid</cite>
is True, then <cite>psinorm</cite> has the shape (<cite>len_R</cite>, <cite>len_Z</cite>).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psinorm (Array-like or scalar float)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of EqdskReader:</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions
R and 1D vector of vertical positions Z:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2phinorm">
<code class="sig-name descname">rz2phinorm</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates normalized toroidal flux at a given (R,Z), using</p>
<div class="math">
<p><img src="_images/math/3fea3cea57d8b7a9bc94dbe2b95fdb0531129c0d.png" alt="\texttt{phi} &amp;= \int q(\psi)\,d\psi\\
\texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}"/></p>
</div><p>Wrapper for
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2phinorm" title="eqtools.core.Equilibrium.rz2phinorm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2phinorm</span></code></a>
masking out timebase dependence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to normalized toroidal flux. Must have the same shape as <cite>Z</cite>
unless the <cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite>
keyword is True, R must have shape (<cite>len_R</cite>,).</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to normalized toroidal flux. Must have the same shape as <cite>R</cite>
unless the <cite>make_grid</cite> keyword is set. If the <cite>make_grid</cite>
keyword is True, Z must have shape (<cite>len_Z</cite>,).</p></li>
</ul>
</dd>
</dl>
<p>All keyword arguments are passed to the parent
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2phinorm" title="eqtools.core.Equilibrium.rz2phinorm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2phinorm</span></code></a>.
Remaining arguments in *args are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>non-normalized poloidal flux.  If
all input arguments are scalar, then <cite>phinorm</cite> is scalar.  IF <cite>R</cite> and <cite>Z</cite>
have the same shape, then <cite>phinorm</cite> has this shape as well.  If <cite>make_grid</cite>
is True, then <cite>phinorm</cite> has the shape (<cite>len_R</cite>, <cite>len_Z</cite>).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>phinorm (Array-like or scalar float)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of EqdskReader.</p>
<p>Find single phinorm value at R=0.6m, Z=0.0m:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values on grid defined by 1D vector of radial positions
R and 1D vector of vertical positions Z:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2volnorm">
<code class="sig-name descname">rz2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume.</p>
<p>Not implemented for EqdskReader, as necessary parameter
is not read from a/g-files.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – in all cases.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2rho">
<code class="sig-name descname">rz2rho</code><span class="sig-paren">(</span><em class="sig-param">method</em>, <em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t=False</em>, <em class="sig-param">sqrt=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">k=3</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R, Z) coordinates into one of several
normalized coordinates.  Wrapper for
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2rho" title="eqtools.core.Equilibrium.rz2rho"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2rho</span></code></a> masking
timebase dependence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>String</em>) – <p>Indicates which normalized coordinates to use.
Valid options are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>psinorm</p></td>
<td><p>Normalized poloidal flux</p></td>
</tr>
<tr class="row-even"><td><p>phinorm</p></td>
<td><p>Normalized toroidal flux</p></td>
</tr>
<tr class="row-odd"><td><p>volnorm</p></td>
<td><p>Normalized volume</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</p></li>
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to normalized coordinate. Must have the same shape as <cite>Z</cite>
unless the make_grid keyword is set. If the make_grid keyword
is True, <cite>R</cite> must have shape (<cite>len_R</cite>,).</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to normalized coordinate. Must have the same shape as <cite>R</cite>
unless the make_grid keyword is set. If the make_grid keyword
is True, <cite>Z</cite> must have shape (<cite>len_Z</cite>,).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>t</strong> (<em>indeterminant</em>) – Provides duck typing for inclusion of t values.
Passed t values either as an Arg or Kwarg are neglected.</p></li>
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of normalized
coordinate. Only the square root of positive values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe’s IDL implementation efit_rz2rho.pro. Default is False
(return normalized coordinate itself).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).</p>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If all of the input arguments are
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
rho has this shape as well. If the make_grid keyword was True
then rho has shape (len(Z), len(R)).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rho (Array-like or scalar float)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If method is not one of the supported values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2rmid">
<code class="sig-name descname">rz2rmid</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">Z</em>, <em class="sig-param">t=False</em>, <em class="sig-param">sqrt=False</em>, <em class="sig-param">make_grid=False</em>, <em class="sig-param">rho=False</em>, <em class="sig-param">k=3</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given points to the outboard midplane major radius, R_mid.
Wrapper for
<a class="reference internal" href="#eqtools.core.Equilibrium.rz2rmid" title="eqtools.core.Equilibrium.rz2rmid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Equilibrium.rz2rmid</span></code></a>
masking timebase dependence.</p>
<p>Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the radial coordinate to
map to midplane radius. Must have the same shape as <cite>Z</cite> unless
the make_grid keyword is set. If the make_grid keyword is True,
<cite>R</cite> must have shape (<cite>len_R</cite>,).</p></li>
<li><p><strong>Z</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the vertical coordinate to
map to midplane radius. Must have the same shape as <cite>R</cite> unless
the make_grid keyword is set. If the make_grid keyword is True,
<cite>Z</cite> must have shape (<cite>len_Z</cite>,).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>t</strong> (<em>indeterminant</em>) – Provides duck typing for inclusion of t values.
Passed t values either as an Arg or Kwarg are neglected.</p></li>
<li><p><strong>sqrt</strong> (<em>Boolean</em>) – Set to True to return the square root of midplane
radius. Only the square root of positive values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe’s IDL implementation efit_rz2rho.pro. Default is False
(return R_mid itself).</p></li>
<li><p><strong>make_grid</strong> (<em>Boolean</em>) – Set to True to pass <cite>R</cite> and <cite>Z</cite> through
meshgrid before evaluating. If this is set to True, <cite>R</cite> and <cite>Z</cite>
must each only have a single dimension, but can have different
lengths.  Default is False (do not form meshgrid).</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of <cite>R_mid</cite>. Default is False (return major radius,
R_mid).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that R and Z are being given
in AND that R_mid is returned in. If a string is given, it
must be a valid unit specifier:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters, R_mid returned in meters).</p>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If all of the input arguments are
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If <cite>R</cite> and <cite>Z</cite> both have the same shape
then <cite>R_mid</cite> has this shape as well. If the make_grid keyword
was True then <cite>R_mid</cite> has shape (<cite>len(Z)</cite>, <cite>len(R)</cite>).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R_mid (Array or scalar float)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single R_mid value at R=0.6m, Z=0.0m:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find R_mid values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.psinorm2rmid">
<code class="sig-name descname">psinorm2rmid</code><span class="sig-paren">(</span><em class="sig-param">psi_norm</em>, <em class="sig-param">t=False</em>, <em class="sig-param">rho=False</em>, <em class="sig-param">k=3</em>, <em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.psinorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.psinorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outboard R_mid location corresponding to the passed
psi_norm (normalized poloidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to midplane radius.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>t</strong> (<em>indeterminant</em>) – Provides duck typing for inclusion of t values.
Passed <cite>t</cite> values either as an Arg or Kwarg are neglected.</p></li>
<li><p><strong>rho</strong> (<em>Boolean</em>) – Set to True to return r/a (normalized minor radius)
instead of <cite>R_mid</cite>. Default is False (return major radius,
<cite>R_mid</cite>).</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
<li><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – <p>Length unit that <cite>R_mid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>’m’</p></td>
<td><p>meters</p></td>
</tr>
<tr class="row-even"><td><p>’cm’</p></td>
<td><p>centimeters</p></td>
</tr>
<tr class="row-odd"><td><p>’mm’</p></td>
<td><p>millimeters</p></td>
</tr>
<tr class="row-even"><td><p>’in’</p></td>
<td><p>inches</p></td>
</tr>
<tr class="row-odd"><td><p>’ft’</p></td>
<td><p>feet</p></td>
</tr>
<tr class="row-even"><td><p>’yd’</p></td>
<td><p>yards</p></td>
</tr>
<tr class="row-odd"><td><p>’smoot’</p></td>
<td><p>smoots</p></td>
</tr>
<tr class="row-even"><td><p>’cubit’</p></td>
<td><p>cubits</p></td>
</tr>
<tr class="row-odd"><td><p>’hand’</p></td>
<td><p>hands</p></td>
</tr>
<tr class="row-even"><td><p>’default’</p></td>
<td><p>meters</p></td>
</tr>
</tbody>
</table>
<p>If <cite>length_unit</cite> is 1 or None, meters are assumed. The default
value is 1 (<cite>R_mid</cite> returned in meters).</p>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If all of the input arguments
are scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R_mid (Array-like or scalar float)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single R_mid value for psinorm=0.7:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at psi_norm values of 0.5 and 0.7.
Note that the Z vector must be fully specified, even if the
values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.psinorm2volnorm">
<code class="sig-name descname">psinorm2volnorm</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.psinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.psinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outboard R_mid location corresponding to psi_norm
(normalized poloidal flux) values.</p>
<p>Not implemented for EqdskReader, as necessary parameter is not read
from a/g-files.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – in all cases.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.psinorm2phinorm">
<code class="sig-name descname">psinorm2phinorm</code><span class="sig-paren">(</span><em class="sig-param">psi_norm</em>, <em class="sig-param">t=False</em>, <em class="sig-param">k=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.psinorm2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.psinorm2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux corresponding to the passed
psi_norm (normalized poloidal flux) values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>psi_norm</strong> (<em>Array-like</em><em> or </em><em>scalar float</em>) – Values of the normalized
poloidal flux to map to normalized toroidal flux.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>t</strong> (<em>indeterminant</em>) – Provides duck typing for inclusion of t values.
Passed <cite>t</cite> values either as an Arg or Kwarg are neglected.</p></li>
<li><p><strong>k</strong> (<em>positive int</em>) – The degree of polynomial spline interpolation to
use in converting coordinates.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If all of the input arguments
are scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>phinorm (Array-like or scalar float)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single phinorm value for psinorm=0.7:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psi_norm values of 0.5 and 0.7.
Note that the Z vector must be fully specified, even if the
values are all the same:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getTimeBase">
<code class="sig-name descname">getTimeBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT time point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1-element, 1D array of time in s.  Returns array for
consistency with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>time (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getCurrentSign">
<code class="sig-name descname">getCurrentSign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the current, based on the check in Steve Wolfe’s
IDL implementation efit_rz2psi.pro.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1 for positive current, -1 for reversed.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>currentSign (Int)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxGrid">
<code class="sig-name descname">getFluxGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT flux grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,r,z] Array of flux values.  Includes 1-element
time axis for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> implementations
with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psiRZ (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRGrid">
<code class="sig-name descname">getRGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT R-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[r] array of R-axis values for RZ grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getZGrid">
<code class="sig-name descname">getZGrid</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT Z-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[z] array of Z-axis values for RZ grid.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Z (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxAxis">
<code class="sig-name descname">getFluxAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns psi on magnetic axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of psi on magnetic axis.  Returns array for
consistency with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psi0 (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxLCFS">
<code class="sig-name descname">getFluxLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns psi at separatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of psi at separatrix.  Returns array for
consistency with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>psia (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRLCFS">
<code class="sig-name descname">getRLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns array of R-values of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of R values describing LCFS.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> implementations
with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>RLCFS (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getZLCFS">
<code class="sig-name descname">getZLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns array of Z-values of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of Z values describing LCFS.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a> implementations
with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ZLCFS (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.remapLCFS">
<code class="sig-name descname">remapLCFS</code><span class="sig-paren">(</span><em class="sig-param">mask=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites RLCFS, ZLCFS values pulled from EFIT with
explicitly-calculated contour of psinorm=1 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>mask</strong> (<em>Boolean</em>) – Set True to mask LCFS path to limiter outline
(using inPolygon).  Set False to draw full contour of
psi = psiLCFS.  Defaults to False.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxVol">
<code class="sig-name descname">getFluxVol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns volume contained within a flux surface as a function of psi.</p>
<p>Not implemented in <a class="reference internal" href="#eqtools.eqdskreader.EqdskReader" title="eqtools.eqdskreader.EqdskReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">EqdskReader</span></code></a>, as required data is not
stored in g/a-files.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – in all cases.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getVolLCFS">
<code class="sig-name descname">getVolLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns volume with LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of plasma volume.  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Vol (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRmidPsi">
<code class="sig-name descname">getRmidPsi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane major radius of flux surfaces.</p>
<p>Data not read from a/g-files, not implemented for <a class="reference internal" href="#eqtools.eqdskreader.EqdskReader" title="eqtools.eqdskreader.EqdskReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">EqdskReader</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – in all cases.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getF">
<code class="sig-name descname">getF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), calculated for grad-shafranov solutions
[psi,t]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of F(psi).  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>F (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxPres">
<code class="sig-name descname">getFluxPres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns pressure on flux surface p(psi).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of pressure.  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>p (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFFPrime">
<code class="sig-name descname">getFFPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF’ function used for grad-shafranov solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of FF’(psi).  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>FF (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getPPrime">
<code class="sig-name descname">getPPrime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of pp’(psi).  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pp (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getElongation">
<code class="sig-name descname">getElongation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns elongation of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of plasma elongation.  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>kappa (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getUpperTriangularity">
<code class="sig-name descname">getUpperTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns upper triangularity of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of plasma upper triangularity.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>delta (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getLowerTriangularity">
<code class="sig-name descname">getLowerTriangularity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns lower triangularity of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of plasma lower triangularity.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>delta (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getShaping">
<code class="sig-name descname">getShaping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getShaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getShaping" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls LCFS elongation, upper/lower triangularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing [kappa,delta_u,delta_l].</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMagR">
<code class="sig-name descname">getMagR</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns major radius of magnetic axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – length unit R is specified in.  Defaults
to 1 (default unit of rmagx, typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of major radius of magnetic axis.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>magR (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMagZ">
<code class="sig-name descname">getMagZ</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Z of magnetic axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – length unit Z is specified in.  Defaults
to 1 (default unit of zmagx, typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of Z of magnetic axis.  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>magZ (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getAreaLCFS">
<code class="sig-name descname">getAreaLCFS</code><span class="sig-paren">(</span><em class="sig-param">length_unit=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns surface area of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>2</em>) – unit area is specified in.  Defaults to 2
(default unit, typically m^2).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of surface area of LCFS.  Returns array
for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AreaLCFS (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getAOut">
<code class="sig-name descname">getAOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit radius is specified in.  Defaults
to 1 (default unit, typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of outboard-midplane minor radius at LCFS.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AOut (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRmidOut">
<code class="sig-name descname">getRmidOut</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane major radius of LCFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit radius is specified in.  Defaults to
1 (default unit, typically m).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of outboard-midplane major radius at LCFS.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rmid (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getGeometry">
<code class="sig-name descname">getGeometry</code><span class="sig-paren">(</span><em class="sig-param">length_unit=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls dimensional geometry parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em>) – length unit parameters are specified in.
Defaults to None, using default units for individual getter
methods for constituent parameters.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>namedtuple containing [Rmag,Zmag,AreaLCFS,aOut,RmidOut]</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQProfile">
<code class="sig-name descname">getQProfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q(psi).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1,n] array of q(psi).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qpsi (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ0">
<code class="sig-name descname">getQ0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q on-axis, q0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of q(psi=0).  Returns array for consistency
with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q0 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ95">
<code class="sig-name descname">getQ95</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q at 95% flux surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of q(psi=0.95).  Returns array for consistency
with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>q95 (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQLCFS">
<code class="sig-name descname">getQLCFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q at LCFS (interpolated).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of q* (interpolated).  Returns array for
consistency with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>qLCFS (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not loaded.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ1Surf">
<code class="sig-name descname">getQ1Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of q=1 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of minor radius.  Defaults to 1
(default unit, typically m)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of minor radius of q=1 surface.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>qr1 (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ2Surf">
<code class="sig-name descname">getQ2Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of q=2 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of minor radius.  Defaults to 1
(default unit, typically m)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of minor radius of q=2 surface.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>qr2 (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ3Surf">
<code class="sig-name descname">getQ3Surf</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of q=3 surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of minor radius.  Defaults to 1
(default unit, typically m)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[1] array of minor radius of q=3 surface.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>qr3 (Array)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQs">
<code class="sig-name descname">getQs</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls q-profile data.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>length_unit</strong> (<em>String</em><em> or </em><em>1</em>) – unit of minor radius.  Defaults to 1
(default unit, typically m)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>namedtuple containing [q0,q95,qLCFS,rq1,rq2,rq3]</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBtVac">
<code class="sig-name descname">getBtVac</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vacuum toroidal field on-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of vacuum toroidal field.  Returns array
for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtVac (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBtPla">
<code class="sig-name descname">getBtPla</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns plasma toroidal field on-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of toroidal field including plasma effects.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BtPla (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBpAvg">
<code class="sig-name descname">getBpAvg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns average poloidal field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of average poloidal field.  Returns array
for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BpAvg (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFields">
<code class="sig-name descname">getFields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls vacuum and plasma toroidal field, poloidal field data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing [BtVac,BtPla,BpAvg]</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getIpCalc">
<code class="sig-name descname">getIpCalc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of EFIT-reconstructed plasma current.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpCalc (Array)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getIpMeas">
<code class="sig-name descname">getIpMeas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns measured plasma current.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of measured plasma current.  Returns
array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>IpMeas (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getJp">
<code class="sig-name descname">getJp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (r,z) grid of toroidal plasma current density.</p>
<p>Data not read from g-file, not implemented for <a class="reference internal" href="#eqtools.eqdskreader.EqdskReader" title="eqtools.eqdskreader.EqdskReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">EqdskReader</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – In all cases.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBetaT">
<code class="sig-name descname">getBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of average toroidal beta.  Returns array
for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaT (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBetaP">
<code class="sig-name descname">getBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of average poloidal beta.  Returns array
for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaP (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getLi">
<code class="sig-name descname">getLi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns internal inductance of plasma.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of internal inductance.  Returns array for
consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Li (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBetas">
<code class="sig-name descname">getBetas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls EFIT-calculated betas and internal inductance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing [betat,betap,Li]</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagFlux">
<code class="sig-name descname">getDiamagFlux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of measured diamagnetic flux.  Returns array
for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Flux (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagBetaT">
<code class="sig-name descname">getDiamagBetaT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop measured toroidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of measured diamagnetic toroidal beta.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>BetaT (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagBetaP">
<code class="sig-name descname">getDiamagBetaP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop measured poloidal beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of measured diamagnetic poloidal beta.
Returns array for consistency with</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><p>BetaP (Array)</p>
<dl class="simple">
<dt><a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a></dt><dd><p>implementations with time variation.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagTauE">
<code class="sig-name descname">getDiamagTauE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of measured energy confinement time.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>TauE (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagWp">
<code class="sig-name descname">getDiamagWp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop measured stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of diamagnetic stored energy.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Wp (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamag">
<code class="sig-name descname">getDiamag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls diamagnetic flux, diamag. measured toroidal and poloidal beta,
stored energy, and energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing [diaFlux,diaBetat,diaBetap,diaTauE,diaWp]</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getWMHD">
<code class="sig-name descname">getWMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of EFIT-reconstructed stored energy.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>WMHD (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getTauMHD">
<code class="sig-name descname">getTauMHD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated energy confinement time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of EFIT-reconstructed energy confinement
time.  Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tauMHD (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getPinj">
<code class="sig-name descname">getPinj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT injected power.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of EFIT-reconstructed injected power.
Returns array for consistency with
<a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Pinj (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getWbdot">
<code class="sig-name descname">getWbdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT d/dt of magnetic stored energy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of d(Wb)/dt.  Returns array for consistency
with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dWdt (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getWpdot">
<code class="sig-name descname">getWpdot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT d/dt of plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[1] array of d(Wp)/dt.  Returns array for consistency
with <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code></a>
implementations with time variation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dWdt (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBCentr">
<code class="sig-name descname">getBCentr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Vacuum toroidal magnetic field in Tesla at Rcentr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[nt] array of B_t at center [T]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>B_cent (Array)</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRCentr">
<code class="sig-name descname">getRCentr</code><span class="sig-paren">(</span><em class="sig-param">length_unit=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRCentr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRCentr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns radius where Bcentr evaluated</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Radial position where Bcent calculated [m]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>R</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if module cannot retrieve data from MDS tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getEnergy">
<code class="sig-name descname">getEnergy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls EFIT stored energy, energy confinement time, injected power,
and d/dt of magnetic and plasma stored energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>namedtuple containing [WMHD,tauMHD,Pinj,Wbdot,Wpdot]</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if a-file data is not read.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getParam">
<code class="sig-name descname">getParam</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Backup function, applying a direct path input for tree-like data
storage access for parameters not typically found in Equilbrium object.
Directly calls attributes read from g/a-files in copy-safe manner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>String</em>) – Parameter name for value stored in EqdskReader
instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored as attribute in
<a class="reference internal" href="#eqtools.eqdskreader.EqdskReader" title="eqtools.eqdskreader.EqdskReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">EqdskReader</span></code></a>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>param (Array-like or scalar float)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AttributeError</strong> – raised if no attribute is found.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMachineCrossSection">
<code class="sig-name descname">getMachineCrossSection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to pull machine cross-section from data storage, convert to
standard format for plotting routine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<cite>R_limiter</cite>, <cite>Z_limiter</cite>)</p>
<ul class="simple">
<li><p><strong>R_limiter</strong> (<cite>Array</cite>) - [n] array of x-values for machine cross-section.</p></li>
<li><p><strong>Z_limiter</strong> (<cite>Array</cite>) - [n] array of y-values for machine cross-section.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMachineCrossSectionFull">
<code class="sig-name descname">getMachineCrossSectionFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vectorization of machine cross-section.</p>
<p>Absent additional data (not found in eqdsks) simply returns
self.getMachineCrossSection().</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.gfile">
<code class="sig-name descname">gfile</code><span class="sig-paren">(</span><em class="sig-param">time=None</em>, <em class="sig-param">nw=None</em>, <em class="sig-param">nh=None</em>, <em class="sig-param">shot=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">tunit='ms'</em>, <em class="sig-param">title='EQTOOLS'</em>, <em class="sig-param">nbbbs=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.gfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.gfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an EFIT gfile with gfile naming convention</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<em>scalar float</em>) – Time of equilibrium to
generate the gfile from. This will use the specified
spline functionality to do so. Allows for it to be
unspecified for single-time-frame equilibria.</p></li>
<li><p><strong>nw</strong> (<em>scalar integer</em>) – Number of points in R.
R is the major radius, and describes the ‘width’ of the
gfile.</p></li>
<li><p><strong>nh</strong> (<em>scalar integer</em>) – Number of points in Z. In cylindrical
coordinates Z is the height, and nh describes the ‘height’
of the gfile.</p></li>
<li><p><strong>shot</strong> (<em>scalar integer</em>) – The shot numer of the equilibrium.
Used to help generate the gfile name if unspecified.</p></li>
<li><p><strong>name</strong> (<em>String</em>) – Name of the gfile.  If unspecified, will follow
standard gfile naming convention (g+shot.time) under current
python operating directory.  This allows for it to be saved
in other directories, etc.</p></li>
<li><p><strong>tunit</strong> (<em>String</em>) – Specified unit for tin. It can only be ‘ms’ for
milliseconds or ‘s’ for seconds.</p></li>
<li><p><strong>title</strong> (<em>String</em>) – Title of the gfile on the first line. Name cannot
exceed 10 digits. This is so that the style of the first line
is preserved.</p></li>
<li><p><strong>nbbbs</strong> (<em>scalar integer</em>) – Number of points to define the plasma
seperatrix within the gfile.  The points are defined equally
spaced in angle about the plasma center.  This will cause the
x-point to be poorly defined.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If title is longer than 10 characters.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Equilibrium</span></code> abstract class (example
shot number of 1001).</p>
<p>Generate a gfile (time at t=.26s) output of g1001.26:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Eq_instance</span><span class="o">.</span><span class="n">gfile</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.plotFlux">
<code class="sig-name descname">plotFlux</code><span class="sig-paren">(</span><em class="sig-param">fill=True</em>, <em class="sig-param">mask=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.plotFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.plotFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>streamlined plotting of flux contours directly from psi grid</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill</strong> (<em>Boolean</em>) – Default True.  Set True to plot filled contours of
flux delineated by black outlines.  Set False to instead plot
color-coded line contours on a blank background.</p></li>
<li><p><strong>mask</strong> (<em>Boolean</em>) – Default True.  Set True to draw a clipping mask
based on the limiter outline for the flux contours.  Set False
to draw the full RZ grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="eqtools-filewriter-module">
<h2>eqtools.filewriter module<a class="headerlink" href="#eqtools-filewriter-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-eqtools.pfilereader">
<span id="eqtools-pfilereader-module"></span><h2>eqtools.pfilereader module<a class="headerlink" href="#module-eqtools.pfilereader" title="Permalink to this headline">¶</a></h2>
<p>This module contains the <a class="reference internal" href="#eqtools.pfilereader.PFileReader" title="eqtools.pfilereader.PFileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">PFileReader</span></code></a> class, a lightweight data
handler for p-file (radial profile) datasets.</p>
<dl class="simple">
<dt>Classes:</dt><dd><dl class="simple">
<dt>PFileReader:</dt><dd><p>Data-storage class for p-file data.  Reads
data from ASCII p-file, storing as copy-safe object
attributes.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="eqtools.pfilereader.PFileReader">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.pfilereader.</code><code class="sig-name descname">PFileReader</code><span class="sig-paren">(</span><em class="sig-param">pfile</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/pfilereader.html#PFileReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.pfilereader.PFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to read ASCII p-file (profile data storage) into lightweight,
user-friendly data structure.</p>
<p>P-files store data blocks containing the following: a header with parameter
name, parameter units, x-axis units, and number of data points, followed by
values of axis x, parameter y, and derivative dy/dx.  Each parameter block
is read into a namedtuple storing</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘name’</p></td>
<td><p>parameter name</p></td>
</tr>
<tr class="row-even"><td><p>‘npts’</p></td>
<td><p>array size</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>abscissa array</p></td>
</tr>
<tr class="row-even"><td><p>‘y’</p></td>
<td><p>data array</p></td>
</tr>
<tr class="row-odd"><td><p>‘dydx’</p></td>
<td><p>data gradient</p></td>
</tr>
<tr class="row-even"><td><p>‘xunits’</p></td>
<td><p>abscissa units</p></td>
</tr>
<tr class="row-odd"><td><p>‘units’</p></td>
<td><p>data units</p></td>
</tr>
</tbody>
</table>
<p>with each namedtuple stored as an attribute of the PFileReader  instance.
This gracefully handles variable formats of p-files (differing versions of
p-files will have different parameters stored).  Data blocks are accessed
as attributes in a copy-safe manner.</p>
<p>Creates instance of PFileReader.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pfile</strong> (<em>String</em>) – Path to ASCII p-file to be loaded.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>verbose</strong> (<em>Boolean</em>) – Option to print message on object creation
listing available data parameters. Defaults to True.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Load p-file data located at <cite>file_path</cite>, while suppressing terminal
output of stored parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pfr</span> <span class="o">=</span> <span class="n">eqtools</span><span class="o">.</span><span class="n">PFileReader</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Recover electron density data (for example):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ne_data</span> <span class="o">=</span> <span class="n">pfr</span><span class="o">.</span><span class="n">ne</span>
</pre></div>
</div>
<p>Recover abscissa and electron density data (for example):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ne</span> <span class="o">=</span> <span class="n">pfr</span><span class="o">.</span><span class="n">ne</span><span class="o">.</span><span class="n">y</span>
<span class="n">abscis</span> <span class="o">=</span> <span class="n">pfr</span><span class="o">.</span><span class="n">ne</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>Available parameters in pfr may be listed via the overridden __str__
command.</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools.trispline">
<span id="eqtools-trispline-module"></span><h2>eqtools.trispline module<a class="headerlink" href="#module-eqtools.trispline" title="Permalink to this headline">¶</a></h2>
<p>This module provides interface to the tricubic spline interpolator. It also
contains an enhanced bivariate spline which generates bounds errors.</p>
<dl class="class">
<dt id="eqtools.trispline.Spline">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.trispline.</code><code class="sig-name descname">Spline</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em>, <em class="sig-param">f</em>, <em class="sig-param">boundary='natural'</em>, <em class="sig-param">dx=0</em>, <em class="sig-param">dy=0</em>, <em class="sig-param">dz=0</em>, <em class="sig-param">bounds_error=True</em>, <em class="sig-param">fill_value=nan</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#Spline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Tricubic interpolating spline with forced edge derivative equal zero
conditions.  It assumes a cartesian grid.  The ordering of f[z,y,x] is
extremely important for the proper evaluation of the spline.  It assumes
that f is in C order.</p>
<p>Create a new Spline instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>1-dimensional float array</em>) – Values of the positions of the 1st
Dimension of f. Must be monotonic without duplicates.</p></li>
<li><p><strong>y</strong> (<em>1-dimensional float array</em>) – Values of the positions of the 2nd
dimension of f. Must be monotonic without duplicates.</p></li>
<li><p><strong>z</strong> (<em>1-dimensional float array</em>) – Values of the positions of the 3rd
dimension of f. Must be monotonic without duplicates.</p></li>
<li><p><strong>f</strong> (<em>3-dimensional float array</em>) – f[x,y,z]. NaN and Inf will hamper
performance and affect interpolation in 4x4x4 space about its value.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>regular</strong> (<em>Boolean</em>) – If the grid is known to be regular, forces
matrix-based fast evaluation of interpolation.</p></li>
<li><p><strong>fast</strong> (<em>Boolean</em>) – Outdated input to test the indexing performance of the
c code vs internal python handling.</p></li>
</ul>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If any of the dimensions do not match specified f dim</p></li>
<li><p><strong>ValueError</strong> – If x,y, or z are not monotonic</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>All assume that <cite>x</cite>, <cite>y</cite>, <cite>z</cite>, and <cite>f</cite> are valid instances of the appropriate
numpy arrays which take independent variables x,y,z and create numpy array
f. <cite>x1</cite>, <cite>y1</cite>, and <cite>z1</cite> are numpy arrays which data f is to be interpolated.</p>
<p>Generate a Trispline instance map with data x, y, z and f:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span> <span class="o">=</span> <span class="n">Spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Evaluate Trispline instance map at x1, y1, z1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="eqtools.trispline.Spline.ev">
<code class="sig-name descname">ev</code><span class="sig-paren">(</span><em class="sig-param">xi</em>, <em class="sig-param">yi</em>, <em class="sig-param">zi</em>, <em class="sig-param">dx=0</em>, <em class="sig-param">dy=0</em>, <em class="sig-param">dz=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#Spline.ev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.Spline.ev" title="Permalink to this definition">¶</a></dt>
<dd><p>evaluates tricubic spline at point (xi,yi,zi) which is f[xi,yi,zi].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xi</strong> (<em>scalar float</em><em> or </em><em>1-dimensional float</em>) – Position in x dimension.
This is the first dimension of 3d-valued grid.</p></li>
<li><p><strong>yi</strong> (<em>scalar float</em><em> or </em><em>1-dimensional float</em>) – Position in y dimension.
This is the second dimension of 3d-valued grid.</p></li>
<li><p><strong>zi</strong> (<em>scalar float</em><em> or </em><em>1-dimensional float</em>) – Position in z dimension.
This is the third dimension of 3d-valued grid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated value at (xi,yi,zi).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>val (array or scalar float)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the dimensions exceed the evaluation boundary
    of the grid</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.trispline.RectBivariateSpline">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.trispline.</code><code class="sig-name descname">RectBivariateSpline</code><span class="sig-paren">(</span><em class="sig-param">x, y, z, bbox=[None, None, None, None], kx=3, ky=3, s=0, bounds_error=True, fill_value=nan</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#RectBivariateSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.RectBivariateSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.fitpack2.RectBivariateSpline</span></code></p>
<p>the lack of a graceful bounds error causes the fortran to fail hard.
This masks scipy.interpolate.RectBivariateSpline with a proper bound
checker and value filler such that it will not fail in use for EqTools</p>
<p>Can be used for both smoothing and interpolating data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>1-dimensional float array</em>) – 1-D array of coordinates in monotonically increasing order.</p></li>
<li><p><strong>y</strong> (<em>1-dimensional float array</em>) – 1-D array of coordinates in monotonically increasing order.</p></li>
<li><p><strong>z</strong> (<em>2-dimensional float array</em>) – 2-D array of data with shape (x.size,y.size).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>bbox</strong> (<em>1-dimensional float</em>) – Sequence of length 4 specifying the
boundary of the rectangular approximation domain.  By default,
<code class="docutils literal notranslate"><span class="pre">bbox=[min(x,tx),max(x,tx),</span> <span class="pre">min(y,ty),max(y,ty)]</span></code>.</p></li>
<li><p><strong>kx</strong> (<em>integer</em>) – Degrees of the bivariate spline. Default is 3.</p></li>
<li><p><strong>ky</strong> (<em>integer</em>) – Degrees of the bivariate spline. Default is 3.</p></li>
<li><p><strong>s</strong> (<em>float</em>) – Positive smoothing factor defined for estimation condition,
<code class="docutils literal notranslate"><span class="pre">sum((w[i]*(z[i]-s(x[i],</span> <span class="pre">y[i])))**2,</span> <span class="pre">axis=0)</span> <span class="pre">&lt;=</span> <span class="pre">s</span></code>
Default is <code class="docutils literal notranslate"><span class="pre">s=0</span></code>, which is for interpolation.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="eqtools.trispline.RectBivariateSpline.ev">
<code class="sig-name descname">ev</code><span class="sig-paren">(</span><em class="sig-param">xi</em>, <em class="sig-param">yi</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#RectBivariateSpline.ev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.RectBivariateSpline.ev" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Evaluate the rectBiVariateSpline at (xi,yi).  (x,y)values are</dt><dd><p>checked for being in the bounds of the interpolated data.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xi</strong> (<em>float array</em>) – input x dimensional values</p></li>
<li><p><strong>yi</strong> (<em>float array</em>) – input x dimensional values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>evaluated spline at points (x[i], y[i]), i=0,…,len(x)-1</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>val (float array)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.trispline.BivariateInterpolator">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.trispline.</code><code class="sig-name descname">BivariateInterpolator</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#BivariateInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.BivariateInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class provides a wrapper for <cite>scipy.interpolate.CloughTocher2DInterpolator</cite>.</p>
<p>This is necessary because <cite>scipy.interpolate.SmoothBivariateSpline</cite> cannot
be made to interpolate, and gives inaccurate answers near the boundaries.</p>
<dl class="method">
<dt id="eqtools.trispline.BivariateInterpolator.ev">
<code class="sig-name descname">ev</code><span class="sig-paren">(</span><em class="sig-param">xi</em>, <em class="sig-param">yi</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#BivariateInterpolator.ev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.BivariateInterpolator.ev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.trispline.UnivariateInterpolator">
<em class="property">class </em><code class="sig-prename descclassname">eqtools.trispline.</code><code class="sig-name descname">UnivariateInterpolator</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/eqtools/trispline.html#UnivariateInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.UnivariateInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.fitpack2.InterpolatedUnivariateSpline</span></code></p>
<p>Interpolated spline class which overcomes the shortcomings of interp1d
(inaccurate near edges) and InterpolatedUnivariateSpline (can’t set NaN
where it extrapolates).</p>
</dd></dl>

</div>
<div class="section" id="module-eqtools">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-eqtools" title="Permalink to this headline">¶</a></h2>
<p>Provides classes for interacting with magnetic equilibrium data in a variety of formats.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">eqtools package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-eqtools.AUGData">eqtools.AUGData module</a></li>
<li><a class="reference internal" href="#module-eqtools.CModEFIT">eqtools.CModEFIT module</a></li>
<li><a class="reference internal" href="#module-eqtools.D3DEFIT">eqtools.D3DEFIT module</a></li>
<li><a class="reference internal" href="#module-eqtools.EFIT">eqtools.EFIT module</a></li>
<li><a class="reference internal" href="#module-eqtools.FromArrays">eqtools.FromArrays module</a></li>
<li><a class="reference internal" href="#module-eqtools.NSTXEFIT">eqtools.NSTXEFIT module</a></li>
<li><a class="reference internal" href="#module-eqtools.TCVLIUQE">eqtools.TCVLIUQE module</a></li>
<li><a class="reference internal" href="#module-eqtools.afilereader">eqtools.afilereader module</a></li>
<li><a class="reference internal" href="#module-eqtools.core">eqtools.core module</a></li>
<li><a class="reference internal" href="#module-eqtools.eqdskreader">eqtools.eqdskreader module</a></li>
<li><a class="reference internal" href="#eqtools-filewriter-module">eqtools.filewriter module</a></li>
<li><a class="reference internal" href="#module-eqtools.pfilereader">eqtools.pfilereader module</a></li>
<li><a class="reference internal" href="#module-eqtools.trispline">eqtools.trispline module</a></li>
<li><a class="reference internal" href="#module-eqtools">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">eqtools: Tools for interacting with magnetic equilibria</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/eqtools.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="eqtools: Tools for interacting with magnetic equilibria"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">eqtools 1.3.2 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Mark Chilenski, Ian Faust and John Walk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>