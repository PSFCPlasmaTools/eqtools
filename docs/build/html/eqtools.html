<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>eqtools package &mdash; eqtools 1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="eqtools 1.1 documentation" href="index.html" />
    <link rel="prev" title="eqtools: Tools for interacting with magnetic equilibria" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="eqtools: Tools for interacting with magnetic equilibria"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">eqtools 1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="eqtools-package">
<h1>eqtools package<a class="headerlink" href="#eqtools-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-eqtools.CModEFIT">
<span id="eqtools-cmodefit-module"></span><h2>eqtools.CModEFIT module<a class="headerlink" href="#module-eqtools.CModEFIT" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes for working with C-Mod EFIT data.</p>
<dl class="class">
<dt id="eqtools.CModEFIT.CModEFITTree">
<em class="property">class </em><tt class="descclassname">eqtools.CModEFIT.</tt><tt class="descname">CModEFITTree</tt><big>(</big><em>shot</em>, <em>tree='ANALYSIS'</em>, <em>length_unit='m'</em>, <em>gfile='g_eqdsk'</em>, <em>afile='a_eqdsk'</em>, <em>tspline=False</em>, <em>monotonic=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.EFIT.EFITTree</span></tt></a></p>
<p>Inherits <tt class="xref py py-class docutils literal"><span class="pre">EFITTree</span></tt> class. Machine-specific data
handling class for Alcator C-Mod. Pulls EFIT data from selected MDS tree
and shot, stores as object attributes. Each EFIT variable or set of
variables is recovered with a corresponding getter method. Essential data
for EFIT mapping are pulled on initialization (e.g. psirz grid). Additional
data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes C-Mod version of EFITTree object.  Pulls data from MDS tree for storage
in instance attributes.  Core attributes are populated from the MDS tree on initialization.
Additional attributes are initialized as None, filled on the first request to the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shot</strong> &#8211; (long) int
C-Mod shot index (long)</li>
<li><strong>tree</strong> &#8211; str
Optional input for EFIT tree, defaults to &#8216;ANALYSIS&#8217;
(i.e., EFIT data are under analysis::top.efit.results).
For any string TREE (such as &#8216;EFIT20&#8217;) other than &#8216;ANALYSIS&#8217;,
data are taken from TREE::top.results.</li>
<li><strong>length_unit</strong> &#8211; <p>str
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is &#8216;m&#8217; (all units taken and returned in meters).</p>
</li>
<li><strong>gfile</strong> &#8211; str
Optional input for EFIT geqdsk location name, defaults to &#8216;g_eqdsk&#8217;
(i.e., EFIT data are under tree::top.results.G_EQDSK)</li>
<li><strong>afile</strong> &#8211; str
Optional input for EFIT aeqdsk location name, defaults to &#8216;a_eqdsk&#8217;
(i.e., EFIT data are under tree::top.results.A_EQDSK)</li>
<li><strong>tspline</strong> &#8211; Boolean
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</li>
<li><strong>monotonic</strong> &#8211; Boolean
Sets whether or not the &#8220;monotonic&#8221; form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getFluxVol">
<tt class="descname">getFluxVol</tt><big>(</big><em>length_unit=3</em><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getRmidPsi">
<tt class="descname">getRmidPsi</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getF">
<tt class="descname">getF</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov solutions  [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getFluxPres">
<tt class="descname">getFluxPres</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>returns pressure at flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getFFPrime">
<tt class="descname">getFFPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF&#8217; function used for grad-shafranov solutions [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getPPrime">
<tt class="descname">getPPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getQProfile">
<tt class="descname">getQProfile</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>returns safety factor q [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getRLCFS">
<tt class="descname">getRLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-values of LCFS position [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getZLCFS">
<tt class="descname">getZLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-values of LCFS position [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.CModEFIT.CModEFITTree.getMachineCrossSectionFull">
<tt class="descname">getMachineCrossSectionFull</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTree.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTree.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls C-Mod cross-section data from tree, converts to plottable
vector format for use in other plotting routines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shot</strong> &#8211; (long) int
C-Mod shot index (used for tree access)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The coordinates of the machine cross-section.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(x, y)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.CModEFIT.CModEFITTreeProp">
<em class="property">class </em><tt class="descclassname">eqtools.CModEFIT.</tt><tt class="descname">CModEFITTreeProp</tt><big>(</big><em>shot</em>, <em>tree='ANALYSIS'</em>, <em>length_unit='m'</em>, <em>gfile='g_eqdsk'</em>, <em>afile='a_eqdsk'</em>, <em>tspline=False</em>, <em>monotonic=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/CModEFIT.html#CModEFITTreeProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.CModEFIT.CModEFITTreeProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.CModEFIT.CModEFITTree" title="eqtools.CModEFIT.CModEFITTree"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.CModEFIT.CModEFITTree</span></tt></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.core.PropertyAccessMixin</span></tt></a></p>
<p>CModEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="eqtools-d3defit-module">
<h2>eqtools.D3DEFIT module<a class="headerlink" href="#eqtools-d3defit-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-eqtools.EFIT">
<span id="eqtools-efit-module"></span><h2>eqtools.EFIT module<a class="headerlink" href="#module-eqtools.EFIT" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="eqtools.EFIT.EFITTree">
<em class="property">class </em><tt class="descclassname">eqtools.EFIT.</tt><tt class="descname">EFITTree</tt><big>(</big><em>shot</em>, <em>tree</em>, <em>root</em>, <em>length_unit='m'</em>, <em>gfile='g_eqdsk'</em>, <em>afile='a_eqdsk'</em>, <em>tspline=False</em>, <em>monotonic=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.core.Equilibrium</span></tt></a></p>
<p>Inherits Equilibrium class. EFIT-specific data handling class for machines using
standard EFIT tag names/tree structure with MDSplus. Constructor and/or data loading may
need overriding in a machine-specific implementation.
Pulls EFIT data from selected MDS tree and shot, stores as object attributes.
Each EFIT variable or set of variables is recovered with a corresponding getter method.
Essential data for EFIT mapping are pulled on initialization (e.g. psirz grid).
Additional data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes EFITTree object. Pulls data from MDS tree for storage in
instance attributes. Core attributes are populated from the MDS tree
on initialization. Additional attributes are initialized as None,
filled on the first request to the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shot</strong> &#8211; int
shot number</li>
<li><strong>tree</strong> &#8211; tree
MDSplus tree to open to fetch EFIT data.</li>
<li><strong>root</strong> &#8211; str
Root path for EFIT data in MDSplus tree.</li>
<li><strong>length_unit</strong> &#8211; <p>String.
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is &#8216;m&#8217; (all units taken and returned in meters).</p>
</li>
<li><strong>tspline</strong> &#8211; Boolean.
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</li>
<li><strong>monotonic</strong> &#8211; Boolean.
Sets whether or not the &#8220;monotonic&#8221; form of time window
finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getInfo">
<tt class="descname">getInfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>returns namedtuple of shot information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>shot</td>
<td>C-Mod shot index (long)</td>
</tr>
<tr class="row-even"><td>tree</td>
<td>EFIT tree (string)</td>
</tr>
<tr class="row-odd"><td>nr</td>
<td>size of R-axis for spatial grid</td>
</tr>
<tr class="row-even"><td>nz</td>
<td>size of Z-axis for spatial grid</td>
</tr>
<tr class="row-odd"><td>nt</td>
<td>size of timebase for flux grid</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getTimeBase">
<tt class="descname">getTimeBase</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT time base vector</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxGrid">
<tt class="descname">getFluxGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT flux grid, [t,z,r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRGrid">
<tt class="descname">getRGrid</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT R-axis [r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getZGrid">
<tt class="descname">getZGrid</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT Z-axis [z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxAxis">
<tt class="descname">getFluxAxis</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi on magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxLCFS">
<tt class="descname">getFluxLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi at separatrix [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxVol">
<tt class="descname">getFluxVol</tt><big>(</big><em>length_unit=3</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getVolLCFS">
<tt class="descname">getVolLCFS</tt><big>(</big><em>length_unit=3</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRmidPsi">
<tt class="descname">getRmidPsi</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRLCFS">
<tt class="descname">getRLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns R-values of LCFS position [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getZLCFS">
<tt class="descname">getZLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Z-values of LCFS position [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.remapLCFS">
<tt class="descname">remapLCFS</tt><big>(</big><em>mask=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites RLCFS, ZLCFS values pulled from EFIT with explicitly-calculated contour
of psinorm=1 surface.  This is then masked down by the limiter array using core.inPolygon,
restricting the contour to the closed plasma surface and the divertor legs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> &#8211; Boolean.
Default False.  Set True to mask LCFS path to limiter outline (using inPolygon).
Set False to draw full contour of psi = psiLCFS.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getF">
<tt class="descname">getF</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov solutions  [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFluxPres">
<tt class="descname">getFluxPres</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>returns pressure at flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFFPrime">
<tt class="descname">getFFPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF&#8217; function used for grad-shafranov solutions [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getPPrime">
<tt class="descname">getPPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getElongation">
<tt class="descname">getElongation</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS elongation [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getUpperTriangularity">
<tt class="descname">getUpperTriangularity</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS upper triangularity [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getLowerTriangularity">
<tt class="descname">getLowerTriangularity</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS lower triangularity [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getSlhaping">
<tt class="descname">getSlhaping</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getSlhaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getSlhaping" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls LCFS elongation and upper/lower triangularity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {kappa, delta_u, delta_l}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMagR">
<tt class="descname">getMagR</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMagZ">
<tt class="descname">getMagZ</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis Z [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getAreaLCFS">
<tt class="descname">getAreaLCFS</tt><big>(</big><em>length_unit=2</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns LCFS cross-sectional area [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getAOut">
<tt class="descname">getAOut</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius at LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getRmidOut">
<tt class="descname">getRmidOut</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getGeometry">
<tt class="descname">getGeometry</tt><big>(</big><em>length_unit=None</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls dimensional geometry parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {magnetic-axis R,Z, LCFS area, outboard-midplane LCFS a,R}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQProfile">
<tt class="descname">getQProfile</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>returns safety factor q [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ0">
<tt class="descname">getQ0</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ95">
<tt class="descname">getQ95</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q at 95% flux surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQLCFS">
<tt class="descname">getQLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns q on LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ1Surf">
<tt class="descname">getQ1Surf</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=1 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ2Surf">
<tt class="descname">getQ2Surf</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=2 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQ3Surf">
<tt class="descname">getQ3Surf</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane minor radius of q=3 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getQs">
<tt class="descname">getQs</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls q values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {q0,q95,qLCFS,rq1,rq2,rq3}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBtVac">
<tt class="descname">getBtVac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>returns on-axis vacuum toroidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBtPla">
<tt class="descname">getBtPla</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>returns on-axis plasma toroidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBpAvg">
<tt class="descname">getBpAvg</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>returns average poloidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getFields">
<tt class="descname">getFields</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls vacuum and plasma toroidal field, avg poloidal field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {btaxv,btaxp,bpolav}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getIpCalc">
<tt class="descname">getIpCalc</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getIpMeas">
<tt class="descname">getIpMeas</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetics-measured plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getJp">
<tt class="descname">getJp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current density Jp on flux grid [t,r,z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBetaT">
<tt class="descname">getBetaT</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated toroidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBetaP">
<tt class="descname">getBetaP</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated poloidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getLi">
<tt class="descname">getLi</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated internal inductance [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getBetas">
<tt class="descname">getBetas</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls calculated betap, betat, internal inductance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {betat,betap,Li}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagFlux">
<tt class="descname">getDiamagFlux</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>returns measured diamagnetic-loop flux [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagBetaT">
<tt class="descname">getDiamagBetaT</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop toroidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagBetaP">
<tt class="descname">getDiamagBetaP</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop avg poloidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagTauE">
<tt class="descname">getDiamagTauE</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop energy confinement time [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamagWp">
<tt class="descname">getDiamagWp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns diamagnetic-loop plasma stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getDiamag">
<tt class="descname">getDiamag</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls diamagnetic flux measurements, toroidal and poloidal beta, energy confinement time and stored energy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {diamag. flux, betatd, betapd, tauDiamag, WDiamag}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getWMHD">
<tt class="descname">getWMHD</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated MHD stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getTauMHD">
<tt class="descname">getTauMHD</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated MHD energy confinement time [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getPinj">
<tt class="descname">getPinj</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated injected power [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getWbdot">
<tt class="descname">getWbdot</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated d/dt of magnetic stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getWpdot">
<tt class="descname">getWpdot</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated d/dt of plasma stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getEnergy">
<tt class="descname">getEnergy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>pulls EFIT-calculated energy parameters - stored energy, tau_E, injected power, d/dt of magnetic and plasma stored energy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing {WMHD,tauMHD,Pinj,Wbdot,Wpdot}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMachineCrossSection">
<tt class="descname">getMachineCrossSection</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for masking, plotting routines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The requested data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getMachineCrossSectionFull">
<tt class="descname">getMachineCrossSectionFull</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for plotting routines.</p>
<p>Absent additional vector-graphic data on machine cross-section, returns
self.getMachineCrossSection().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The requested data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getCurrentSign">
<tt class="descname">getCurrentSign</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the current, based on the check in Steve Wolfe&#8217;s IDL implementation efit_rz2psi.pro.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.EFIT.EFITTree.getParam">
<tt class="descname">getParam</tt><big>(</big><em>path</em><big>)</big><a class="reference internal" href="_modules/eqtools/EFIT.html#EFITTree.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.EFIT.EFITTree.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>backup function - path to parameter as input, returns desired variable acts as wrapper for MDS call</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; str
The path to the MDSplus node you wish to pull in.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The requested data.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.FromArrays">
<span id="eqtools-fromarrays-module"></span><h2>eqtools.FromArrays module<a class="headerlink" href="#module-eqtools.FromArrays" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="eqtools.FromArrays.ArrayEquilibrium">
<em class="property">class </em><tt class="descclassname">eqtools.FromArrays.</tt><tt class="descname">ArrayEquilibrium</tt><big>(</big><em>psiRZ</em>, <em>rGrid</em>, <em>zGrid</em>, <em>time</em>, <em>q</em>, <em>fluxVol</em>, <em>psiLCFS</em>, <em>psiAxis</em>, <em>rmag</em>, <em>zmag</em>, <em>Rout</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.core.Equilibrium</span></tt></a></p>
<p>Class to represent an equilibrium specified as arrays of data.</p>
<p>Create ArrayEquilibrium instance from arrays of data.</p>
<p>Has very little checking on the shape/type of the arrays at this point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>psiRZ</strong> &#8211; Array-like, (M, N, P).
Flux values at M times, N Z locations and P R locations.</li>
<li><strong>rGrid</strong> &#8211; Array-like, (P,).
R coordinates that psiRZ is given at.</li>
<li><strong>zGrid</strong> &#8211; Array-like, (N,).
Z coordinates that psiRZ is given at.</li>
<li><strong>time</strong> &#8211; Array-like, (M,).
Times that psiRZ is given at.</li>
<li><strong>q</strong> &#8211; Array-like, (S, M).
q profile evaluated at S values of psinorm from 0 to 1, given at M
times.</li>
<li><strong>fluxVol</strong> &#8211; Array-like, (S, M).
Flux surface volumes evaluated at S values of psinorm from 0 to 1,
given at M times.</li>
<li><strong>psiLCFS</strong> &#8211; Array-like, (M,).
Flux at the last closed flux surface, given at M times.</li>
<li><strong>psiAxis</strong> &#8211; Array-like, (M,).
Flux at the magnetic axis, given at M times.</li>
<li><strong>rmag</strong> &#8211; Array-like, (M,).
Radial coordinate of the magnetic axis, given at M times.</li>
<li><strong>zmag</strong> &#8211; Array-like, (M,).
Vertical coordinate of the magnetic axis, given at M times.</li>
<li><strong>Rout</strong> &#8211; Outboard midplane radius of the last closed flux surface.</li>
<li><strong>length_unit</strong> &#8211; <p>String.
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is &#8216;m&#8217; (all units taken and returned in meters).</p>
</li>
<li><strong>tspline</strong> &#8211; Boolean.
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</li>
<li><strong>monotonic</strong> &#8211; Boolean.
Sets whether or not the &#8220;monotonic&#8221; form of time window
finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</li>
<li><strong>verbose</strong> &#8211; Boolean.
Allows or blocks console readout during operation.  Defaults to True,
displaying useful information for the user.  Set to False for quiet
usage or to avoid console clutter for multiple instances.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getTimeBase">
<tt class="descname">getTimeBase</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the time base vector, array dimensions are (M,).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxGrid">
<tt class="descname">getFluxGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the flux array, dimensions are (M, N, P), corresponding to (time, Z, R).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getRGrid">
<tt class="descname">getRGrid</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the radial grid, dimensions are (P,).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getZGrid">
<tt class="descname">getZGrid</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the vertical grid, dimensions are (N,).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getQProfile">
<tt class="descname">getQProfile</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q profile (over Q values of psinorm from 0 to 1), dimensions are (Q, M)</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxVol">
<tt class="descname">getFluxVol</tt><big>(</big><em>length_unit=3</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within flux surface [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxLCFS">
<tt class="descname">getFluxLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi at separatrix [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getFluxAxis">
<tt class="descname">getFluxAxis</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns psi on magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getMagR">
<tt class="descname">getMagR</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getMagZ">
<tt class="descname">getMagZ</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>returns magnetic-axis Z [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getRmidOut">
<tt class="descname">getRmidOut</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns outboard-midplane major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getRLCFS">
<tt class="descname">getRLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getZLCFS">
<tt class="descname">getZLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="eqtools.FromArrays.ArrayEquilibrium.getCurrentSign">
<tt class="descname">getCurrentSign</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/FromArrays.html#ArrayEquilibrium.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.FromArrays.ArrayEquilibrium.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.NSTXEFIT">
<span id="eqtools-nstxefit-module"></span><h2>eqtools.NSTXEFIT module<a class="headerlink" href="#module-eqtools.NSTXEFIT" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes for working with NSTX EFIT data.</p>
<dl class="class">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree">
<em class="property">class </em><tt class="descclassname">eqtools.NSTXEFIT.</tt><tt class="descname">NSTXEFITTree</tt><big>(</big><em>shot</em>, <em>tree='EFIT01'</em>, <em>length_unit='m'</em>, <em>gfile='geqdsk'</em>, <em>afile='aeqdsk'</em>, <em>tspline=False</em>, <em>monotonic=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.EFIT.EFITTree" title="eqtools.EFIT.EFITTree"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.EFIT.EFITTree</span></tt></a></p>
<p>Inherits <tt class="xref py py-class docutils literal"><span class="pre">EFITTree</span></tt> class. Machine-specific data
handling class for the National Spherical Torus Experiment (NSTX). Pulls EFIT
data from selected MDS tree and shot, stores as object attributes. Each EFIT
variable or set of variables is recovered with a corresponding getter method.
Essential data for EFIT mapping are pulled on initialization (e.g. psirz grid).
Additional data are pulled at the first request and stored for subsequent usage.</p>
<p>Intializes NSTX version of EFITTree object.  Pulls data from MDS tree for storage
in instance attributes.  Core attributes are populated from the MDS tree on initialization.
Additional attributes are initialized as None, filled on the first request to the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shot</strong> &#8211; (long) int
NSTX shot index (long)</li>
<li><strong>tree</strong> &#8211; str
Optional input for EFIT tree, defaults to &#8216;EFIT01&#8217;
(i.e., EFIT data are under EFIT01::top.results).</li>
<li><strong>length_unit</strong> &#8211; <p>str
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is &#8216;m&#8217; (all units taken and returned in meters).</p>
</li>
<li><strong>gfile</strong> &#8211; str
Optional input for EFIT geqdsk location name, defaults to &#8216;g_eqdsk&#8217;
(i.e., EFIT data are under tree::top.results.G_EQDSK)</li>
<li><strong>afile</strong> &#8211; str
Optional input for EFIT aeqdsk location name, defaults to &#8216;a_eqdsk&#8217;
(i.e., EFIT data are under tree::top.results.A_EQDSK)</li>
<li><strong>tspline</strong> &#8211; Boolean
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).</li>
<li><strong>monotonic</strong> &#8211; Boolean
Sets whether or not the &#8220;monotonic&#8221; form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getFluxGrid">
<tt class="descname">getFluxGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT flux grid, [t,z,r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getMachineCrossSection">
<tt class="descname">getMachineCrossSection</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R,Z coordinates of vacuum-vessel wall for masking, plotting routines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The requested data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getFluxVol">
<tt class="descname">getFluxVol</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented in NSTXEFIT tree.</p>
<p>Returns volume within flux surface [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getRmidPsi">
<tt class="descname">getRmidPsi</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum major radius of each flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getIpCalc">
<tt class="descname">getIpCalc</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns EFIT-calculated plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getVolLCFS">
<tt class="descname">getVolLCFS</tt><big>(</big><em>length_unit=3</em><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>returns volume within LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.getJp">
<tt class="descname">getJp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented in NSTXEFIT tree.</p>
<p>returns EFIT-calculated plasma current density Jp on flux grid [t,r,z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.rz2volnorm">
<tt class="descname">rz2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.rz2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.rz2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculated normalized volume of flux surfaces not stored in NSTX EFIT. All maping with Volnorm
not implemented</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.NSTXEFIT.NSTXEFITTree.psinorm2volnorm">
<tt class="descname">psinorm2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTree.psinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTree.psinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculated normalized volume of flux surfaces not stored in NSTX EFIT. All maping with Volnorm
not implemented</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.NSTXEFIT.NSTXEFITTreeProp">
<em class="property">class </em><tt class="descclassname">eqtools.NSTXEFIT.</tt><tt class="descname">NSTXEFITTreeProp</tt><big>(</big><em>shot</em>, <em>tree='EFIT01'</em>, <em>length_unit='m'</em>, <em>gfile='geqdsk'</em>, <em>afile='aeqdsk'</em>, <em>tspline=False</em>, <em>monotonic=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/NSTXEFIT.html#NSTXEFITTreeProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.NSTXEFIT.NSTXEFITTreeProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.NSTXEFIT.NSTXEFITTree" title="eqtools.NSTXEFIT.NSTXEFITTree"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.NSTXEFIT.NSTXEFITTree</span></tt></a>, <a class="reference internal" href="#eqtools.core.PropertyAccessMixin" title="eqtools.core.PropertyAccessMixin"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.core.PropertyAccessMixin</span></tt></a></p>
<p>NSTXEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.</p>
</dd></dl>

</div>
<div class="section" id="eqtools-tcvliuqe-module">
<h2>eqtools.TCVLIUQE module<a class="headerlink" href="#eqtools-tcvliuqe-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="eqtools-augdata-module">
<h2>eqtools.AUGDATA module<a class="headerlink" href="#eqtools-augdata-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-eqtools.afilereader">
<span id="eqtools-afilereader-module"></span><h2>eqtools.afilereader module<a class="headerlink" href="#module-eqtools.afilereader" title="Permalink to this headline">¶</a></h2>
<p>This module contains the AFileReader class, a lightweight data
handler for a-file (time-history) datasets.</p>
<dl class="docutils">
<dt>Classes:</dt>
<dd><dl class="first last docutils">
<dt>AFileReader: Data-storage class for a-file data.  Reads</dt>
<dd>data from ASCII a-file, storing as copy-safe object
attributes.</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="eqtools.afilereader.AFileReader">
<em class="property">class </em><tt class="descclassname">eqtools.afilereader.</tt><tt class="descname">AFileReader</tt><big>(</big><em>afile</em><big>)</big><a class="reference internal" href="_modules/eqtools/afilereader.html#AFileReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.afilereader.AFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to read ASCII a-file (time-history data storage) into lightweight, user-friendly data structure.</p>
<p>A-files store data blocks of scalar time-history data for EFIT plasma equilibrium.  Each parameter is
read into a pseudo-private object attribute (marked by a leading underscore), followed by the standard
EFIT variable names.</p>
<p>initialize object, reading from file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>afile</strong> &#8211; str
path to a-file</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-eqtools.core">
<span id="eqtools-core-module"></span><h2>eqtools.core module<a class="headerlink" href="#module-eqtools.core" title="Permalink to this headline">¶</a></h2>
<p>This module provides the core classes for <a class="reference internal" href="#module-eqtools" title="eqtools"><tt class="xref py py-mod docutils literal"><span class="pre">eqtools</span></tt></a>, including the
base <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> class.</p>
<dl class="exception">
<dt id="eqtools.core.ModuleWarning">
<em class="property">exception </em><tt class="descclassname">eqtools.core.</tt><tt class="descname">ModuleWarning</tt><a class="reference internal" href="_modules/eqtools/core.html#ModuleWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.ModuleWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Warning</span></tt></p>
<p>Warning class to notify the user of unavailable modules.</p>
<p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="class">
<dt id="eqtools.core.PropertyAccessMixin">
<em class="property">class </em><tt class="descclassname">eqtools.core.</tt><tt class="descname">PropertyAccessMixin</tt><a class="reference internal" href="_modules/eqtools/core.html#PropertyAccessMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.PropertyAccessMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Mixin to implement access of getter methods through a property-type
interface without the need to apply a decorator to every property.</p>
<p>For any getter <cite>obj.getSomething()</cite>, the call <cite>obj.Something</cite> will do the
same thing.</p>
<p>This is accomplished by overriding <tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt> such that if
an attribute <cite>ATTR</cite> does not exist it then attempts to call <cite>self.getATTR()</cite>.
If <cite>self.getATTR()</cite> does not exist, an <tt class="xref py py-class docutils literal"><span class="pre">AttributeError</span></tt> will be
raised as usual.</p>
<p>Also overrides <tt class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></tt> such that it will raise an
<tt class="xref py py-class docutils literal"><span class="pre">AttributeError</span></tt> when attempting to write an attribute <cite>ATTR</cite> for
which there is already a method <cite>getATTR</cite>.</p>
<p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="function">
<dt id="eqtools.core.inPolygon">
<tt class="descclassname">eqtools.core.</tt><tt class="descname">inPolygon</tt><big>(</big><em>polyx</em>, <em>polyy</em>, <em>pointx</em>, <em>pointy</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#inPolygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.inPolygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating whether a given point is within a 2D polygon.</p>
<p>Given an array of X,Y coordinates describing a 2D polygon, checks whether a
point given by x,y coordinates lies within the polygon. Operates via a
ray-casting approach - the function projects a semi-infinite ray parallel to
the positive horizontal axis, and counts how many edges of the polygon this
ray intersects. For a simply-connected polygon, this determines whether the
point is inside (even number of crossings) or outside (odd number of
crossings) the polygon, by the Jordan Curve Theorem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>polyx</strong> (<em>Array-like</em>) &#8211; Array of x-coordinates of the vertices of the polygon.</li>
<li><strong>polyy</strong> (<em>Array-like</em>) &#8211; Array of y-coordinates of the vertices of the polygon.</li>
<li><strong>pointx</strong> (<em>Int or float</em>) &#8211; x-coordinate of test point.</li>
<li><strong>pointy</strong> (<em>Int or float</em>) &#8211; y-coordinate of test point.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True/False result for whether the point is contained within the polygon.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">result (Boolean)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="eqtools.core.Equilibrium">
<em class="property">class </em><tt class="descclassname">eqtools.core.</tt><tt class="descname">Equilibrium</tt><big>(</big><em>length_unit='m'</em>, <em>tspline=False</em>, <em>monotonic=False</em>, <em>verbose=True</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract class of data handling object for magnetic reconstruction outputs.</p>
<p>Defines the mapping routines and method fingerprints necessary. Each
variable or set of variables is recovered with a corresponding getter method.
Essential data for mapping are pulled on initialization (psirz grid, for
example) to frontload overhead. Additional data are pulled at the first
request and stored for subsequent usage.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This abstract class should not be used directly. Device- and code-
specific subclasses are set up to account for inter-device/-code
differences in data storage.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>length_unit</strong> &#8211; <p>Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>whatever the default in the tree is (no conversion is performed, units may be inconsistent)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Default is &#8216;m&#8217; (all units taken and returned in meters).</p>
</li>
<li><strong>tspline</strong> &#8211; Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor interpolation.
Tricubic spline interpolation requires at least four complete
equilibria at different times. It is also assumed that they are
functionally correlated, and that parameters do not vary out of
their boundaries (derivative = 0 boundary condition). Default is
False (use nearest-neighbor interpolation).</li>
<li><strong>monotonic</strong> &#8211; Sets whether or not the &#8220;monotonic&#8221; form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).</li>
<li><strong>verbose</strong> &#8211; Allows or blocks console readout during operation.
Defaults to True, displaying useful information for the user. Set to
False for quiet usage or to avoid console clutter for multiple
instances.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype tspline:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype monotonic:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype verbose:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>length_unit</cite> is not a valid unit specifier.</li>
<li><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>tspline</cite> is True but module trispline did not load
successfully.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.core.Equilibrium.rho2rho">
<tt class="descname">rho2rho</tt><big>(</big><em>origin</em>, <em>destination</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rho2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rho2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from one coordinate to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>origin</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates the data are given in.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>RZ</td>
<td>R,Z coordinates</td>
</tr>
<tr class="row-even"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-odd"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-even"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-odd"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
<tr class="row-even"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>destination</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-odd"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-even"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
<tr class="row-odd"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>rho</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the starting coordinate
to map to the new coordinate. Will be two arguments <cite>R</cite>, <cite>Z</cite> if
<cite>origin</cite> is &#8216;RZ&#8217;.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>rho</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>rho</cite> (or the meshgrid of <cite>R</cite>
and <cite>Z</cite> if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of <cite>rho</cite>. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>rho</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>rho</cite> or be
a scalar. Default is True (evaluate ALL <cite>rho</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Only applicable if <cite>origin</cite> is &#8216;RZ&#8217;. Set to
True to pass <cite>R</cite> and <cite>Z</cite> through <tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt>
before evaluating. If this is set to True, <cite>R</cite> and <cite>Z</cite> must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid when <cite>destination</cite> is Rmid. Default is False
(return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that quantities are
given/returned in, as applicable. If a string is given, it must
be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>origin</cite> is not one of the supported values.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="s1">&#39;r/a&#39;</span><span class="p">,</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2psi">
<tt class="descname">rz2psi</tt><big>(</big><em>R</em>, <em>Z</em>, <em>t</em>, <em>return_t=False</em>, <em>make_grid=False</em>, <em>each_t=True</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2psi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the passed R, Z, t arrays to psi (unnormalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to poloidal flux. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to poloidal flux. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>psi</cite> or (<cite>psi</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>psi</strong> (<cite>Array or scalar float</cite>) - The unnormalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>psi</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>psi</cite> has
shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>psi</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psi value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully
specified, even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psi values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2psinorm">
<tt class="descname">rz2psinorm</tt><big>(</big><em>R</em>, <em>Z</em>, <em>t</em>, <em>return_t=False</em>, <em>sqrt=False</em>, <em>make_grid=False</em>, <em>each_t=True</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux at the given (R, Z, t).</p>
<p>Uses the definition:</p>
<div class="math">
<p><img src="_images/math/8cfc9918d98ef074d444e15f78cbe36644b86146.png" alt="\texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}"/></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to psinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to psinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The normalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>psinorm</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>psinorm</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the
appropriate extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2phinorm">
<tt class="descname">rz2phinorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux.</p>
<p>Uses the definitions:</p>
<div class="math">
<p><img src="_images/math/3f388581bfa0ab33aac72eef1e933e63537edd5d.png" alt="\texttt{phi} &amp;= \int q(\psi)\,d\psi

\texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}"/></p>
</div><p>This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to phinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to phinorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The normalized toroidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>phinorm</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>phinorm</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2volnorm">
<tt class="descname">rz2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume.</p>
<p>Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to volnorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to volnorm. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The normalized volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>volnorm</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>volnorm</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2rmid">
<tt class="descname">rz2rmid</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given points to the outboard midplane major radius, Rmid.</p>
<p>Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to Rmid. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to Rmid. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in,
AND that <cite>Rmid</cite> is returned in. If a string is given, it must
be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The outboard midplan major
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>Rmid</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>Rmid</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single Rmid value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find Rmid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2roa">
<tt class="descname">rz2roa</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given points to the normalized minor radius, r/a.</p>
<p>Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to r/a. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to r/a. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>roa</strong> (<cite>Array or scalar float</cite>) - The normalized minor radius.
If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If <cite>R</cite> and <cite>Z</cite>
both have the same shape then <cite>roa</cite> has this shape as well,
unless the <cite>make_grid</cite> keyword was True, in which case <cite>roa</cite>
has shape (len(<cite>Z</cite>), len(<cite>R</cite>)).</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single r/a value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2roa</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rz2rho">
<tt class="descname">rz2rho</tt><big>(</big><em>method</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rz2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rz2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R, Z, t) coordinates into one of several coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to. Valid
options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-odd"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-even"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
<tr class="row-odd"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>R</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the radial coordinate to
map to <cite>rho</cite>. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>Z</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>R</cite> must
have exactly one dimension.</li>
<li><strong>Z</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the vertical coordinate to
map to <cite>rho</cite>. If <cite>R</cite> and <cite>Z</cite> are both scalar values,
they are used as the coordinate pair for all of the values in
<cite>t</cite>. Must have the same shape as <cite>R</cite> unless the <cite>make_grid</cite>
keyword is set. If the <cite>make_grid</cite> keyword is True, <cite>Z</cite> must
have exactly one dimension.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R</cite>, <cite>Z</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be
scalar or have exactly one dimension. If the <cite>each_t</cite> keyword is
False, <cite>t</cite> must have the same shape as <cite>R</cite> and <cite>Z</cite> (or their
meshgrid if <cite>make_grid</cite> is True).</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of <cite>rho</cite>.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R</cite>, <cite>Z</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R</cite> and
<cite>Z</cite> or be a scalar. Default is True (evaluate ALL <cite>R</cite>, <cite>Z</cite> at
EACH element in <cite>t</cite>).</li>
<li><strong>make_grid</strong> &#8211; Set to True to pass <cite>R</cite> and <cite>Z</cite> through
<tt class="xref py py-func docutils literal"><span class="pre">scipy.meshgrid()</span></tt> before evaluating. If this is set to
True, <cite>R</cite> and <cite>Z</cite> must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid when <cite>destination</cite> is Rmid. Default is False
(return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R</cite>, <cite>Z</cite> are given in,
AND that <cite>Rmid</cite> is returned in. If a string is given, it must
be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype make_grid:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>method</cite> is not one of the supported values.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the <cite>Z</cite> vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions <cite>R</cite>
and 1D vector of vertical positions <cite>Z</cite> at time t=0.2s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2roa">
<tt class="descname">rmid2roa</tt><big>(</big><em>R_mid</em>, <em>t</em>, <em>each_t=True</em>, <em>return_t=False</em>, <em>sqrt=False</em>, <em>time_idxs=None</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R_mid, t) coordinates into r/a.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R_mid</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the outboard midplane
major radius to map to r/a.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>roa</strong> (<cite>Array or scalar float</cite>) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single r/a value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find roa values at R_mid points 0.6m and 0.8m at the
single time t=0.26s.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find roa values at R_mid of 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2psinorm">
<tt class="descname">rmid2psinorm</tt><big>(</big><em>R_mid</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux corresponding to the passed R_mid (mapped outboard midplane major radius) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R_mid</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the outboard midplane
major radius to map to psinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - Normalized poloidal flux.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value for Rmid=0.7m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid values of 0.5m and 0.7m at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid=0.5m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2phinorm">
<tt class="descname">rmid2phinorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux.</p>
<p>Uses the definitions:</p>
<div class="math">
<p><img src="_images/math/3f388581bfa0ab33aac72eef1e933e63537edd5d.png" alt="\texttt{phi} &amp;= \int q(\psi)\,d\psi

\texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}"/></p>
</div><p>This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R_mid</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the outboard midplane
major radius to map to phinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - Normalized toroidal flux.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single phinorm value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at R_mid points 0.6m and 0.8m at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at R_mid point 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (R, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2volnorm">
<tt class="descname">rmid2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume.</p>
<p>Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R_mid</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the outboard midplane
major radius to map to volnorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - Normalized volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single volnorm value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at R_mid points 0.6m and 0.8m at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at R_mid points 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vol_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.rmid2rho">
<tt class="descname">rmid2rho</tt><big>(</big><em>method</em>, <em>R_mid</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.rmid2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.rmid2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R_mid, t) coordinates into one of several coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to. Valid
options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-odd"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-even"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>R_mid</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the outboard midplane
major radius to map to rho.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>R_mid</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>R_mid</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of rho.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>R_mid</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>R_mid</cite>
or be a scalar. Default is True (evaluate ALL <cite>R_mid</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>R_mid</cite> is given in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at R_mid=0.6m, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid points 0.6m and 0.8m at the
single time t=0.26s.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at R_mid of 0.6m at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2rmid">
<tt class="descname">roa2rmid</tt><big>(</big><em>roa</em>, <em>t</em>, <em>each_t=True</em>, <em>return_t=False</em>, <em>time_idxs=None</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into Rmid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roa</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized minor
radius to map to Rmid.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single R_mid value at r/a=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find R_mid values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2psinorm">
<tt class="descname">roa2psinorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into psinorm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roa</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized minor
radius to map to psinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2phinorm">
<tt class="descname">roa2phinorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into phinorm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roa</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized minor
radius to map to phinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single phinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2volnorm">
<tt class="descname">roa2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into volnorm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roa</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized minor
radius to map to volnorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single volnorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.roa2rho">
<tt class="descname">roa2rho</tt><big>(</big><em>method</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.roa2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.roa2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (r/a, t) coordinates into one of several coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-odd"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-even"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>roa</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized minor
radius to map to rho.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>roa</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>roa</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of rho.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>roa</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>roa</cite>
or be a scalar. Default is True (evaluate ALL <cite>roa</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at r/a=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2rmid">
<tt class="descname">psinorm2rmid</tt><big>(</big><em>psi_norm</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outboard R_mid location corresponding to the passed psinorm (normalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>psi_norm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
poloidal flux to map to Rmid.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of Rmid. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single R_mid value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find R_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2roa">
<tt class="descname">psinorm2roa</tt><big>(</big><em>psi_norm</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized minor radius location corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>psi_norm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
poloidal flux to map to r/a.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of r/a. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>roa</strong> (<cite>Array or scalar float</cite>) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single r/a value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2volnorm">
<tt class="descname">psinorm2volnorm</tt><big>(</big><em>psi_norm</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized volume corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>psi_norm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
poloidal flux to map to volnorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of volnorm. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single volnorm value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2phinorm">
<tt class="descname">psinorm2phinorm</tt><big>(</big><em>psi_norm</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>psi_norm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
poloidal flux to map to phinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of phinorm. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single phinorm value for psinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psi_norm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.psinorm2rho">
<tt class="descname">psinorm2rho</tt><big>(</big><em>method</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.psinorm2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.psinorm2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (psinorm, t) coordinates into one of several coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-even"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-odd"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
<tr class="row-even"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>psi_norm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
poloidal flux to map to rho.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>psi_norm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>psi_norm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>psi_norm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>psi_norm</cite> or be
a scalar. Default is True (evaluate ALL <cite>psi_norm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>method</cite> is not one of the supported values.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single phinorm value at psinorm=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at phinorm of 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psinorm of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2psinorm">
<tt class="descname">phinorm2psinorm</tt><big>(</big><em>phinorm</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phinorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
toroidal flux to map to psinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2volnorm">
<tt class="descname">phinorm2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phinorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
toroidal flux to map to volnorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm and psinorm to volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>volnorm</cite> or (<cite>volnorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>volnorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>volnorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single volnorm value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find volnorm values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find volnorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volnorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2rmid">
<tt class="descname">phinorm2rmid</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mapped outboard midplane major radius corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phinorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
toroidal flux to map to Rmid.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm and psinorm to Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single Rmid value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find Rmid values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2roa">
<tt class="descname">phinorm2roa</tt><big>(</big><em>phi_norm</em>, <em>t</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized minor radius corresponding to the passed phinorm (normalized toroidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>phinorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
toroidal flux to map to r/a.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>phinorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm and psinorm to Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>roa</strong> (<cite>Array or scalar float</cite>) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single r/a value for phinorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at phinorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.phinorm2rho">
<tt class="descname">phinorm2rho</tt><big>(</big><em>method</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.phinorm2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.phinorm2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (phinorm, t) coordinates into one of several coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
<tr class="row-odd"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
<tr class="row-even"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>phinorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
toroidal flux to map to rho.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>phinorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>phinorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>phinorm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>phinorm</cite> or be
a scalar. Default is True (evaluate ALL <cite>phinorm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>method</cite> is not one of the supported values.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at phinorm=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm of 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at phinorm of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2psinorm">
<tt class="descname">volnorm2psinorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volnorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
flux surface volume to map to psinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>psinorm</cite> or (<cite>psinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>psinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>psinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2phinorm">
<tt class="descname">volnorm2phinorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volnorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
flux surface volume to map to phinorm.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm and psinorm to phinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>phinorm</cite> or (<cite>phinorm</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>phinorm</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>phinorm</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single phinorm value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2rmid">
<tt class="descname">volnorm2rmid</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mapped outboard midplane major radius corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volnorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
flux surface volume to map to Rmid.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm and psinorm to Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>Rmid</cite> or (<cite>Rmid</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>Rmid</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>Rmid</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single Rmid value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find Rmid values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find Rmid values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Rmid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2roa">
<tt class="descname">volnorm2roa</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2roa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2roa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized minor radius corresponding to the passed volnorm (normalized flux surface volume) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volnorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
flux surface volume to map to r/a.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe&#8217;s
IDL implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>volnorm</cite> are evaluated
at each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension
(or be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite>
or be a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH
element in <cite>t</cite>).</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm and psinorm to Rmid. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><cite>roa</cite> or (<cite>roa</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>roa</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>roa</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single r/a value for volnorm=0.7, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find r/a values at volnorm=0.5 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find r/a values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">roa_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.volnorm2rho">
<tt class="descname">volnorm2rho</tt><big>(</big><em>method</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.volnorm2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.volnorm2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (volnorm, t) coordinates into one of several coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>String</em>) &#8211; <p>Indicates which coordinates to convert to.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-odd"><td>Rmid</td>
<td>Midplane major radius</td>
</tr>
<tr class="row-even"><td>r/a</td>
<td>Normalized minor radius</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additionally, each valid option may be prepended with &#8216;sqrt&#8217;
to specify the square root of the desired unit.</p>
</li>
<li><strong>volnorm</strong> (<em>Array-like or scalar float</em>) &#8211; Values of the normalized
flux surface volume to map to rho.</li>
<li><strong>t</strong> (<em>Array-like or scalar float</em>) &#8211; Times to perform the conversion at.
If <cite>t</cite> is a single value, it is used for all of the elements of
<cite>volnorm</cite>. If the <cite>each_t</cite> keyword is True, then <cite>t</cite> must be scalar
or have exactly one dimension. If the <cite>each_t</cite> keyword is False,
<cite>t</cite> must have the same shape as <cite>volnorm</cite>.</li>
<li><strong>sqrt</strong> &#8211; Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe&#8217;s IDL
implementation efit_rz2rho.pro. Default is False.</li>
<li><strong>each_t</strong> &#8211; When True, the elements in <cite>volnorm</cite> are evaluated at
each value in <cite>t</cite>. If True, <cite>t</cite> must have only one dimension (or
be a scalar). If False, <cite>t</cite> must match the shape of <cite>volnorm</cite> or be
a scalar. Default is True (evaluate ALL <cite>volnorm</cite> at EACH element in
<cite>t</cite>).</li>
<li><strong>rho</strong> &#8211; Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).</li>
<li><strong>length_unit</strong> &#8211; <p>Length unit that <cite>Rmid</cite> is returned in.
If a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of
interpolation to be performed in getting from volnorm to
Rmid/phinorm/psinorm. This is passed to
<tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></tt>. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for <tt class="xref py py-class docutils literal"><span class="pre">interp1d</span></tt> for more
details. Default value is &#8216;cubic&#8217; (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try &#8216;linear&#8217; until you can rebuild your
scipy install.</li>
<li><strong>return_t</strong> &#8211; Set to True to return a tuple of (<cite>rho</cite>,
<cite>time_idxs</cite>), where <cite>time_idxs</cite> is the array of time indices
actually used in evaluating <cite>rho</cite> with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return <cite>rho</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype sqrt:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype each_t:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype rho:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Kwtype return_t:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><cite>rho</cite> or (<cite>rho</cite>, <cite>time_idxs</cite>)</p>
<ul class="simple">
<li><strong>rho</strong> (<cite>Array or scalar float</cite>) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.</li>
<li><strong>time_idxs</strong> (Array with same shape as <cite>rho</cite>) - The indices
(in <tt class="xref py py-meth docutils literal"><span class="pre">self.getTimeBase()</span></tt>) that were used for
nearest-neighbor interpolation. Only returned if <cite>return_t</cite> is
True.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If <cite>method</cite> is not one of the supported values.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that <cite>Eq_instance</cite> is a valid instance of the appropriate
extension of the <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">Equilibrium</span></tt></a> abstract class.</p>
<p>Find single psinorm value at volnorm=0.6, t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm of 0.6 and 0.8 at the
single time t=0.26s:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="mf">0.26</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at volnorm of 0.6 at times t=[0.2s, 0.3s]:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagRSpline">
<tt class="descname">getMagRSpline</tt><big>(</big><em>length_unit=1</em>, <em>kind='nearest'</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagRSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagRSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate R_mag as a function of time.</p>
<p>Only used if the instance was created with keyword tspline=True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>length_unit</strong> &#8211; <p>Length unit that R_mag is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div>&#8216;m&#8217;         meters
&#8216;cm&#8217;        centimeters
&#8216;mm&#8217;        millimeters
&#8216;in&#8217;        inches
&#8216;ft&#8217;        feet
&#8216;yd&#8217;        yards
&#8216;smoot&#8217;     smoots
&#8216;cubit&#8217;     cubits
&#8216;hand&#8217;      hands
&#8216;default&#8217;   meters</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_out returned in meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of interpolation
to be performed in getting from t to R_mag. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">scipy.interpolate.interp1d to convert from t to R_mid.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagZSpline">
<tt class="descname">getMagZSpline</tt><big>(</big><em>length_unit=1</em>, <em>kind='nearest'</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagZSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagZSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate Z_mag as a function of time.</p>
<p>Generated for completeness of the core position calculation when using
tspline = True</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>length_unit</strong> &#8211; <p>Length unit that R_mag is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div>&#8216;m&#8217;         meters
&#8216;cm&#8217;        centimeters
&#8216;mm&#8217;        millimeters
&#8216;in&#8217;        inches
&#8216;ft&#8217;        feet
&#8216;yd&#8217;        yards
&#8216;smoot&#8217;     smoots
&#8216;cubit&#8217;     cubits
&#8216;hand&#8217;      hands
&#8216;default&#8217;   meters</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_out returned in meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of interpolation
to be performed in getting from t to R_mag. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">scipy.interpolate.interp1d to convert from t to R_mid.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRmidOutSpline">
<tt class="descname">getRmidOutSpline</tt><big>(</big><em>length_unit=1</em>, <em>kind='nearest'</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRmidOutSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRmidOutSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate R_mid_out as a function of time.</p>
<p>Generated for completeness of the core position calculation when using
tspline = True</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>length_unit</strong> &#8211; <p>Length unit that R_mag is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div>&#8216;m&#8217;         meters
&#8216;cm&#8217;        centimeters
&#8216;mm&#8217;        millimeters
&#8216;in&#8217;        inches
&#8216;ft&#8217;        feet
&#8216;yd&#8217;        yards
&#8216;smoot&#8217;     smoots
&#8216;cubit&#8217;     cubits
&#8216;hand&#8217;      hands
&#8216;default&#8217;   meters</div></blockquote>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_out returned in meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of interpolation
to be performed in getting from t to R_mag. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">scipy.interpolate.interp1d to convert from t to R_mid.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getAOutSpline">
<tt class="descname">getAOutSpline</tt><big>(</big><em>length_unit=1</em>, <em>kind='nearest'</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getAOutSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getAOutSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the univariate spline to interpolate a_out as a function of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>length_unit</strong> &#8211; <p>Length unit that a_out is returned in. If
a string is given, it must be a valid unit specifier:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If <cite>length_unit</cite> is 1 or None, meters are assumed. The default
value is 1 (a_out returned in meters).</p>
</li>
<li><strong>kind</strong> &#8211; Specifies the type of interpolation
to be performed in getting from t to a_out. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Kwtype length_unit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">String or 1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">String or non-negative int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">scipy.interpolate.interp1d to convert from t to a_out.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getInfo">
<tt class="descname">getInfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns namedtuple of instance parameters (shot, equilibrium type, size, timebase, etc.)</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getTimeBase">
<tt class="descname">getTimeBase</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns timebase array [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxGrid">
<tt class="descname">getFluxGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<dl class="docutils">
<dt>returns 3D grid of psi(r,z,t)</dt>
<dd><dl class="first last docutils">
<dt>The array returned should have the following dimensions:</dt>
<dd>First dimension: time
Second dimension: Z
Third dimension: R</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRGrid">
<tt class="descname">getRGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns vector of R-values for psiRZ grid [r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getZGrid">
<tt class="descname">getZGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns vector of Z-values for psiRZ grid [z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxAxis">
<tt class="descname">getFluxAxis</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns psi at magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxLCFS">
<tt class="descname">getFluxLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns psi a separatrix [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRLCFS">
<tt class="descname">getRLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns R-positions (n points) mapping LCFS [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getZLCFS">
<tt class="descname">getZLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns Z-positions (n points) mapping LCFS [t,n]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.remapLCFS">
<tt class="descname">remapLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Overwrites stored R,Z positions of LCFS with explicitly calculated psinorm=1
surface.  This surface is then masked using core.inPolygon() to only draw within
vacuum vessel, the end result replacing RLCFS, ZLCFS with an R,Z array showing
the divertor legs of the flux surface in addition to the core-enclosing closed
flux surface.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxVol">
<tt class="descname">getFluxVol</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns volume contained within flux surface as function of psi [psi,t].
Psi assumed to be evenly-spaced grid on [0,1]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getVolLCFS">
<tt class="descname">getVolLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns plasma volume within LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRmidPsi">
<tt class="descname">getRmidPsi</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane major radius of flux surface [t,psi]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getF">
<tt class="descname">getF</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns F=RB_{Phi}(Psi), often calculated for grad-shafranov solutions  [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFluxPres">
<tt class="descname">getFluxPres</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated pressure profile [psi,t].
Psi assumed to be evenly-spaced grid on [0,1]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFFPrime">
<tt class="descname">getFFPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns FF&#8217; function used for grad-shafranov solutions [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getPPrime">
<tt class="descname">getPPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns plasma pressure gradient as a function of psi [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getElongation">
<tt class="descname">getElongation</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS elongation [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getUpperTriangularity">
<tt class="descname">getUpperTriangularity</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS upper triangularity [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getLowerTriangularity">
<tt class="descname">getLowerTriangularity</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS lower triangularity [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getShaping">
<tt class="descname">getShaping</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getShaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getShaping" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns dimensionless shaping parameters for plasma.
Namedtuple containing {LCFS elongation, LCFS upper/lower triangularity}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagR">
<tt class="descname">getMagR</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns magnetic-axis major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMagZ">
<tt class="descname">getMagZ</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns magnetic-axis Z [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getAreaLCFS">
<tt class="descname">getAreaLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns LCFS surface area [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getAOut">
<tt class="descname">getAOut</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getRmidOut">
<tt class="descname">getRmidOut</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane major radius [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getGeometry">
<tt class="descname">getGeometry</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns dimensional geometry parameters
Namedtuple containing {mag axis R,Z, LCFS area, volume, outboard-midplane major radius}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQProfile">
<tt class="descname">getQProfile</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns safety factor q profile [psi,t]
Psi assumed to be evenly-spaced grid on [0,1]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ0">
<tt class="descname">getQ0</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns q on magnetic axis [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ95">
<tt class="descname">getQ95</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns q on 95% flux surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQLCFS">
<tt class="descname">getQLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns q on LCFS [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ1Surf">
<tt class="descname">getQ1Surf</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius of q=1 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ2Surf">
<tt class="descname">getQ2Surf</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius of q=2 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQ3Surf">
<tt class="descname">getQ3Surf</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns outboard-midplane minor radius of q=3 surface [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getQs">
<tt class="descname">getQs</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns specific q-profile values.
Namedtuple containing {q0, q95, qLCFS, minor radius of q=1,2,3 surfaces}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBtVac">
<tt class="descname">getBtVac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns vacuum on-axis toroidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBtPla">
<tt class="descname">getBtPla</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns plasma on-axis toroidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBpAvg">
<tt class="descname">getBpAvg</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns average poloidal field [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getFields">
<tt class="descname">getFields</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns magnetic-field values.
Namedtuple containing {Btor on magnetic axis (plasma and vacuum), avg Bpol}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getIpCalc">
<tt class="descname">getIpCalc</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getIpMeas">
<tt class="descname">getIpMeas</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns measured plasma current [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getJp">
<tt class="descname">getJp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns grid of calculated toroidal current density [t,z,r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBetaT">
<tt class="descname">getBetaT</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated global toroidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBetaP">
<tt class="descname">getBetaP</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated global poloidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getLi">
<tt class="descname">getLi</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated internal inductance of plasma [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getBetas">
<tt class="descname">getBetas</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated betas and inductance.
Namedtuple of {betat,betap,Li}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagFlux">
<tt class="descname">getDiamagFlux</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic flux [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagBetaT">
<tt class="descname">getDiamagBetaT</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop toroidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagBetaP">
<tt class="descname">getDiamagBetaP</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop poloidal beta [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagTauE">
<tt class="descname">getDiamagTauE</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop energy confinement time [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamagWp">
<tt class="descname">getDiamagWp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic-loop plasma stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getDiamag">
<tt class="descname">getDiamag</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns diamagnetic measurements of plasma parameters.
Namedtuple of {diamag. flux, betat, betap from coils, tau_E from diamag., diamag. stored energy}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getWMHD">
<tt class="descname">getWMHD</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated MHD stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getTauMHD">
<tt class="descname">getTauMHD</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated MHD energy confinement time [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getPinj">
<tt class="descname">getPinj</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated injected power [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getCurrentSign">
<tt class="descname">getCurrentSign</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated current direction, where CCW = +</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getWbdot">
<tt class="descname">getWbdot</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated d/dt of magnetic stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getWpdot">
<tt class="descname">getWpdot</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns calculated d/dt of plasma stored energy [t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getEnergy">
<tt class="descname">getEnergy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns stored-energy parameters.
Namedtuple of {stored energy, confinement time, injected power, d/dt of magnetic, plasma stored energy}</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getParam">
<tt class="descname">getParam</tt><big>(</big><em>path</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Backup function: takes parameter name for variable, returns variable directly.
Acts as wrapper to direct data-access routines from within object.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMachineCrossSection">
<tt class="descname">getMachineCrossSection</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns (R,Z) coordinates of vacuum wall cross-section for plotting/masking routines.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.getMachineCrossSectionFull">
<tt class="descname">getMachineCrossSectionFull</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method.  See child classes for implementation.</p>
<p>Returns (R,Z) coordinates of machine wall cross-section for plotting routines.
Returns a more detailed cross-section than getLimiter(), generally a vector map
displaying non-critical cross-section information.  If this is unavailable, this
should point to self.getMachineCrossSection(), which pulls the limiter outline
stored by default in data files e.g. g-eqdsk files.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.gfile">
<tt class="descname">gfile</tt><big>(</big><em>time=None</em>, <em>nw=None</em>, <em>nh=None</em>, <em>shot=None</em>, <em>name=None</em>, <em>tunit='ms'</em>, <em>title='EQTOOLS'</em>, <em>nbbbs=100</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.gfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.gfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="eqtools.core.Equilibrium.plotFlux">
<tt class="descname">plotFlux</tt><big>(</big><em>fill=True</em>, <em>mask=True</em><big>)</big><a class="reference internal" href="_modules/eqtools/core.html#Equilibrium.plotFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.core.Equilibrium.plotFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots flux contours directly from psi grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fill</strong> &#8211; Set True to plot filled contours.  Set False (default) to plot white-background
color contours.</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype fill:</th><td class="field-body">Boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.eqdskreader">
<span id="eqtools-eqdskreader-module"></span><h2>eqtools.eqdskreader module<a class="headerlink" href="#module-eqtools.eqdskreader" title="Permalink to this headline">¶</a></h2>
<p>This module contains the EqdskReader class, which creates Equilibrium class
functionality for equilibria stored in eqdsk files from EFIT(a- and g-files).</p>
<dl class="docutils">
<dt>Classes:</dt>
<dd><dl class="first last docutils">
<dt>EqdskReader: class inheriting Equilibrium reading g- and a-files for</dt>
<dd>equilibrium data.</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="eqtools.eqdskreader.EqdskReader">
<em class="property">class </em><tt class="descclassname">eqtools.eqdskreader.</tt><tt class="descname">EqdskReader</tt><big>(</big><em>shot=None</em>, <em>time=None</em>, <em>gfile=None</em>, <em>afile=None</em>, <em>length_unit='m'</em>, <em>verbose=True</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#eqtools.core.Equilibrium" title="eqtools.core.Equilibrium"><tt class="xref py py-class docutils literal"><span class="pre">eqtools.core.Equilibrium</span></tt></a></p>
<p>Equilibrium subclass working from eqdsk ASCII-file equilibria.</p>
<p>Inherits mapping and structural data from Equilibrium, populates equilibrium
and profile data from g- and a-files for a selected shot and time window.</p>
<p>Create instance of EqdskReader.</p>
<p>Generates object and reads data from selected g-file (either manually set or
autodetected based on user shot and time selection), storing as object
attributes for usage in Equilibrium mapping methods.</p>
<p>Calling structure - user may call class with shot and time (ms) values, set by keywords
(or positional placement allows calling without explicit keyword syntax).  EqdskReader
then attempts to construct filenames from the shot/time, of the form &#8216;g[shot].[time]&#8217; and
&#8216;a[shot].[time]&#8217;.  Alternately, the user may skip this input and explicitly set paths to
the g- and/or a-files, using the gfile and afile keyword arguments.  If both types of calls
are set, the explicit g-file and a-file paths override the auto-generated filenames from
the shot and time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shot</strong> &#8211; Int.
Shot index.</li>
<li><strong>time</strong> &#8211; Int.
Time index (typically ms).  Shot and Time used to autogenerate filenames.</li>
<li><strong>gfile</strong> &#8211; String.
Manually selects ASCII file for equilibrium read.</li>
<li><strong>afile</strong> &#8211; String.
Manually selects ASCII file for time-history read.</li>
<li><strong>length_unit</strong> &#8211; String.
Flag setting length unit for equilibrium scales.
Defaults to &#8216;m&#8217; for lengths in meters.</li>
<li><strong>verbose</strong> &#8211; Boolean.
When set to False, suppresses terminal outputs during CSV read.
Defaults to True (prints terminal output).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt> &#8211; if both name/shot and explicit filenames are not set.</li>
<li><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if the g-file cannot be found, or if multiple valid g/a-files are found.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getInfo">
<tt class="descname">getInfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>returns namedtuple of equilibrium information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>shot</td>
<td>shot index</td>
</tr>
<tr class="row-even"><td>time</td>
<td>time point of g-file</td>
</tr>
<tr class="row-odd"><td>nr</td>
<td>size of R-axis of spatial grid</td>
</tr>
<tr class="row-even"><td>nz</td>
<td>size of Z-axis of spatial grid</td>
</tr>
<tr class="row-odd"><td>efittype</td>
<td>EFIT calculation type (magnetic, kinetic, MSE)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.readAFile">
<tt class="descname">readAFile</tt><big>(</big><em>afile</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.readAFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.readAFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a-file (scalar time-history data) to pull additional equilibrium data
not found in g-file, populates remaining data (initialized as None) in object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>afile</strong> &#8211; String.
Path to ASCII a-file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt> &#8211; If afile is not found.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2psi">
<tt class="descname">rz2psi</tt><big>(</big><em>R</em>, <em>Z</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2psi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts passed, R,Z arrays to psi values.</p>
<p>Wrapper for Equilibrium.rz2psi masking out timebase dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> &#8211; Array-like or scalar float.
Values of the radial coordinate to
map to poloidal flux. If the make_grid keyword is True, R must
have shape (len_R,).</li>
<li><strong>Z</strong> &#8211; Array-like or scalar float.
Values of the vertical coordinate to
map to poloidal flux. Must have the same shape as R unless the
make_grid keyword is set. If the make_grid keyword is True, Z
must have shape (len_Z,).</li>
<li><strong>*args</strong> &#8211; Slot for time input for consistent syntax with Equilibrium.rz2psi.
will return dummy value for time if input in EqdskReader.</li>
<li><strong>make_grid</strong> &#8211; Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).</p>
</li>
<li><strong>**kwargs</strong> &#8211; Other keywords (i.e., return_t) to rz2psi are valid
(necessary for proper inheritance and usage in other mapping routines)
but will return dummy values.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are scalar,</dt>
<dd><p class="first last">then a scalar is returned. Otherwise, a scipy Array instance is
returned. If R and Z both have the same shape then psi has this
shape as well. If the make_grid keyword was True then psi has
shape (len(Z), len(R)).</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">psi</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2psinorm">
<tt class="descname">rz2psinorm</tt><big>(</big><em>R</em>, <em>Z</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2psinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2psinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized poloidal flux at the given (R,Z).
Wrapper for Equilibrium.rz2psinorm masking out timebase dependence.</p>
<p>Uses the definition:
psi_norm = (psi - psi(0)) / (psi(a) - psi(0))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> &#8211; Array-like or scalar float.
Values of the radial coordinate to
map to normalized poloidal flux. If R and Z are both scalar
values, they are used as the coordinate pair for all of the
values in t. Must have the same shape as Z unless the make_grid
keyword is set. If the make_grid keyword is True, R must have
shape (len_R,).</li>
<li><strong>Z</strong> &#8211; Array-like or scalar float.
Values of the vertical coordinate to
map to normalized poloidal flux. If R and Z are both scalar
values, they are used as the coordinate pair for all of the
values in t. Must have the same shape as R unless the make_grid
keyword is set. If the make_grid keyword is True, Z must have
shape (len_Z,).</li>
<li><strong>*args</strong> &#8211; Slot for time input for consistent syntax with Equilibrium.rz2psinorm.
will return dummy value for time if input in EqdskReader.</li>
<li><strong>sqrt</strong> &#8211; Boolean.
Set to True to return the square root of normalized
flux. Only the square root of positive psi_norm values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe&#8217;s IDL implementation efit_rz2rho.pro. Default is False
(return psinorm).</li>
<li><strong>make_grid</strong> &#8211; Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</li>
<li><strong>length_unit</strong> &#8211; <p>String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).</p>
</li>
<li><strong>**kwargs</strong> &#8211; Other keywords passed to Equilibrium.rz2psinorm are valid,
but will return dummy values (i.e. for timebase keywords)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are</dt>
<dd><p class="first last">scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
psinorm has this shape as well. If the make_grid keyword was
True then psinorm has shape (len(Z), len(R)).</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">psinorm</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance EqdskReader:</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2phinorm">
<tt class="descname">rz2phinorm</tt><big>(</big><em>R</em>, <em>Z</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates normalized toroidal flux at a given (R,Z).</p>
<p>Wrapper for Equilibrium.rz2phinorm masking out timebase dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> &#8211; Array-like or scalar float.
Values of the radial coordinate to
map to normalized toroidal flux. Must have the same shape as Z
unless the make_grid keyword is set. If the make_grid keyword
is True, R must have shape (len_R,).</li>
<li><strong>Z</strong> &#8211; Array-like or scalar float.
Values of the vertical coordinate to
map to normalized toroidal flux. Must have the same shape as R
unless the make_grid keyword is set. If the make_grid keyword
is True, Z must have shape (len_Z,).</li>
<li><strong>*args</strong> &#8211; Slot for time input for consistent syntax with Equilibrium.rz2phinorm.
will return dummy value for time if input in EqdskReader.</li>
<li><strong>sqrt</strong> &#8211; Boolean.
Set to True to return the square root of normalized
flux. Only the square root of positive phi_norm values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe&#8217;s IDL implementation efit_rz2rho.pro. Default is False
(return phinorm).</li>
<li><strong>make_grid</strong> &#8211; Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</li>
<li><strong>kind</strong> &#8211; String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to phinorm. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
<li><strong>length_unit</strong> &#8211; <p>String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).</p>
</li>
<li><strong>**kwargs</strong> &#8211; Other keywords passed to Equilibrium.rz2phinorm are valid,
but will return dummy values (i.e. for timebase keywords)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are</dt>
<dd><p class="first last">scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
phinorm has this shape as well. If the make_grid keyword was
True then phinorm has shape (len(Z), len(R)).</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">phinorm</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of EqdskReader.</p>
<p>Find single phinorm value at R=0.6m, Z=0.0m:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find phinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2volnorm">
<tt class="descname">rz2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized flux surface volume.</p>
<p>Not implemented for EqdskReader, as necessary parameter
is not read from a/g-files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></tt> &#8211; in all cases.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2rho">
<tt class="descname">rz2rho</tt><big>(</big><em>method</em>, <em>R</em>, <em>Z</em>, <em>t=False</em>, <em>sqrt=False</em>, <em>make_grid=False</em>, <em>kind='cubic'</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the passed (R, Z) coordinates into one of several normalized coordinates.
Wrapper for Equilibrium.rz2rho masking timebase dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> &#8211; <p>String.
Indicates which normalized coordinates to use.
Valid options are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>psinorm</td>
<td>Normalized poloidal flux</td>
</tr>
<tr class="row-even"><td>phinorm</td>
<td>Normalized toroidal flux</td>
</tr>
<tr class="row-odd"><td>volnorm</td>
<td>Normalized volume</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><strong>R</strong> &#8211; Array-like or scalar float.
Values of the radial coordinate to
map to normalized coordinate. Must have the same shape as Z
unless the make_grid keyword is set. If the make_grid keyword
is True, R must have shape (len_R,).</li>
<li><strong>Z</strong> &#8211; Array-like or scalar float.
Values of the vertical coordinate to
map to normalized coordinate. Must have the same shape as R
unless the make_grid keyword is set. If the make_grid keyword
is True, Z must have shape (len_Z,).</li>
<li><strong>t</strong> &#8211; indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.</li>
<li><strong>sqrt</strong> &#8211; Boolean.
Set to True to return the square root of normalized
coordinate. Only the square root of positive values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe&#8217;s IDL implementation efit_rz2rho.pro. Default is False
(return normalized coordinate itself).</li>
<li><strong>make_grid</strong> &#8211; Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</li>
<li><strong>kind</strong> &#8211; String or non-negative int.
Specifies the type of interpolation to be performed in getting
from psinorm to phinorm or volnorm. This is passed to
scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
<li><strong>length_unit</strong> &#8211; <p>String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype kind:</th><td class="field-body"><p class="first">phinorm and volnorm only</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are</dt>
<dd><p class="first last">scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
rho has this shape as well. If the make_grid keyword was True
then rho has shape (len(Z), len(R)).</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">rho</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If method is not one of the supported values.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single psinorm value at R=0.6m, Z=0.0m:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find psinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.rz2rmid">
<tt class="descname">rz2rmid</tt><big>(</big><em>R</em>, <em>Z</em>, <em>t=False</em>, <em>sqrt=False</em>, <em>make_grid=False</em>, <em>rho=False</em>, <em>kind='cubic'</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.rz2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.rz2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given points to the outboard midplane major radius, R_mid.
Wrapper for Equilibrium.rz2rmid masking timebase dependence.</p>
<p>Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>R</strong> &#8211; Array-like or scalar float.
Values of the radial coordinate to
map to midplane radius. Must have the same shape as Z unless
the make_grid keyword is set. If the make_grid keyword is True,
R must have shape (len_R,).</li>
<li><strong>Z</strong> &#8211; Array-like or scalar float.
Values of the vertical coordinate to
map to midplane radius. Must have the same shape as R unless the
make_grid keyword is set. If the make_grid keyword is True, Z
must have shape (len_Z,).</li>
<li><strong>t</strong> &#8211; indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.</li>
<li><strong>sqrt</strong> &#8211; Boolean.
Set to True to return the square root of midplane
radius. Only the square root of positive values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe&#8217;s IDL implementation efit_rz2rho.pro. Default is False
(return R_mid itself).</li>
<li><strong>make_grid</strong> &#8211; Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).</li>
<li><strong>rho</strong> &#8211; Boolean.
Set to True to return r/a (normalized minor radius)
instead of R_mid. Default is False (return major radius, R_mid).</li>
<li><strong>kind</strong> &#8211; String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to R_mid. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
<li><strong>length_unit</strong> &#8211; <dl class="docutils">
<dt>String or 1.</dt>
<dd>Length unit that R and Z are being given
in AND that R_mid is returned in. If a string is given, it
must be a valid unit specifier:<table border="1" class="last docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
</dd>
<dt>If length_unit is 1 or None, meters are assumed. The default</dt>
<dd>value is 1 (R and Z given in meters, R_mid returned in meters).</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are</dt>
<dd><p class="first last">scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
R_mid has this shape as well. If the make_grid keyword was True
then R_mid has shape (len(Z), len(R)).</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">R_mid</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single R_mid value at R=0.6m, Z=0.0m:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Find R_mid values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_mat</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.psinorm2rmid">
<tt class="descname">psinorm2rmid</tt><big>(</big><em>psi_norm</em>, <em>t=False</em>, <em>rho=False</em>, <em>kind='cubic'</em>, <em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.psinorm2rmid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.psinorm2rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outboard R_mid location corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>psi_norm</strong> &#8211; Array-like or scalar float.
Values of the normalized
poloidal flux to map to midplane radius.</li>
<li><strong>t</strong> &#8211; indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.</li>
<li><strong>rho</strong> &#8211; Boolean.
Set to True to return r/a (normalized minor radius)
instead of R_mid. Default is False (return major radius, R_mid).</li>
<li><strong>kind</strong> &#8211; String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to R_mid. This is
passed to scipy.interpolate.interp1d. Valid options are:
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
<li><strong>length_unit</strong> &#8211; <p>String or 1.
Length unit that R_mid is returned in. If
a string is given, it must be a valid unit specifier:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#8216;m&#8217;</td>
<td>meters</td>
</tr>
<tr class="row-even"><td>&#8216;cm&#8217;</td>
<td>centimeters</td>
</tr>
<tr class="row-odd"><td>&#8216;mm&#8217;</td>
<td>millimeters</td>
</tr>
<tr class="row-even"><td>&#8216;in&#8217;</td>
<td>inches</td>
</tr>
<tr class="row-odd"><td>&#8216;ft&#8217;</td>
<td>feet</td>
</tr>
<tr class="row-even"><td>&#8216;yd&#8217;</td>
<td>yards</td>
</tr>
<tr class="row-odd"><td>&#8216;smoot&#8217;</td>
<td>smoots</td>
</tr>
<tr class="row-even"><td>&#8216;cubit&#8217;</td>
<td>cubits</td>
</tr>
<tr class="row-odd"><td>&#8216;hand&#8217;</td>
<td>hands</td>
</tr>
<tr class="row-even"><td>&#8216;default&#8217;</td>
<td>meters</td>
</tr>
</tbody>
</table>
<p>If length_unit is 1 or None, meters are assumed. The default
value is 1 (R_mid returned in meters).</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are</dt>
<dd><p class="first last">scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">R_mid</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single R_mid value for psinorm=0.7:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
<p>Find R_mid values at psi_norm values of 0.5 and 0.7.
Note that the Z vector must be fully specified, even if the
values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">R_mid_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.psinorm2volnorm">
<tt class="descname">psinorm2volnorm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.psinorm2volnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.psinorm2volnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outboard R_mid location corresponding to psi_norm (normalized poloidal flux) values.
Not implemented for EqdskReader, as necessary parameter
is not read from a/g-files.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.psinorm2phinorm">
<tt class="descname">psinorm2phinorm</tt><big>(</big><em>psi_norm</em>, <em>t=False</em>, <em>kind='cubic'</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.psinorm2phinorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.psinorm2phinorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>psi_norm</strong> &#8211; Array-like or scalar float.
Values of the normalized
poloidal flux to map to normalized toroidal flux.</li>
<li><strong>t</strong> &#8211; indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.</li>
<li><strong>kind</strong> &#8211; String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to phinorm. This is
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217;
passed to scipy.interpolate.interp1d. Valid options are:
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is &#8216;cubic&#8217; (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try &#8216;linear&#8217; until you can rebuild your scipy install.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Array or scalar float. If all of the input arguments are</dt>
<dd><p class="first last">scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">phinorm</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>All assume that Eq_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.</p>
<p>Find single phinorm value for psinorm=0.7:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_val</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
<p>Find phinorm values at psi_norm values of 0.5 and 0.7.
Note that the Z vector must be fully specified, even if the
values are all the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">phinorm_arr</span> <span class="o">=</span> <span class="n">Eq_instance</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getTimeBase">
<tt class="descname">getTimeBase</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getTimeBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getTimeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT time point</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getCurrentSign">
<tt class="descname">getCurrentSign</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getCurrentSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getCurrentSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the current, based on the check in Steve Wolfe&#8217;s IDL implementation efit_rz2psi.pro.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxGrid">
<tt class="descname">getFluxGrid</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT flux grid, [r,z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRGrid">
<tt class="descname">getRGrid</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT R-axis [r]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getZGrid">
<tt class="descname">getZGrid</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT Z-axis [z]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxAxis">
<tt class="descname">getFluxAxis</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxAxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns psi on magnetic axis</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxLCFS">
<tt class="descname">getFluxLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns psi at separatrix</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRLCFS">
<tt class="descname">getRLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns array of R-values of LCFS</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getZLCFS">
<tt class="descname">getZLCFS</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getZLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getZLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns array of Z-values of LCFS</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.remapLCFS">
<tt class="descname">remapLCFS</tt><big>(</big><em>mask=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.remapLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.remapLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites RLCFS, ZLCFS values pulled from EFIT with explicitly-calculated contour
of psinorm=1 surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> &#8211; Boolean.
Default False.  Set True to mask LCFS path to limiter outline (using inPolygon).
Set False to draw full contour of psi = psiLCFS.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxVol">
<tt class="descname">getFluxVol</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxVol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxVol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getVolLCFS">
<tt class="descname">getVolLCFS</tt><big>(</big><em>length_unit=3</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getVolLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getVolLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns volume with LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRmidPsi">
<tt class="descname">getRmidPsi</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRmidPsi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRmidPsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane major radius of flux surfaces.</p>
<p>Data not read from a/g-files, not implemented for EqdskReader.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></tt> &#8211; RmidPsi not read from a/g-files.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getF">
<tt class="descname">getF</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getF" title="Permalink to this definition">¶</a></dt>
<dd><p>returns F=RB_{Phi}(Psi), often calculated for grad-shafranov solutions  [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFluxPres">
<tt class="descname">getFluxPres</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFluxPres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFluxPres" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns pressure on flux surface p(psi)</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFFPrime">
<tt class="descname">getFFPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFFPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFFPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns FF&#8217; function used for grad-shafranov solutions [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getPPrime">
<tt class="descname">getPPrime</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getPPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getPPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>returns plasma pressure gradient as a function of psi [psi,t]</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getElongation">
<tt class="descname">getElongation</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getElongation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getElongation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns elongation of LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getUpperTriangularity">
<tt class="descname">getUpperTriangularity</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getUpperTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getUpperTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns upper triangularity of LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getLowerTriangularity">
<tt class="descname">getLowerTriangularity</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getLowerTriangularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getLowerTriangularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns lower triangularity of LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getShaping">
<tt class="descname">getShaping</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getShaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getShaping" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls LCFS elongation, upper/lower triangularity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [kappa,delta_u,delta_l].</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMagR">
<tt class="descname">getMagR</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMagR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMagR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns major radius of magnetic axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMagZ">
<tt class="descname">getMagZ</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMagZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMagZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Z of magnetic axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getAreaLCFS">
<tt class="descname">getAreaLCFS</tt><big>(</big><em>length_unit=2</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getAreaLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getAreaLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns surface area of LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getAOut">
<tt class="descname">getAOut</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getAOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getAOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getRmidOut">
<tt class="descname">getRmidOut</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getRmidOut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getRmidOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane major radius of LCFS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getGeometry">
<tt class="descname">getGeometry</tt><big>(</big><em>length_unit=None</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getGeometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls dimensional geometry parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [Rmag,Zmag,AreaLCFS,aOut,RmidOut]</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>length_unit</strong> &#8211; TODO</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQProfile">
<tt class="descname">getQProfile</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q(psi).</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ0">
<tt class="descname">getQ0</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ0" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q on-axis, q0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ95">
<tt class="descname">getQ95</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ95" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q at 95% flux surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQLCFS">
<tt class="descname">getQLCFS</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQLCFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQLCFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns safety factor q at LCFS (interpolated).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not loaded.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ1Surf">
<tt class="descname">getQ1Surf</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ1Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ1Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of q=1 surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ2Surf">
<tt class="descname">getQ2Surf</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ2Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ2Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of q=2 surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQ3Surf">
<tt class="descname">getQ3Surf</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQ3Surf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQ3Surf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns outboard-midplane minor radius of q=3 surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getQs">
<tt class="descname">getQs</tt><big>(</big><em>length_unit=1</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getQs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getQs" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls q-profile data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [q0,q95,qLCFS,rq1,rq2,rq3]</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBtVac">
<tt class="descname">getBtVac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBtVac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBtVac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vacuum toroidal field on-axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBtPla">
<tt class="descname">getBtPla</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBtPla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBtPla" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns plasma toroidal field on-axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBpAvg">
<tt class="descname">getBpAvg</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBpAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBpAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns average poloidal field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getFields">
<tt class="descname">getFields</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getFields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls vacuum and plasma toroidal field, poloidal field data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [BtVac,BtPla,BpAvg]</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getIpCalc">
<tt class="descname">getIpCalc</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getIpCalc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getIpCalc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated plasma current.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getIpMeas">
<tt class="descname">getIpMeas</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getIpMeas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getIpMeas" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns measured plasma current.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getJp">
<tt class="descname">getJp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getJp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getJp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (r,z) grid of toroidal plasma current density.</p>
<p>Data not read from g-file, not implemented for EqdskReader.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></tt> &#8211; Jp not read from g-file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBetaT">
<tt class="descname">getBetaT</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated toroidal beta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBetaP">
<tt class="descname">getBetaP</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated poloidal beta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getLi">
<tt class="descname">getLi</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getLi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getLi" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns internal inductance of plasma.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getBetas">
<tt class="descname">getBetas</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getBetas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getBetas" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls EFIT-calculated betas and internal inductance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [betat,betap,Li]</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagFlux">
<tt class="descname">getDiamagFlux</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic flux.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagBetaT">
<tt class="descname">getDiamagBetaT</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagBetaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagBetaT" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop measured toroidal beta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagBetaP">
<tt class="descname">getDiamagBetaP</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagBetaP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagBetaP" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop measured poloidal beta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagTauE">
<tt class="descname">getDiamagTauE</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagTauE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagTauE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop energy confinement time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamagWp">
<tt class="descname">getDiamagWp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamagWp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamagWp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diamagnetic-loop measured stored energy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getDiamag">
<tt class="descname">getDiamag</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getDiamag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getDiamag" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls diamagnetic flux, diamag. measured toroidal and poloidal beta, stored energy, and energy confinement time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [diaFlux,diaBetat,diaBetap,diaTauE,diaWp]</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getWMHD">
<tt class="descname">getWMHD</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getWMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getWMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated stored energy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getTauMHD">
<tt class="descname">getTauMHD</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getTauMHD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getTauMHD" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT-calculated energy confinement time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getPinj">
<tt class="descname">getPinj</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getPinj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getPinj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT injected power.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getWbdot">
<tt class="descname">getWbdot</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getWbdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getWbdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT d/dt of magnetic stored energy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getWpdot">
<tt class="descname">getWpdot</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getWpdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getWpdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns EFIT d/dt of plasma stored energy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getEnergy">
<tt class="descname">getEnergy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getEnergy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls EFIT stored energy, energy confinement time, injected power, and d/dt of magnetic and plasma stored energy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">namedtuple containing [WMHD,tauMHD,Pinj,Wbdot,Wpdot]</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; if a-file data is not read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getParam">
<tt class="descname">getParam</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getParam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Backup function, applying a direct path input for tree-like data storage access
for parameters not typically found in Equilbrium object.  Directly calls attributes
read from g/a-files in copy-safe manner.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; String.
Parameter name for value stored in EqdskReader instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt> &#8211; raised if no attribute is found.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMachineCrossSection">
<tt class="descname">getMachineCrossSection</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMachineCrossSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMachineCrossSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to pull machine cross-section from data storage, convert to standard format for plotting routine.</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.getMachineCrossSectionFull">
<tt class="descname">getMachineCrossSectionFull</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.getMachineCrossSectionFull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.getMachineCrossSectionFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vectorization of machine cross-section.</p>
<p>Absent additional data (not found in eqdsks) simply returns self.getMachineCrossSection().</p>
</dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.gfile">
<tt class="descname">gfile</tt><big>(</big><em>time=None</em>, <em>nw=None</em>, <em>nh=None</em>, <em>shot=None</em>, <em>name=None</em>, <em>tunit='ms'</em>, <em>title='EQTOOLS'</em>, <em>nbbbs=100</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.gfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.gfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="eqtools.eqdskreader.EqdskReader.plotFlux">
<tt class="descname">plotFlux</tt><big>(</big><em>fill=True</em>, <em>mask=True</em><big>)</big><a class="reference internal" href="_modules/eqtools/eqdskreader.html#EqdskReader.plotFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.eqdskreader.EqdskReader.plotFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>streamlined plotting of flux contours directly from psi grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fill</strong> &#8211; Boolean.
Default True.  Set True to plot filled contours of flux delineated by black outlines.
Set False to instead plot color-coded line contours on a blank background.</li>
<li><strong>mask</strong> &#8211; Boolean.
Default True.  Set True to draw a clipping mask based on the limiter outline for the flux contours.
Set False to draw the full RZ grid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools.filewriter">
<span id="eqtools-filewriter-module"></span><h2>eqtools.filewriter module<a class="headerlink" href="#module-eqtools.filewriter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="eqtools.filewriter.gfile">
<tt class="descclassname">eqtools.filewriter.</tt><tt class="descname">gfile</tt><big>(</big><em>obj</em>, <em>tin</em>, <em>nw=None</em>, <em>nh=None</em>, <em>shot=None</em>, <em>name=None</em>, <em>tunit='ms'</em>, <em>title='EQTOOLS'</em>, <em>nbbbs=100</em><big>)</big><a class="reference internal" href="_modules/eqtools/filewriter.html#gfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.filewriter.gfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="eqtools.filewriter.findLCFS">
<tt class="descclassname">eqtools.filewriter.</tt><tt class="descname">findLCFS</tt><big>(</big><em>rgrid</em>, <em>zgrid</em>, <em>psiRZ</em>, <em>rcent</em>, <em>zcent</em>, <em>psiLCFS</em>, <em>nbbbs=100</em><big>)</big><a class="headerlink" href="#eqtools.filewriter.findLCFS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-eqtools.pfilereader">
<span id="eqtools-pfilereader-module"></span><h2>eqtools.pfilereader module<a class="headerlink" href="#module-eqtools.pfilereader" title="Permalink to this headline">¶</a></h2>
<p>This module contains the PFileReader class, a lightweight data
handler for p-file (radial profile) datasets.</p>
<dl class="docutils">
<dt>Classes:</dt>
<dd><dl class="first last docutils">
<dt>PFileReader: Data-storage class for p-file data.  Reads</dt>
<dd>data from ASCII p-file, storing as copy-safe object
attributes.</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="eqtools.pfilereader.PFileReader">
<em class="property">class </em><tt class="descclassname">eqtools.pfilereader.</tt><tt class="descname">PFileReader</tt><big>(</big><em>pfile</em>, <em>verbose=True</em><big>)</big><a class="reference internal" href="_modules/eqtools/pfilereader.html#PFileReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.pfilereader.PFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to read ASCII p-file (profile data storage) into lightweight, user-friendly data structure.</p>
<p>P-files store data blocks containing the following: a header with parameter
name, parameter units, x-axis units, and number of data points, followed by values of
axis x, parameter y, and derivative dy/dx.  Each parameter block is read into a
namedtuple storing [&#8216;name&#8217;,&#8217;npts&#8217;,&#8217;units&#8217;,&#8217;xunits&#8217;,&#8217;x&#8217;,&#8217;y&#8217;,&#8217;dydx&#8217;], with each namedtuple
stored as an attribute of the PFileReader instance.  This gracefully handles variable
formats of p-files (differing versions of p-files will have different parameters stored).
Data blocks are accessed as attributes in a copy-safe manner.</p>
<p>Creates instance of PFileReader.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pfile</strong> &#8211; String.
Path to ASCII p-file to be loaded.</li>
<li><strong>verbose</strong> &#8211; Boolean.
Option to print message on object creation listing available data
parameters. Defaults to True.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-eqtools.trispline">
<span id="eqtools-trispline-module"></span><h2>eqtools.trispline module<a class="headerlink" href="#module-eqtools.trispline" title="Permalink to this headline">¶</a></h2>
<p>This module provides interface to the tricubic spline interpolator. It also
contains an enhanced bivariate spline which generates bounds errors.</p>
<dl class="class">
<dt id="eqtools.trispline.Spline">
<em class="property">class </em><tt class="descclassname">eqtools.trispline.</tt><tt class="descname">Spline</tt><big>(</big><em>z</em>, <em>y</em>, <em>x</em>, <em>f</em>, <em>regular=True</em>, <em>fast=False</em><big>)</big><a class="reference internal" href="_modules/eqtools/trispline.html#Spline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Tricubic interpolating spline with forced edge derivative equal zero
conditions.  It assumes a cartesian grid.</p>
<p>Create a new Spline instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>1-dimensional float array</em>) &#8211; Values of the positions of the 1st
Dimension of f. Must be monotonic without duplicates.</li>
<li><strong>y</strong> (<em>1-dimensional float array</em>) &#8211; Values of the positions of the 2nd
dimension of f. Must be monotonic without duplicates.</li>
<li><strong>x</strong> (<em>1-dimensional float array</em>) &#8211; Values of the positions of the 3rd
dimension of f. Must be monotonic without duplicates.</li>
<li><strong>f</strong> (<em>3-dimensional float array</em>) &#8211; f[z,y,x]. NaN and Inf will hamper
performance and affect interpolation in 4x4x4 space about its value.</li>
<li><strong>regular</strong> &#8211; If the grid is known to be regular, forces
matrix-based fast evaluation of interpolation.</li>
<li><strong>fast</strong> &#8211; Outdated input to test the indexing performance of the
c code vs internal python handling.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype regular:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype fast:</th><td class="field-body"><p class="first">Boolean</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If any of the dimensions do not match specified f dim</li>
<li><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If x,y, or z are not monotonic</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>temp</p>
<dl class="method">
<dt id="eqtools.trispline.Spline.ev">
<tt class="descname">ev</tt><big>(</big><em>z1</em>, <em>y1</em>, <em>x1</em><big>)</big><a class="reference internal" href="_modules/eqtools/trispline.html#Spline.ev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.Spline.ev" title="Permalink to this definition">¶</a></dt>
<dd><p>evaluates tricubic spline at point (x1,y1,z1) which is f[z1,y1,x1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z1</strong> (<em>scalar float or 1-dimensional float</em>) &#8211; Position in z dimension. (First dimension of 3d valued grid)</li>
<li><strong>y1</strong> (<em>scalar float or 1-dimensional float</em>) &#8211; Position in y dimension. (Second dimension of 3d valued grid)</li>
<li><strong>x1</strong> (<em>scalar float or 1-dimensional float</em>) &#8211; Position in x dimension. (Third dimension of 3d valued grid)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><cite>val</cite></p>
<ul class="simple">
<li><strong>val</strong> (<cite>array or scalar float</cite>) - The interpolated value at</li>
</ul>
<p>(x1,y1,z1).</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> &#8211; If any of the dimensions exceed the evaluation boundary
of the grid</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<dl class="docutils">
<dt>Data is grouped into the grid voxels so as to reuse calculated</dt>
<dd>spline coefficents, thus speeding evaluation.  It is
recommended that it is evaluated outside of for loops to best
utilize this feature.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eqtools.trispline.RectBivariateSpline">
<em class="property">class </em><tt class="descclassname">eqtools.trispline.</tt><tt class="descname">RectBivariateSpline</tt><big>(</big><em>x, y, z, bbox=[None, None, None, None], kx=3, ky=3, s=0, bounds_error=True, fill_value=nan</em><big>)</big><a class="reference internal" href="_modules/eqtools/trispline.html#RectBivariateSpline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.RectBivariateSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.fitpack2.RectBivariateSpline</span></tt></p>
<p>the lack of a graceful bounds error causes the fortran to fail hard.
This masks scipy.interpolate.RectBivariateSpline with a proper bound
checker and value filler such that it will not fail in use for EqTools</p>
<p>Can be used for both smoothing and interpolating data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>1-dimensional float array</em>) &#8211; 1-D array of coordinates in monotonically increasing order.</li>
<li><strong>y</strong> (<em>1-dimensional float array</em>) &#8211; 1-D array of coordinates in monotonically increasing order.</li>
<li><strong>z</strong> (<em>2-dimensional float array</em>) &#8211; 2-D array of data with shape (x.size,y.size).</li>
<li><strong>bbox</strong> &#8211; Sequence of length 4 specifying the
boundary of the rectangular approximation domain.  By default,
<tt class="docutils literal"><span class="pre">bbox=[min(x,tx),max(x,tx),</span> <span class="pre">min(y,ty),max(y,ty)]</span></tt>.</li>
<li><strong>kx</strong> &#8211; Degrees of the bivariate spline. Default is 3.</li>
<li><strong>ky</strong> &#8211; Degrees of the bivariate spline. Default is 3.</li>
<li><strong>s</strong> &#8211; Positive smoothing factor defined for estimation condition,
<tt class="docutils literal"><span class="pre">sum((w[i]*(z[i]-s(x[i],</span> <span class="pre">y[i])))**2,</span> <span class="pre">axis=0)</span> <span class="pre">&lt;=</span> <span class="pre">s</span></tt>
Default is <tt class="docutils literal"><span class="pre">s=0</span></tt>, which is for interpolation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype bbox:</th><td class="field-body"><p class="first">1-dimensional float</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype kx:</th><td class="field-body"><p class="first">integer</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwtype ky:</th><td class="field-body"><p class="first">integer</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Kwtype s:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="eqtools.trispline.RectBivariateSpline.ev">
<tt class="descname">ev</tt><big>(</big><em>xi</em>, <em>yi</em><big>)</big><a class="reference internal" href="_modules/eqtools/trispline.html#RectBivariateSpline.ev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#eqtools.trispline.RectBivariateSpline.ev" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Evaluate the rectBiVariateSpline at (xi,yi).  (x,y)values are</dt>
<dd>checked for being in the bounds of the interpolated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xi</strong> (<em>float array</em>) &#8211; input x dimensional values</li>
<li><strong>yi</strong> (<em>float array</em>) &#8211; input x dimensional values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>evaluated spline at points</dt>
<dd><p class="first last">(x[i], y[i]), i=0,...,len(x)-1</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">val (float array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-eqtools">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-eqtools" title="Permalink to this headline">¶</a></h2>
<p>Provides classes for interacting with magnetic equilibrium data in a variety of formats.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">eqtools package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-eqtools.CModEFIT">eqtools.CModEFIT module</a></li>
<li><a class="reference internal" href="#eqtools-d3defit-module">eqtools.D3DEFIT module</a></li>
<li><a class="reference internal" href="#module-eqtools.EFIT">eqtools.EFIT module</a></li>
<li><a class="reference internal" href="#module-eqtools.FromArrays">eqtools.FromArrays module</a></li>
<li><a class="reference internal" href="#module-eqtools.NSTXEFIT">eqtools.NSTXEFIT module</a></li>
<li><a class="reference internal" href="#eqtools-tcvliuqe-module">eqtools.TCVLIUQE module</a></li>
<li><a class="reference internal" href="#eqtools-augdata-module">eqtools.AUGDATA module</a></li>
<li><a class="reference internal" href="#module-eqtools.afilereader">eqtools.afilereader module</a></li>
<li><a class="reference internal" href="#module-eqtools.core">eqtools.core module</a></li>
<li><a class="reference internal" href="#module-eqtools.eqdskreader">eqtools.eqdskreader module</a></li>
<li><a class="reference internal" href="#module-eqtools.filewriter">eqtools.filewriter module</a></li>
<li><a class="reference internal" href="#module-eqtools.pfilereader">eqtools.pfilereader module</a></li>
<li><a class="reference internal" href="#module-eqtools.trispline">eqtools.trispline module</a></li>
<li><a class="reference internal" href="#module-eqtools">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">eqtools: Tools for interacting with magnetic equilibria</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/eqtools.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="eqtools: Tools for interacting with magnetic equilibria"
             >previous</a> |</li>
        <li><a href="index.html">eqtools 1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Chilenski, Ian Faust and John Walk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>