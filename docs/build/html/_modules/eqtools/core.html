<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>eqtools.core &mdash; eqtools 1.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="eqtools 1.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">eqtools 1.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for eqtools.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># This program is distributed under the terms of the GNU General Purpose License (GPL).</span>
<span class="c1"># Refer to http://www.gnu.org/licenses/gpl.txt</span>
<span class="c1">#</span>
<span class="c1"># This file is part of eqtools.</span>
<span class="c1">#</span>
<span class="c1"># eqtools is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># eqtools is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with eqtools.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;This module provides the core classes for :py:mod:`eqtools`, including the</span>
<span class="sd">base :py:class:`Equilibrium` class.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<div class="viewcode-block" id="ModuleWarning"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.ModuleWarning">[docs]</a><span class="k">class</span> <span class="nc">ModuleWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning class to notify the user of unavailable modules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">trispline</span>
    <span class="n">_has_trispline</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;trispline module could not be loaded -- tricubic spline &quot;</span>
                  <span class="s2">&quot;interpolation will not be available.&quot;</span><span class="p">,</span>
                  <span class="n">ModuleWarning</span><span class="p">)</span>
    <span class="n">_has_trispline</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">matplotlib.widgets</span> <span class="kn">as</span> <span class="nn">mplw</span>
    <span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="kn">as</span> <span class="nn">mplgs</span>
    <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">mpatches</span>
    <span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="kn">as</span> <span class="nn">mpath</span>
    <span class="kn">import</span> <span class="nn">filewriter</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;matplotlib modules could not be loaded -- plotting and gfile&quot;</span>
                  <span class="s2">&quot; writing will not be available.&quot;</span><span class="p">,</span>
                  <span class="n">ModuleWarning</span><span class="p">)</span>


<div class="viewcode-block" id="PropertyAccessMixin"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin">[docs]</a><span class="k">class</span> <span class="nc">PropertyAccessMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin to implement access of getter methods through a property-type</span>
<span class="sd">    interface without the need to apply a decorator to every property.</span>
<span class="sd">    </span>
<span class="sd">    For any getter `obj.getSomething()`, the call `obj.Something` will do the</span>
<span class="sd">    same thing.</span>
<span class="sd">    </span>
<span class="sd">    This is accomplished by overriding :py:meth:`__getattribute__` such that if</span>
<span class="sd">    an attribute `ATTR` does not exist it then attempts to call `self.getATTR()`.</span>
<span class="sd">    If `self.getATTR()` does not exist, an :py:class:`AttributeError` will be</span>
<span class="sd">    raised as usual.</span>
<span class="sd">    </span>
<span class="sd">    Also overrides :py:meth:`__setattr__` such that it will raise an</span>
<span class="sd">    :py:class:`AttributeError` when attempting to write an attribute `ATTR` for</span>
<span class="sd">    which there is already a method `getATTR`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PropertyAccessMixin.__getattribute__"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin.__getattribute__">[docs]</a>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an attribute.</span>
<span class="sd">        </span>
<span class="sd">        Tries to get attribute as-written. If this fails, tries to call the</span>
<span class="sd">        method `get&lt;name&gt;` with no arguments. If this fails, raises</span>
<span class="sd">        :py:class:`AttributeError`. This effectively generates a Python</span>
<span class="sd">        &#39;property&#39; for each getter method.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            name (String): Name of the attribute to retrieve. If the instance</span>
<span class="sd">                has an attribute with this name, the attribute is returned. If</span>
<span class="sd">                the instance does not have an attribute with this name but does</span>
<span class="sd">                have a method called &#39;get&#39;+name, this method is called and the</span>
<span class="sd">                result is returned.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            The value of the attribute requested.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If neither attribute name or method &#39;get&#39;+name exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">)()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%(class)s</span><span class="s2"> object has no attribute &#39;</span><span class="si">%(n)s</span><span class="s2">&#39; or method &#39;get</span><span class="si">%(n)s</span><span class="s2">&#39;&quot;</span>
                    <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>
                <span class="p">)</span>
</div>
<div class="viewcode-block" id="PropertyAccessMixin.__setattr__"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin.__setattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an attribute.</span>
<span class="sd">        </span>
<span class="sd">        Raises :py:class:`AttributeError` if the object already has a method</span>
<span class="sd">        &#39;get&#39;+name, as creation of such an attribute would interfere with the</span>
<span class="sd">        automatic property generation in :py:meth:`__getattribute__`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            name (String): Name of the attribute to set.</span>
<span class="sd">            value (Object): Value to set the attribute to.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If a method called &#39;get&#39;+name already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%(class)s</span><span class="s2"> object already has getter method &#39;get</span><span class="si">%(n)s</span><span class="s2">&#39;, creating &quot;</span>
                <span class="s2">&quot;attribute &#39;</span><span class="si">%(n)s</span><span class="s2">&#39; will conflict with automatic property &quot;</span>
                <span class="s2">&quot;generation.&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div></div>
<span class="sd">&quot;&quot;&quot;The following is a dictionary to implement length unit conversions. The first</span>
<span class="sd">key is the unit are converting FROM, the second the unit you are converting TO.</span>
<span class="sd">Supports: m, cm, mm, in, ft, yd, smoot, cubit, hand</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">_length_conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
                            <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">,</span>
                            <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span><span class="p">,</span>
                            <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                            <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                            <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                            <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                            <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">),</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">67.0</span><span class="p">),</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">18.0</span><span class="p">),</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)},</span>
                      <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">),</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">67.0</span><span class="p">),</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">18.0</span><span class="p">),</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)},</span>
                      <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">67.0</span><span class="p">,</span>
                                <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                                <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                                <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                                <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">18.0</span><span class="p">,</span>
                                <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                                <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                                <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                                <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
                               <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                               <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                               <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                               <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                               <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}}</span>


<div class="viewcode-block" id="inPolygon"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.inPolygon">[docs]</a><span class="k">def</span> <span class="nf">inPolygon</span><span class="p">(</span><span class="n">polyx</span><span class="p">,</span> <span class="n">polyy</span><span class="p">,</span> <span class="n">pointx</span><span class="p">,</span> <span class="n">pointy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function calculating whether a given point is within a 2D polygon.</span>

<span class="sd">    Given an array of X,Y coordinates describing a 2D polygon, checks whether a</span>
<span class="sd">    point given by x,y coordinates lies within the polygon. Operates via a</span>
<span class="sd">    ray-casting approach - the function projects a semi-infinite ray parallel to</span>
<span class="sd">    the positive horizontal axis, and counts how many edges of the polygon this</span>
<span class="sd">    ray intersects. For a simply-connected polygon, this determines whether the</span>
<span class="sd">    point is inside (even number of crossings) or outside (odd number of</span>
<span class="sd">    crossings) the polygon, by the Jordan Curve Theorem.</span>

<span class="sd">    Args:</span>
<span class="sd">        polyx (Array-like): Array of x-coordinates of the vertices of the polygon.</span>
<span class="sd">        polyy (Array-like): Array of y-coordinates of the vertices of the polygon.</span>
<span class="sd">        pointx (Int or float): x-coordinate of test point.</span>
<span class="sd">        pointy (Int or float): y-coordinate of test point.</span>

<span class="sd">    Returns:</span>
<span class="sd">        result (Boolean): True/False result for whether the point is contained within the polygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#generator function for &quot;lines&quot; - pairs of (x,y) coords describing each edge of the polygon.</span>
    <span class="k">def</span> <span class="nf">lines</span><span class="p">():</span>
        <span class="n">p0x</span> <span class="o">=</span> <span class="n">polyx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p0y</span> <span class="o">=</span> <span class="n">polyy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">(</span><span class="n">p0x</span><span class="p">,</span><span class="n">p0y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polyx</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">polyy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">p0</span><span class="p">,</span><span class="n">p1</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>

    <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">p0</span><span class="p">,</span><span class="n">p1</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pointy</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pointy</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pointx</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">pointy</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="Equilibrium"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium">[docs]</a><span class="k">class</span> <span class="nc">Equilibrium</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class of data handling object for magnetic reconstruction outputs.</span>
<span class="sd">    </span>
<span class="sd">    Defines the mapping routines and method fingerprints necessary. Each</span>
<span class="sd">    variable or set of variables is recovered with a corresponding getter method.</span>
<span class="sd">    Essential data for mapping are pulled on initialization (psirz grid, for</span>
<span class="sd">    example) to frontload overhead. Additional data are pulled at the first</span>
<span class="sd">    request and stored for subsequent usage.</span>

<span class="sd">    .. note:: This abstract class should not be used directly. Device- and code-</span>
<span class="sd">        specific subclasses are set up to account for inter-device/-code</span>
<span class="sd">        differences in data storage.</span>
<span class="sd">    </span>
<span class="sd">    Keyword Args:</span>
<span class="sd">        length_unit (String): Sets the base unit used for any quantity whose</span>
<span class="sd">            dimensions are length to any power. Valid options are:</span>
<span class="sd">            </span>
<span class="sd">                ===========  ===========================================================================================</span>
<span class="sd">                &#39;m&#39;          meters</span>
<span class="sd">                &#39;cm&#39;         centimeters</span>
<span class="sd">                &#39;mm&#39;         millimeters</span>
<span class="sd">                &#39;in&#39;         inches</span>
<span class="sd">                &#39;ft&#39;         feet</span>
<span class="sd">                &#39;yd&#39;         yards</span>
<span class="sd">                &#39;smoot&#39;      smoots</span>
<span class="sd">                &#39;cubit&#39;      cubits</span>
<span class="sd">                &#39;hand&#39;       hands</span>
<span class="sd">                &#39;default&#39;    whatever the default in the tree is (no conversion is performed, units may be inconsistent)</span>
<span class="sd">                ===========  ===========================================================================================</span>
<span class="sd">            </span>
<span class="sd">            Default is &#39;m&#39; (all units taken and returned in meters).</span>
<span class="sd">        tspline (Boolean): Sets whether or not interpolation in time is</span>
<span class="sd">            performed using a tricubic spline or nearest-neighbor interpolation.</span>
<span class="sd">            Tricubic spline interpolation requires at least four complete</span>
<span class="sd">            equilibria at different times. It is also assumed that they are</span>
<span class="sd">            functionally correlated, and that parameters do not vary out of</span>
<span class="sd">            their boundaries (derivative = 0 boundary condition). Default is</span>
<span class="sd">            False (use nearest-neighbor interpolation).</span>
<span class="sd">        monotonic (Boolean): Sets whether or not the &quot;monotonic&quot; form of time</span>
<span class="sd">            window finding is used. If True, the timebase must be monotonically</span>
<span class="sd">            increasing. Default is False (use slower, safer method).</span>
<span class="sd">        verbose (Boolean): Allows or blocks console readout during operation.</span>
<span class="sd">            Defaults to True, displaying useful information for the user. Set to</span>
<span class="sd">            False for quiet usage or to avoid console clutter for multiple</span>
<span class="sd">            instances.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `length_unit` is not a valid unit specifier.</span>
<span class="sd">        ValueError: If `tspline` is True but module trispline did not load</span>
<span class="sd">            successfully.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">tspline</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">monotonic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">length_unit</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">length_unit</span> <span class="ow">in</span> <span class="n">_length_conversion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit &#39;</span><span class="si">%s</span><span class="s2">&#39; not a valid unit specifier!&quot;</span> <span class="o">%</span> <span class="n">length_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">=</span> <span class="n">length_unit</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tspline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_monotonic</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">monotonic</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
            
        <span class="c1"># These are indexes of splines, and become higher dimensional splines</span>
        <span class="c1"># with the setting of the tspline keyword.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
    
<div class="viewcode-block" id="Equilibrium.__str__"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of this instance.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            string (String): String describing this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;This is an abstract class. Please use machine-specific subclass.&#39;</span>
    
    <span class="c1">####################</span>
    <span class="c1"># Mapping routines #</span>
    <span class="c1">####################</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rho2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rho2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert from one coordinate to another.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            origin (String): Indicates which coordinates the data are given in.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    RZ      R,Z coordinates</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            destination (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            rho (Array-like or scalar float): Values of the starting coordinate</span>
<span class="sd">                to map to the new coordinate. Will be two arguments `R`, `Z` if</span>
<span class="sd">                `origin` is &#39;RZ&#39;.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `rho`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `rho` (or the meshgrid of `R`</span>
<span class="sd">                and `Z` if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of `rho`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `rho` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `rho` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `rho` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            make_grid (Boolean): Only applicable if `origin` is &#39;RZ&#39;. Set to</span>
<span class="sd">                True to pass `R` and `Z` through :py:func:`scipy.meshgrid`</span>
<span class="sd">                before evaluating. If this is set to True, `R` and `Z` must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                Default is False (do not form meshgrid).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid when `destination` is Rmid. Default is False</span>
<span class="sd">                (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that quantities are</span>
<span class="sd">                given/returned in, as applicable. If a string is given, it must</span>
<span class="sd">                be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid/phinorm/volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `origin` is not one of the supported values.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>
<span class="sd">            </span>
<span class="sd">            Find single psinorm value at r/a=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, 0.6, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find psinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>
<span class="sd">            </span>
<span class="sd">            Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">destination</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">destination</span> <span class="o">=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;RZ&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho2rho: Unsupported origin coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">origin</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rz2psi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2psi">[docs]</a>    <span class="k">def</span> <span class="nf">rz2psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the passed R, Z, t arrays to psi (unnormalized poloidal flux) values.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to poloidal flux. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to poloidal flux. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `psi` or (`psi`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **psi** (`Array or scalar float`) - The unnormalized poloidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `psi` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `psi` has</span>
<span class="sd">              shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psi`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psi value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.rz2psi(0.6, 0, 0.26)</span>

<span class="sd">            Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2psi([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find psi values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2psi(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2psi([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find psi values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                psi_mat = Eq_instance.rz2psi(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check inputs and process into flat arrays with units of meters:</span>
        <span class="p">(</span><span class="n">R</span><span class="p">,</span>
         <span class="n">Z</span><span class="p">,</span>
         <span class="n">t</span><span class="p">,</span>
         <span class="n">time_idxs</span><span class="p">,</span>
         <span class="n">original_shape</span><span class="p">,</span>
         <span class="n">single_val</span><span class="p">,</span>
         <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                         <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span>
                                         <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
                                         <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
 
        <span class="c1"># Optimized form for single t value case:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="c1"># Need to loop over time_idxs</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxTriSpline</span><span class="p">()</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>

        <span class="c1"># Correct for current sign:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">out_vals</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span>

        <span class="c1"># Restore correct shape:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

        <span class="c1"># Unwrap back into single value to match input form, if necessary:</span>
        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out_vals</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="c1"># will reshape time_idxs only if it is utilized (otherwise set to None)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#there is no easy way around this, this is a product of the time_idxs reliance</span>
                <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">each_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculates the normalized poloidal flux at the given (R, Z, t).</span>
<span class="sd">        </span>
<span class="sd">        Uses the definition:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to psinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to psinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **psinorm** (`Array or scalar float`) - The normalized poloidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `psinorm` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `psinorm`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">       </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.rz2psinorm(0.6, 0, 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2psinorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psinorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2psinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find psinorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                psi_mat = Eq_instance.rz2psinorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">psi</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                     <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span>
                                     <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
                                     <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
       
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">psi_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()[</span><span class="n">time_idxs</span><span class="p">]</span>
            <span class="n">psi_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()[</span><span class="n">time_idxs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use 1d spline to generate the psi at the core and at boundary.</span>
            <span class="c1">#psi = psi.squeeze(psi)</span>
            <span class="n">psi_boundary</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getLCFSPsiSpline</span><span class="p">()(</span><span class="n">time_idxs</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">psi_0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPsi0Spline</span><span class="p">()(</span><span class="n">time_idxs</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">psi_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi</span> <span class="o">-</span> <span class="n">psi_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psi_boundary</span> <span class="o">-</span> <span class="n">psi_0</span><span class="p">)</span>
       
        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">psi_norm</span>
        
        <span class="c1"># Unwrap single values to ensure least surprise:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculates the normalized toroidal flux.</span>
<span class="sd">        </span>
<span class="sd">        Uses the definitions:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \texttt{phi} &amp;= \int q(\psi)\,d\psi</span>
<span class="sd">            </span>
<span class="sd">            \texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}</span>
<span class="sd">            </span>
<span class="sd">        This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to phinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to phinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **phinorm** (`Array or scalar float`) - The normalized toroidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `phinorm` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `phinorm`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phi_val = Eq_instance.rz2phinorm(0.6, 0, 0.26)</span>
<span class="sd">        </span>
<span class="sd">            Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.rz2phinorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find phinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.rz2phinorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.rz2phinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find phinorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                phi_mat = Eq_instance.rz2phinorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume.</span>
<span class="sd">        </span>
<span class="sd">        Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to volnorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to volnorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **volnorm** (`Array or scalar float`) - The normalized volume.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `volnorm` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `volnorm`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.rz2volnorm(0.6, 0, 0.26)</span>

<span class="sd">            Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                vol_arr = Eq_instance.rz2volnorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find volnorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                vol_arr = Eq_instance.rz2volnorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                vol_arr = Eq_instance.rz2volnorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find volnorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                vol_mat = Eq_instance.rz2volnorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">rz2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps the given points to the outboard midplane major radius, Rmid.</span>
<span class="sd">        </span>
<span class="sd">        Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to Rmid. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to Rmid. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in,</span>
<span class="sd">                AND that `Rmid` is returned in. If a string is given, it must</span>
<span class="sd">                be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **Rmid** (`Array or scalar float`) - The outboard midplan major</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `Rmid` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `Rmid`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single Rmid value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_val = Eq_instance.rz2rmid(0.6, 0, 0.26)</span>

<span class="sd">            Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.rz2rmid([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find Rmid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.rz2rmid(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find Rmid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.rz2rmid([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find Rmid values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_mat = Eq_instance.rz2rmid(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Steve Wolfe&#39;s version has an extra (linear) interpolation step for</span>
        <span class="c1"># small psi_norm. Should check to see if we need this still with the</span>
        <span class="c1"># scipy spline. So far looks fine...</span>
        
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rz2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2roa">[docs]</a>    <span class="k">def</span> <span class="nf">rz2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps the given points to the normalized minor radius, r/a.</span>
<span class="sd">        </span>
<span class="sd">        Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</span>
<span class="sd">       </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to r/a. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to r/a. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **roa** (`Array or scalar float`) - The normalized minor radius.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `roa` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `roa`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                roa_val = Eq_instance.rz2roa(0.6, 0, 0.26)</span>

<span class="sd">            Find r/a values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.rz2roa([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find r/a values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.rz2roa(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.rz2roa([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find r/a values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                roa_mat = Eq_instance.rz2roa(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Steve Wolfe&#39;s version has an extra (linear) interpolation step for</span>
        <span class="c1"># small psi_norm. Should check to see if we need this still with the</span>
        <span class="c1"># scipy spline. So far looks fine...</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rz2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rz2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (R, Z, t) coordinates into one of several coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to. Valid</span>
<span class="sd">                options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to `rho`. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to `rho`. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of `rho`. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid when `destination` is Rmid. Default is False</span>
<span class="sd">                (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in,</span>
<span class="sd">                AND that `Rmid` is returned in. If a string is given, it must</span>
<span class="sd">                be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid/phinorm/volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.rz2rho(&#39;psinorm&#39;, 0.6, 0, 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, [0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, 0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, [0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find psinorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>
<span class="sd">            </span>
<span class="sd">                psi_mat = Eq_instance.rz2rho(&#39;psinorm&#39;, R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rz2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rmid2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2roa">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">time_idxs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (R_mid, t) coordinates into r/a.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **roa** (`Array or scalar float`) - Normalized midplane minor</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value at R_mid=0.6m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                roa_val = Eq_instance.rmid2roa(0.6, 0.26)</span>

<span class="sd">            Find roa values at R_mid points 0.6m and 0.8m at the</span>
<span class="sd">            single time t=0.26s.::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.rmid2roa([0.6, 0.8], 0.26)</span>

<span class="sd">            Find roa values at R_mid of 0.6m at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.rmid2roa(0.6, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.rmid2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_idxs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">R_mid</span><span class="p">,</span>
             <span class="n">dum</span><span class="p">,</span>
             <span class="n">t</span><span class="p">,</span>
             <span class="n">time_idxs</span><span class="p">,</span>
             <span class="n">original_shape</span><span class="p">,</span>
             <span class="n">single_val</span><span class="p">,</span>
             <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                             <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                             <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
                                             <span class="n">convert_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">R_mid</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">R_mid</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="n">original_shape</span> <span class="o">=</span> <span class="n">R_mid</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="n">roa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        
        <span class="c1"># Restore original shape:</span>
        <span class="n">roa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
 
        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">roa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">roa</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">roa</span>

        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 
        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rmid2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **psinorm** (`Array or scalar float`) - Normalized poloidal flux.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for Rmid=0.7m, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_val = Eq_instance.rmid2psinorm(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find psinorm values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.rmid2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.rmid2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.rmid2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidToPsiNormSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rmid2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculates the normalized toroidal flux.</span>
<span class="sd">        </span>
<span class="sd">        Uses the definitions:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \texttt{phi} &amp;= \int q(\psi)\,d\psi</span>
<span class="sd">            </span>
<span class="sd">            \texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}</span>
<span class="sd">            </span>
<span class="sd">        This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **phinorm** (`Array or scalar float`) - Normalized toroidal flux.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at R_mid=0.6m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phi_val = Eq_instance.rmid2phinorm(0.6, 0.26)</span>
<span class="sd">        </span>
<span class="sd">            Find phinorm values at R_mid points 0.6m and 0.8m at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.rmid2phinorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find phinorm values at R_mid point 0.6m at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.rmid2phinorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (R, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.rmid2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rmid2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume.</span>
<span class="sd">        </span>
<span class="sd">        Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **volnorm** (`Array or scalar float`) - Normalized volume.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value at R_mid=0.6m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                vol_val = Eq_instance.rmid2volnorm(0.6, 0.26)</span>

<span class="sd">            Find volnorm values at R_mid points 0.6m and 0.8m at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                vol_arr = Eq_instance.rmid2volnorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find volnorm values at R_mid points 0.6m at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                vol_arr = Eq_instance.rmid2volnorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                vol_arr = Eq_instance.rmid2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rmid2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (R_mid, t) coordinates into one of several coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to. Valid</span>
<span class="sd">                options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to volnorm or phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at R_mid=0.6m, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.rmid2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at R_mid points 0.6m and 0.8m at the</span>
<span class="sd">            single time t=0.26s.::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rmid2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at R_mid of 0.6m at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rmid2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.rmid2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default back to the old kuldge that wastes time in rz2psi:</span>
            <span class="c1"># TODO: This doesn&#39;t handle length units properly!</span>
            <span class="n">Z_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagZSpline</span><span class="p">()(</span><span class="n">t</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;each_t&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="c1"># Need to override the default in _processRZt, since we are doing</span>
                <span class="c1"># the shaping here:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;each_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># For a single t, there will only be a single value of Z_mid and</span>
                    <span class="c1"># we only need to make it have the same shape as R_mid. Note</span>
                    <span class="c1"># that ones_like appears to be clever enough to handle the case</span>
                    <span class="c1"># of a scalar R_mid.</span>
                    <span class="n">Z_mid</span> <span class="o">=</span> <span class="n">Z_mid</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R_mid</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For multiple t, we need to repeat R_mid for every t, then</span>
                    <span class="c1"># repeat the corresponding Z_mid that many times for each such</span>
                    <span class="c1"># entry.</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rmid2rho: When using the each_t keyword, &quot;</span>
                                         <span class="s2">&quot;t must have only one dimension.&quot;</span><span class="p">)</span>
                    <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
                        <span class="n">R_mid</span><span class="p">,</span>
                        <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),],</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">R_mid</span><span class="p">))))</span>
                    <span class="p">)</span>
                    <span class="c1"># TODO: Is there a clever way to do this without a loop?</span>
                    <span class="n">Z_mid_temp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R_mid</span><span class="p">)</span>
                    <span class="n">t_temp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R_mid</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_mid</span><span class="p">)):</span>
                        <span class="n">Z_mid_temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Z_mid</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">t_temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">Z_mid</span> <span class="o">=</span> <span class="n">Z_mid_temp</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t_temp</span>
                    
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">Z_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.roa2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">roa2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">time_idxs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into Rmid.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).            </span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single R_mid value at r/a=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_val = Eq_instance.roa2rmid(0.6, 0.26)</span>

<span class="sd">            Find R_mid values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.roa2rmid([0.6, 0.8], 0.26)</span>

<span class="sd">            Find R_mid values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.roa2rmid(0.6, [0.2, 0.3])</span>

<span class="sd">            Find R_mid values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.roa2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_idxs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">roa</span><span class="p">,</span>
             <span class="n">dum</span><span class="p">,</span>
             <span class="n">t</span><span class="p">,</span>
             <span class="n">time_idxs</span><span class="p">,</span>
             <span class="n">original_shape</span><span class="p">,</span>
             <span class="n">single_val</span><span class="p">,</span>
             <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                             <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                             <span class="n">check_space</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">roa</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">roa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">roa</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">roa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="n">original_shape</span> <span class="o">=</span> <span class="n">roa</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">roa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="n">R_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        
        <span class="c1"># Restore original shape:</span>
        <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
 
        <span class="n">out</span> <span class="o">=</span> <span class="n">R_mid</span>

        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
    </div>
<div class="viewcode-block" id="Equilibrium.roa2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">roa2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into psinorm.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to volnorm or phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **psinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at r/a=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psinorm_val = Eq_instance.roa2psinorm(0.6, 0.26)</span>

<span class="sd">            Find psinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>
<span class="sd">            </span>
<span class="sd">                psinorm_arr = Eq_instance.roa2psinorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psinorm_arr = Eq_instance.roa2psinorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psinorm_arr = Eq_instance.roa2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.roa2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">roa2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into phinorm.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to volnorm or phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **phinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at r/a=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_val = Eq_instance.roa2phinorm(0.6, 0.26)</span>

<span class="sd">            Find phinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_arr = Eq_instance.roa2phinorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find phinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_arr = Eq_instance.roa2phinorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_arr = Eq_instance.roa2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.roa2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">roa2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into volnorm.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to volnorm or phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **volnorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value at r/a=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_val = Eq_instance.roa2volnorm(0.6, 0.26)</span>

<span class="sd">            Find volnorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_arr = Eq_instance.roa2volnorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find volnorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_arr = Eq_instance.roa2volnorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_arr = Eq_instance.roa2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;volnorm&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.roa2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2rho">[docs]</a>    <span class="k">def</span> <span class="nf">roa2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into one of several coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from Rmid to</span>
<span class="sd">                psinorm and psinorm to volnorm or phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at r/a=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.roa2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.roa2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.roa2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.roa2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;convert_roa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.psinorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the outboard R_mid location corresponding to the passed psinorm (normalized poloidal flux) values.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single R_mid value for psinorm=0.7, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_val = Eq_instance.psinorm2rmid(0.7, 0.26)</span>

<span class="sd">            Find R_mid values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.psinorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">            Find R_mid values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.psinorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">            Find R_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                R_mid_arr = Eq_instance.psinorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span>
                                                <span class="n">psi_norm</span><span class="p">,</span>
                                                <span class="n">t</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2roa">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized minor radius location corresponding to the passed psi_norm (normalized poloidal flux) values.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **roa** (`Array or scalar float`) - Normalized midplane minor</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value for psinorm=0.7, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                roa_val = Eq_instance.psinorm2roa(0.7, 0.26)</span>

<span class="sd">            Find r/a values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.psinorm2roa([0.5, 0.7], 0.26)</span>

<span class="sd">            Find r/a values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.psinorm2roa(0.5, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                roa_arr = Eq_instance.psinorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span>
                                  <span class="n">psi_norm</span><span class="p">,</span>
                                  <span class="n">t</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized volume corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **volnorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value for psinorm=0.7, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_val = Eq_instance.psinorm2volnorm(0.7, 0.26)</span>

<span class="sd">            Find volnorm values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_arr = Eq_instance.psinorm2volnorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find volnorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_arr = Eq_instance.psinorm2volnorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                volnorm_arr = Eq_instance.psinorm2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **phinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value for psinorm=0.7, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_val = Eq_instance.psinorm2phinorm(0.7, 0.26)</span>
<span class="sd">                </span>
<span class="sd">            Find phinorm values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_arr = Eq_instance.psinorm2phinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find phinorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_arr = Eq_instance.psinorm2phinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                phinorm_arr = Eq_instance.psinorm2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2rho">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (psinorm, t) coordinates into one of several coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid/phinorm/volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at psinorm=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phi_val = Eq_instance.psinorm2rho(&#39;phinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find phinorm values at phinorm of 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.psinorm2rho(&#39;phinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find phinorm values at psinorm of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.psinorm2rho(&#39;phinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                phi_arr = Eq_instance.psinorm2rho(&#39;phinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;psinorm2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.phinorm2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from phinorm to</span>
<span class="sd">                psinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **psinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for phinorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_val = Eq_instance.phinorm2psinorm(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find psinorm values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.phinorm2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.phinorm2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.phinorm2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormToPsiNormSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.phinorm2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from phinorm to</span>
<span class="sd">                psinorm and psinorm to volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **volnorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value for phinorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                volnorm_val = Eq_instance.phinorm2volnorm(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find volnorm values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                volnorm_arr = Eq_instance.phinorm2volnorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find volnorm values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                volnorm_arr = Eq_instance.phinorm2volnorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                volnorm_arr = Eq_instance.phinorm2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.phinorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the mapped outboard midplane major radius corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).                        </span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).            </span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from phinorm to</span>
<span class="sd">                psinorm and psinorm to Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single Rmid value for phinorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_val = Eq_instance.phinorm2rmid(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find Rmid values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_arr = Eq_instance.phinorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">            Find Rmid values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_arr = Eq_instance.phinorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">            Find Rmid values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_arr = Eq_instance.phinorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.phinorm2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2roa">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized minor radius corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from phinorm to</span>
<span class="sd">                psinorm and psinorm to Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **roa** (`Array or scalar float`) - Normalized midplane minor</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value for phinorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                roa_val = Eq_instance.phinorm2roa(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find r/a values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                roa_arr = Eq_instance.phinorm2roa([0.5, 0.7], 0.26)</span>

<span class="sd">            Find r/a values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                roa_arr = Eq_instance.phinorm2roa(0.5, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                roa_arr = Eq_instance.phinorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="n">phi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.phinorm2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2rho">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (phinorm, t) coordinates into one of several coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `phinorm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `phinorm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                Rmid/phinorm/volnorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at phinorm=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.phinorm2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at phinorm of 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.phinorm2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at phinorm of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.phinorm2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.phinorm2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;phinorm2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.volnorm2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from volnorm to</span>
<span class="sd">                psinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **psinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for volnorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_val = Eq_instance.volnorm2psinorm(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find psinorm values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.volnorm2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.volnorm2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                psinorm_arr = Eq_instance.volnorm2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormToPsiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.volnorm2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from volnorm to</span>
<span class="sd">                psinorm and psinorm to phinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **phinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value for volnorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                phinorm_val = Eq_instance.volnorm2phinorm(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find phinorm values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                phinorm_arr = Eq_instance.volnorm2phinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find phinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                phinorm_arr = Eq_instance.volnorm2phinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                phinorm_arr = Eq_instance.volnorm2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.volnorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the mapped outboard midplane major radius corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).                        </span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).            </span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from volnorm to</span>
<span class="sd">                psinorm and psinorm to Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single Rmid value for volnorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_val = Eq_instance.volnorm2rmid(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find Rmid values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_arr = Eq_instance.volnorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">            Find Rmid values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_arr = Eq_instance.volnorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">            Find Rmid values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                Rmid_arr = Eq_instance.volnorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.volnorm2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2roa">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized minor radius corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>
<span class="sd">    </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a. </span>
<span class="sd">                Only the square root of positive values is taken. Negative </span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated </span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from volnorm to</span>
<span class="sd">                psinorm and psinorm to Rmid. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.            </span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **roa** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">    </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value for volnorm=0.7, t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                roa_val = Eq_instance.volnorm2roa(0.7, 0.26)</span>
<span class="sd">            </span>
<span class="sd">            Find r/a values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>
<span class="sd">        </span>
<span class="sd">                roa_arr = Eq_instance.volnorm2roa([0.5, 0.7], 0.26)</span>

<span class="sd">            Find r/a values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>
<span class="sd">        </span>
<span class="sd">                roa_arr = Eq_instance.volnorm2roa(0.5, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>
<span class="sd">        </span>
<span class="sd">                roa_arr = Eq_instance.volnorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Equilibrium.volnorm2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2rho">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (volnorm, t) coordinates into one of several coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                </span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>
<span class="sd">                </span>
<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `volnorm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `volnorm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).            </span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from volnorm to</span>
<span class="sd">                Rmid/phinorm/psinorm. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>
<span class="sd">        </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at volnorm=0.6, t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_val = Eq_instance.volnorm2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at volnorm of 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.volnorm2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at volnorm of 0.6 at times t=[0.2s, 0.3s]::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.volnorm2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::</span>
<span class="sd">            </span>
<span class="sd">                psi_arr = Eq_instance.volnorm2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;volnorm2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    
    <span class="c1">###########################</span>
    <span class="c1"># Backend Mapping Drivers #</span>
    <span class="c1">###########################</span>
</div>
    <span class="k">def</span> <span class="nf">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                      <span class="n">sqrt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">time_idxs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">check_space</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">convert_only</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">convert_roa</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert psinorm to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for computing a variety of quantities given psi_norm</span>
<span class="sd">        and the relevant time indices.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable): Function which returns a 1d spline for the </span>
<span class="sd">                quantity you want to convert into as a function of `psi_norm`</span>
<span class="sd">                given a time index.</span>
<span class="sd">            psi_norm (Array or scalar float): `psi_norm` values to evaluate at.</span>
<span class="sd">            time_idxs (Array or scalar float): Time indices for each of the</span>
<span class="sd">                `psi_norm` values. Shape must match that of `psi_norm`.</span>
<span class="sd">            t: Array or scalar float. Representative time array that `psi_norm`</span>
<span class="sd">                and `time_idxs` was formed from (used to determine output shape).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of `rho`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).            </span>
<span class="sd">                Note that this will have unexpected results if `spline_func`</span>
<span class="sd">                returns anything other than R_mid.</span>
<span class="sd">            kind (String or non-negative int): Specifies the type of</span>
<span class="sd">                interpolation to be performed in getting from psinorm to</span>
<span class="sd">                `rho`. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for :py:class:`interp1d` for more</span>
<span class="sd">                details. Default value is &#39;cubic&#39; (3rd order spline</span>
<span class="sd">                interpolation). On some builds of scipy, this can cause problems,</span>
<span class="sd">                in which case you should try &#39;linear&#39; until you can rebuild your</span>
<span class="sd">                scipy install.</span>
<span class="sd">            time_idxs (Array with same shape as `psi_norm` or None):</span>
<span class="sd">                The time indices to use (as computed by :py:meth:`_processRZt`).</span>
<span class="sd">                Default is None (compute time indices in method).</span>
<span class="sd">            convert_roa (Boolean): When True, it is assumed that `psi_norm` is</span>
<span class="sd">                actually given as r/a and should be converted to Rmid before</span>
<span class="sd">                being passed to the spline for conversion. Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (`rho`, `time_idxs`)</span>
<span class="sd">            </span>
<span class="sd">            * **rho** (`Array or scalar float`) - The converted quantity. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices </span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
 
        <span class="k">if</span> <span class="n">time_idxs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span>
             <span class="n">dum</span><span class="p">,</span>
             <span class="n">t</span><span class="p">,</span>
             <span class="n">time_idxs</span><span class="p">,</span>
             <span class="n">original_shape</span><span class="p">,</span>
             <span class="n">single_val</span><span class="p">,</span>
             <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                             <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                             <span class="n">check_space</span><span class="o">=</span><span class="n">check_space</span><span class="p">,</span>
                                             <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
                                             <span class="n">convert_only</span><span class="o">=</span><span class="n">convert_only</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">psi_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">psi_norm</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="c1"># This is almost certainly redundant for the designed use case,</span>
                <span class="c1"># but should add minimal overhead in either case:</span>
                <span class="n">psi_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="n">original_shape</span> <span class="o">=</span> <span class="n">psi_norm</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">psi_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># TODO: This might waste more time than it saves with long time_idxs:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
            <span class="n">psi_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)(</span><span class="n">psi_norm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: This can probaby be done a lot better!</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psi_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">)):</span>
                    <span class="n">quan_norm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)(</span><span class="n">psi_norm</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">)</span>
        
        <span class="c1"># Convert to r/a if needed:</span>
        <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
            <span class="n">quan_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        
        <span class="c1"># Restore original shape:</span>
        <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
 
        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">quan_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">quan_norm</span>

        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 
        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
    
    <span class="k">def</span> <span class="nf">_rmid2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Covert the given `R_mid` at the given `time_idxs` to r/a.</span>
<span class="sd">        </span>
<span class="sd">        If you want to use a different definition of r/a, you should override</span>
<span class="sd">        this function and :py:meth:`_roa2rmid`.</span>
<span class="sd">        </span>
<span class="sd">        The definition used here is</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            r/a = \frac{R_{mid} - R_0}{R_a - R_0} = \frac{R_{mid} - R_0}{a}</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array or scalar float): Values of outboard midplane major</span>
<span class="sd">                radius to evaluate r/a at.</span>
<span class="sd">            time_idxs (Array, same shape as `R_mid`): If :py:attr:`self._tricubic`</span>
<span class="sd">                is True, this should be an array of the time points to evaluate</span>
<span class="sd">                at. Otherwise, this should be an array of the time INDICES in</span>
<span class="sd">                :py:meth:`getTimeBase` to evaluate at.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            roa (Array): Same shape as `R_mid` and `time_idxs`. The normalized minor radius at the given `R_mid`, `t` points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get necessary quantities at the relevant times:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagRSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOutSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>
        
        <span class="c1"># Compute r/a according to our definition:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">R_mid</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Rout</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_roa2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Covert the given r/a at the given time_idxs to R_mid.</span>
<span class="sd">        </span>
<span class="sd">        If you want to use a different definition of r/a, you should override</span>
<span class="sd">        this function and :py:meth:`_rmid2roa`.</span>
<span class="sd">        </span>
<span class="sd">        The definition used here is</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            r/a = \frac{R_{mid} - R_0}{R_a - R_0} = \frac{R_{mid} - R_0}{a}</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            roa (Array or scalar float): Values of normalized minor radius to</span>
<span class="sd">                evaluate R_mid at.</span>
<span class="sd">            time_idxs (Array, same shape as `roa`): If :py:attr:`self._tricubic`</span>
<span class="sd">                is True, this should be an array of the time points to evaluate</span>
<span class="sd">                at. Otherwise, this should be an array of the time INDICES in</span>
<span class="sd">                :py:meth:`getTimeBase` to evaluate at.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            R_mid (Array): Same shape as `roa` and `time_idxs`. The mapped midplane major radius at the given `roa`, `t` points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get necessary quantities at the relevant times:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagRSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOutSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>
        
        <span class="c1"># Compute R_mid according to our definition:</span>
        <span class="k">return</span> <span class="n">roa</span> <span class="o">*</span> <span class="p">(</span><span class="n">Rout</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span> <span class="o">+</span> <span class="n">magR</span>
    
    <span class="k">def</span> <span class="nf">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert RZ to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for converting R, Z coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular phi_norm, vol_norm and R_mid.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable): Function which returns a 1d spline for the</span>
<span class="sd">                quantity you want to convert into as a function of psi_norm</span>
<span class="sd">                given a time index.</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to Quan. If R and Z are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in t. Must have</span>
<span class="sd">                the same shape as Z unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to Quan. If R and Z are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in t. Must have</span>
<span class="sd">                the same shape as R unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t (Array-like or single value): If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `R` and `Z` (or the meshgrid thereof</span>
<span class="sd">                if `make_grid` is True) are evaluated at each value in `t`. If</span>
<span class="sd">                True, `t` must have only one dimension (or be a scalar). If</span>
<span class="sd">                False, `t` must match the shape of `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True) or be a scalar. Default is True</span>
<span class="sd">                (evaluate ALL `R`, `Z` at each element in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (Quan,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return Quan).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of Quan. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            make_grid (Boolean):</span>
<span class="sd">                Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho (Boolean):</span>
<span class="sd">                Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of R_mid. Default is False (return major radius, R_mid).</span>
<span class="sd">                Note that this will have unexpected results if spline_func</span>
<span class="sd">                returns anything other than R_mid.</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to Quan. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    =========== ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    =========== ===========</span>
<span class="sd">                    </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                Quand has this shape as well. If the make_grid keyword was True</span>
<span class="sd">                then R_mid has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as R_mid. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c1"># Not used by rz2psinorm:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        
        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_grid&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="c1"># TODO: This technically computes the time indices twice. Is there are</span>
        <span class="c1"># good compromise to get the best of both worlds (nice calling of</span>
        <span class="c1"># _psinorm2Quan AND no recompute)?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="n">spline_func</span><span class="p">,</span>
                                  <span class="n">psi_norm</span><span class="p">,</span>
                                  <span class="n">t</span><span class="p">,</span>
                                  <span class="n">time_idxs</span><span class="o">=</span><span class="n">time_idxs</span><span class="p">,</span>
                                  <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert R_mid to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for converting R, Z coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular phi_norm and vol_norm.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable):</span>
<span class="sd">                Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            R_mid (Array-like or scalar float):</span>
<span class="sd">                Values of the radial coordinate to map to Quan.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R_mid. If t is array-like it must</span>
<span class="sd">                have the same dimensions as R_mid.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `R` and `Z` (or the meshgrid thereof</span>
<span class="sd">                if `make_grid` is True) are evaluated at each value in `t`. If</span>
<span class="sd">                True, `t` must have only one dimension (or be a scalar). If</span>
<span class="sd">                False, `t` must match the shape of `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True) or be a scalar. Default is True</span>
<span class="sd">                (evaluate ALL `R`, `Z` at each element in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (Quan,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return Quan).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of Quan. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to Quan. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_mid given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Has the same shape as R_mid.</span>
<span class="sd">            time_idxs: Array with same shape as Quan. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c1"># Not used by rmid2psinorm:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;convert_roa&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_idxs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_idxs</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        
        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_grid&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        
        <span class="c1"># TODO: This technically computes the time indices twice. Is there are</span>
        <span class="c1"># good compromise to get the best of both worlds (nice calling of</span>
        <span class="c1"># _psinorm2Quan AND no recompute)?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="n">spline_func</span><span class="p">,</span>
                                  <span class="n">psi_norm</span><span class="p">,</span>
                                  <span class="n">t</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert phinorm to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for converting phinorm coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular psi_norm and vol_norm.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable):</span>
<span class="sd">                Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            phinorm (Array-like or scalar float):</span>
<span class="sd">                Values of the normalized toroidal flux to map to `Quan`.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If `t` is a single value, it is used</span>
<span class="sd">                for all of the elements of `phinorm`. If `t` is array-like it</span>
<span class="sd">                must have the same dimensions as `phinorm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `phinorm` are evaluated at each value</span>
<span class="sd">                in `t`. If True, `t` must have only one dimension (or be a</span>
<span class="sd">                scalar). If False, `t` must match the shape of `phinorm` or be a</span>
<span class="sd">                scalar. Default is True (evaluate ALL `phinorm` at each element</span>
<span class="sd">                in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (`Quan`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `phinorm` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `Quan`).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of `Quan`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from `psinorm` to `Quan`. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Has the same shape as `phinorm`.</span>
<span class="sd">            time_idxs: Array with same shape as `Quan`. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if `return_t` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c1"># Not used by phinorm2psinorm:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
        
        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># TODO: This technically computes the time indices twice. Is there are</span>
        <span class="c1"># good compromise to get the best of both worlds (nice calling of</span>
        <span class="c1"># _psinorm2Quan AND no recompute)?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="n">spline_func</span><span class="p">,</span>
                                  <span class="n">psi_norm</span><span class="p">,</span>
                                  <span class="n">t</span><span class="p">,</span>
                                  <span class="n">time_idxs</span><span class="o">=</span><span class="n">time_idxs</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert volnorm to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for converting volnorm coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular psi_norm and phi_norm.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable): Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            volnorm (Array-like or scalar float):</span>
<span class="sd">                Values of the normalized volume to map to `Quan`.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If `t` is a single value, it is used</span>
<span class="sd">                for all of the elements of `volnorm`. If `t` is array-like it</span>
<span class="sd">                must have the same dimensions as `volnorm`.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `volnorm` are evaluated at each value</span>
<span class="sd">                in `t`. If True, `t` must have only one dimension (or be a</span>
<span class="sd">                scalar). If False, `t` must match the shape of `volnorm` or be a</span>
<span class="sd">                scalar. Default is True (evaluate ALL `volnorm` at each element</span>
<span class="sd">                in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (`Quan`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `phinorm` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `Quan`).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of `Quan`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from `volnorm` to `Quan`. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Has the same shape as `volnorm`.</span>
<span class="sd">            time_idxs: Array with same shape as `Quan`. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if `return_t` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c1"># Not used by phinorm2psinorm:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
        
        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># TODO: This technically computes the time indices twice. Is there are</span>
        <span class="c1"># good compromise to get the best of both worlds (nice calling of</span>
        <span class="c1"># _psinorm2Quan AND no recompute)?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="n">spline_func</span><span class="p">,</span>
                                  <span class="n">psi_norm</span><span class="p">,</span>
                                  <span class="n">t</span><span class="p">,</span>
                                  <span class="n">time_idxs</span><span class="o">=</span><span class="n">time_idxs</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="c1">####################</span>
    <span class="c1"># Helper Functions #</span>
    <span class="c1">####################</span>

    <span class="k">def</span> <span class="nf">_getLengthConversionFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the conversion factor to convert from units start to units end.</span>
<span class="sd">        </span>
<span class="sd">        Uses a regex to parse units of the form:</span>
<span class="sd">        &#39;m&#39;</span>
<span class="sd">        &#39;m^2&#39;</span>
<span class="sd">        &#39;m2&#39;</span>
<span class="sd">        Leading and trailing spaces are NOT allowed.</span>
<span class="sd">        </span>
<span class="sd">        Valid unit specifiers are:</span>
<span class="sd">            &#39;m&#39;         meters</span>
<span class="sd">            &#39;cm&#39;        centimeters</span>
<span class="sd">            &#39;mm&#39;        millimeters</span>
<span class="sd">            &#39;in&#39;        inches</span>
<span class="sd">            &#39;ft&#39;        feet</span>
<span class="sd">            &#39;yd&#39;        yards</span>
<span class="sd">            &#39;smoot&#39;     smoots</span>
<span class="sd">            &#39;cubit&#39;     cubits</span>
<span class="sd">            &#39;hand&#39;      hands</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            start (String, int or None):</span>
<span class="sd">                Starting unit for the conversion.</span>
<span class="sd">                - If None, uses the unit specified when the instance was created.</span>
<span class="sd">                - If start is an int, the starting unit is taken to be the unit</span>
<span class="sd">                    specified when the instance was created raised to that power.</span>
<span class="sd">                - If start is &#39;default&#39;, either explicitly or because of</span>
<span class="sd">                    reverting to the instance-level unit, then the value passed</span>
<span class="sd">                    in the kwarg default is used. In this case, default must be</span>
<span class="sd">                    a complete unit string (i.e., not None, not an int and not</span>
<span class="sd">                    &#39;default&#39;).</span>
<span class="sd">                - Otherwise, start must be a valid unit specifier as given above.</span>
<span class="sd">            end (String, int or None):</span>
<span class="sd">                Target (ending) unit for the conversion.</span>
<span class="sd">                - If None, uses the unit specified when the instance was created.</span>
<span class="sd">                - If end is an int, the target unit is taken to be the unit</span>
<span class="sd">                    specified when the instance was created raised to that power.</span>
<span class="sd">                - If end is &#39;default&#39;, either explicitly or because of</span>
<span class="sd">                    reverting to the instance-level unit, then the value passed</span>
<span class="sd">                    in the kwarg default is used. In this case, default must be</span>
<span class="sd">                    a complete unit string (i.e., not None, not an int and not</span>
<span class="sd">                    &#39;default&#39;).</span>
<span class="sd">                - Otherwise, end must be a valid unit specifier as given above.</span>
<span class="sd">                    In this case, if end does not specify an exponent, it uses</span>
<span class="sd">                    whatever the exponent on start is. This allows a user to</span>
<span class="sd">                    ask for an area in units of m^2 by specifying</span>
<span class="sd">                    length_unit=&#39;m&#39;, for instance. An error will still be</span>
<span class="sd">                    raised if the user puts in a completely inconsistent</span>
<span class="sd">                    specification such as length_unit=&#39;m^3&#39; or length_unit=&#39;m^1&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            default (String, int or None):</span>
<span class="sd">                The default unit to use in cases</span>
<span class="sd">                where start or end is &#39;default&#39;. If default is None, an int, or </span>
<span class="sd">                &#39;default&#39;, then the value given for start is used. (A circular</span>
<span class="sd">                definition is prevented for cases in which start is default by</span>
<span class="sd">                checking for this case during the handling of the case</span>
<span class="sd">                start==&#39;default&#39;.)</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Conversion factor: Scalar float. The conversion factor to get from</span>
<span class="sd">                the start unit to the end unit.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If start is &#39;default&#39; and default is None, an int, or</span>
<span class="sd">                &#39;default&#39;.</span>
<span class="sd">            ValueError: If the (processed) exponents of start and end or start</span>
<span class="sd">                and default are incompatible.</span>
<span class="sd">            ValueError: If the processed units for start and end are not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Input handling:</span>
        <span class="c1"># Starting unit:</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># If start is None, it means to use the instance&#39;s default unit (implied to the power of 1):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="c1"># If start is an integer type, this is used as the power applied to the instance&#39;s default unit:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the instance&#39;s default unit is &#39;default&#39;, this is handled next:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="c1"># If start is &#39;default&#39;, the thing passed to default is used, but only if it is a complete unit specification:</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must specify a complete unit (i.e., &quot;</span>
                                 <span class="s2">&quot;non-None, non-integer and not &#39;default&#39;) &quot;</span>
                                 <span class="s2">&quot;when using &#39;default&#39; for the starting unit.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">default</span>
        
        <span class="c1"># Default unit:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="c1"># If start is &#39;default&#39;, these cases have already been caught above.</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">start</span>
        
        <span class="c1"># Target (ending) unit:</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># If end is None, it means to use the instance&#39;s default unit (implied to the power of 1):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="c1"># If end is an integer type, this is used as the power applied to the instance&#39;s default unit:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the instance&#39;s default unit is &#39;default&#39;, this is handled next:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="c1"># If end is &#39;default&#39;, the thing passed to default is used, which</span>
            <span class="c1"># defaults to start, which itself is not allowed to be &#39;default&#39;:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">default</span>
        
        <span class="n">unit_regex</span> <span class="o">=</span> <span class="s1">r&#39;^([A-Za-z]+)\^?([0-9]*)$&#39;</span>
        
        <span class="c1"># Need to explicitly cast because MDSplus returns its own classes and</span>
        <span class="c1"># re.split doesn&#39;t seem to handle the polymorphism properly:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        
        <span class="n">dum1</span><span class="p">,</span> <span class="n">start_u</span><span class="p">,</span> <span class="n">start_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">dum1</span><span class="p">,</span> <span class="n">end_u</span><span class="p">,</span> <span class="n">end_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">dum1</span><span class="p">,</span> <span class="n">default_u</span><span class="p">,</span> <span class="n">default_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        
        <span class="n">start_pow</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">start_pow</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">start_pow</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_pow</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">end_pow</span> <span class="o">=</span> <span class="n">start_pow</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_pow</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_pow</span><span class="p">)</span>
        <span class="n">default_pow</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">default_pow</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">default_pow</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">start_pow</span> <span class="o">!=</span> <span class="n">end_pow</span> <span class="ow">or</span> <span class="n">start_pow</span> <span class="o">!=</span> <span class="n">default_pow</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible exponents between &#39;</span><span class="si">%s</span><span class="s2">&#39;, &#39;</span><span class="si">%s</span><span class="s2">&#39; and &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">_length_conversion</span><span class="p">[</span><span class="n">start_u</span><span class="p">][</span><span class="n">end_u</span><span class="p">])</span><span class="o">**</span><span class="n">start_pow</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit &#39;</span><span class="si">%s</span><span class="s2">&#39; is not a recognized length unit!&quot;</span> <span class="o">%</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_processRZt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">convert_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Input checker/processor.</span>
<span class="sd">        </span>
<span class="sd">        Takes R, Z and t. Appropriately packages them into scipy arrays. Checks</span>
<span class="sd">        the validity of the R, Z ranges. If there is a single time value but</span>
<span class="sd">        multiple R, Z values, creates matching time vector. If there is a single</span>
<span class="sd">        R, Z value but multiple t values, creates matching R and Z vectors.</span>
<span class="sd">        Finds list of nearest-neighbor time indices.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float):</span>
<span class="sd">                Values of the radial coordinate. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `Z` unless the</span>
<span class="sd">                `make_grid` keyword is True. If `make_grid` is True, `R` must</span>
<span class="sd">                have only one dimension (or be a scalar).</span>
<span class="sd">            Z (Array-like or scalar float):</span>
<span class="sd">                Values of the vertical coordinate. If `R` and `Z` are both</span>
<span class="sd">                scalar values, they are used as the coordinate pair for all of</span>
<span class="sd">                the values in `t`. Must have the same shape as `R` unless the</span>
<span class="sd">                `make_grid` keyword is True. If `make_grid` is True, `Z` must</span>
<span class="sd">                have only one dimension.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If `t` is array-like and `make_grid` is False, `t`</span>
<span class="sd">                must have the same dimensions as `R` and `Z`. If `t` is</span>
<span class="sd">                array-like and `make_grid` is True, `t` must have shape</span>
<span class="sd">                (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            make_grid (Boolean):</span>
<span class="sd">                Set to True to pass `R` and `Z` through :py:func:`meshgrid`</span>
<span class="sd">                before evaluating. If this is set to True, `R` and `Z` must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                Default is False (do not form meshgrid).</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `R` and `Z` (or the meshgrid thereof</span>
<span class="sd">                if `make_grid` is True) are evaluated at each value in `t`. If</span>
<span class="sd">                True, `t` must have only one dimension (or be a scalar). If</span>
<span class="sd">                False, `t` must match the shape of `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True) or be a scalar. Default is True</span>
<span class="sd">                (evaluate ALL `R`, `Z` at each element in `t`).</span>
<span class="sd">            check_space (Boolean):</span>
<span class="sd">                If True, `R` and `Z` are converted to meters and checked against</span>
<span class="sd">                the extents of the spatial grid.</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that `R` and `Z` are being given in. If a string is</span>
<span class="sd">                given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>
<span class="sd">                </span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple of:</span>
<span class="sd">            </span>
<span class="sd">            * **R** - Flattened `R` array with out-of-range values replaced with NaN.</span>
<span class="sd">            * **Z** - Flattened Z array with out-of-range values replaced with NaN.</span>
<span class="sd">            * **t** - Flattened t array with out-of-range values replaced with NaN.</span>
<span class="sd">            * **time_idxs** - Flattened array of nearest-neighbor time indices.</span>
<span class="sd">            * **original_shape** - Original shape tuple, used to return the</span>
<span class="sd">              arrays to their starting form.</span>
<span class="sd">            * **single_val** - Boolean indicating whether a single point is used.</span>
<span class="sd">              If True, then the final step of the calling code should unpack the</span>
<span class="sd">              result from the array.</span>
<span class="sd">            * **single_time** - Boolean indicating whether a single time value</span>
<span class="sd">              is used. If True, then certain simplifying steps can be made.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Handle single-value form of R and Z:</span>
        <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">R</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">Z</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Make the grid, if called for:</span>
        <span class="k">if</span> <span class="n">make_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_processRZt: When using the make_grid keyword, the &#39;</span>
                                 <span class="s1">&#39;number of dimensions of R and Z must both be one!&#39;</span><span class="p">)</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_processRZt: Shape of R and Z arrays must match!&#39;</span><span class="p">)</span>

        <span class="c1"># Check that R, Z points are fine:</span>
        <span class="k">if</span> <span class="n">check_space</span><span class="p">:</span>
            <span class="c1"># Convert units to meters:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="n">length_unit</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">R</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">Z</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">convert_only</span><span class="p">:</span>
                <span class="n">good_points</span><span class="p">,</span> <span class="n">num_good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkRZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">num_good</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_processRZt: No valid points!&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">single_val</span><span class="p">:</span>
                    <span class="c1"># Mask out the bad points here so we don&#39;t interfere with the</span>
                    <span class="c1"># single-value case (which must be valid to have made it past the</span>
                    <span class="c1"># test above):</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">~</span><span class="n">good_points</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">~</span><span class="n">good_points</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Handle single-value time cases:</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># The bivariate spline case technically only needs one element, but</span>
            <span class="c1"># the trispline case looks like it needs the full shape.</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
   
        <span class="k">if</span> <span class="n">each_t</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">single_time</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_processRZt: When using the each_t keyword, &quot;</span>
                                 <span class="s2">&quot;t must have only one dimension.&quot;</span><span class="p">)</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,]</span> <span class="o">*</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,]</span> <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">make_grid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_processRZt: shape of t does not match shape of R &#39;</span>
                                 <span class="s1">&#39;and Z. Recall that use of the make_grid &#39;</span>
                                 <span class="s1">&#39;keyword requires that t either be a single &#39;</span>
                                 <span class="s1">&#39;value, or that its shape matches that of &#39;</span>
                                 <span class="s1">&#39;scipy.meshgrid(R, Z).&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_processRZt: t must either be a single number, &#39;</span>
                                 <span class="s1">&#39;or must match the shape of R and Z!&#39;</span><span class="p">)</span>

        <span class="c1"># Handle non-vector array inputs: store the shape, then flatten the arrays.</span>
        <span class="c1"># Don&#39;t bother with a test/flag -- just use the shape vector at the end.</span>
        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
 
        <span class="c1"># Takes keyword to bypass for tricubic interpolation</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>
            <span class="c1"># Set up times to use -- essentially use nearest-neighbor interpolation</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getNearestIdx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timebase</span><span class="p">)</span>
            <span class="c1"># Check errors and warn if needed:</span>
            <span class="n">t_errs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">timebase</span><span class="p">[</span><span class="n">time_idxs</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">timebase</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t_errs</span> <span class="o">&gt;</span> <span class="n">scipy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">timebase</span><span class="p">))</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Some time points are off by more than 1/3 &quot;</span>
                              <span class="s2">&quot;the EFIT point spacing. Using nearest-neighbor interpolation &quot;</span>
                              <span class="s2">&quot;between time points. You may want to run EFIT on the timebase &quot;</span>
                              <span class="s2">&quot;you need. Max error: </span><span class="si">%.3f</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_errs</span><span class="p">),</span>
                              <span class="ne">RuntimeWarning</span><span class="p">)</span>

                <span class="c1"># If a single time value is passed with multiple R, Z points, evaluate</span>
                <span class="c1"># them all at that time point:</span>
            <span class="k">if</span> <span class="n">single_time</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">single_val</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">t</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">single_time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_checkRZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks whether or not the passed arrays of (R, Z) are within the bounds of the reconstruction data.</span>
<span class="sd">        </span>
<span class="sd">        Returns the mask array of booleans indicating the goodness of each point</span>
<span class="sd">        at the corresponding index. Raises warnings if there are no good_points</span>
<span class="sd">        and if there are some values out of bounds.</span>
<span class="sd">        </span>
<span class="sd">        Assumes R and Z are in meters and that the R and Z arrays returned by</span>
<span class="sd">        this instance&#39;s getRGrid() and getZGrid() are monotonically increasing.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (Array):</span>
<span class="sd">                Radial coordinate to check. Must have the same size as Z.</span>
<span class="sd">            Z (Array)</span>
<span class="sd">                Vertical coordinate to check. Must have the same size as R.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            good_points: Boolean array. True where points are within the bounds</span>
<span class="sd">                defined by self.getRGrid and self.getZGrid.</span>
<span class="sd">            num_good: The number of good points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">good_points</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">R</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">Z</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">Z</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># Gracefully handle single-value versus array inputs, returning in the</span>
        <span class="c1"># corresponding type.</span>
        <span class="n">num_good</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_points</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_good</span> <span class="o">=</span> <span class="n">good_points</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: _checkRZ: No valid (R, Z) points!&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_good</span> <span class="o">!=</span> <span class="n">num_pts</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: _checkRZ: Some (R, Z) values out of bounds. &quot;</span>
                          <span class="s2">&quot;(</span><span class="si">%(bad)d</span><span class="s2"> bad out of </span><span class="si">%(tot)d</span><span class="s2">)&quot;</span>
                          <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;bad&#39;</span><span class="p">:</span> <span class="n">num_pts</span> <span class="o">-</span> <span class="n">num_good</span><span class="p">,</span> <span class="s1">&#39;tot&#39;</span><span class="p">:</span> <span class="n">num_pts</span><span class="p">},</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">good_points</span><span class="p">,</span> <span class="n">num_good</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getNearestIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the array of indices of the nearest value in a corresponding to each value in v.</span>
<span class="sd">        </span>
<span class="sd">        If the monotonic keyword in the instance is True, then this is done using</span>
<span class="sd">        scipy.digitize under the assumption that a is monotonic. Otherwise,</span>
<span class="sd">        this is done in a general manner by looking for the minimum distance</span>
<span class="sd">        between the points in v and a.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            v (Array):</span>
<span class="sd">                Input values to match to nearest neighbors in a.</span>
<span class="sd">            a (Array):</span>
<span class="sd">                Given values to match against.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Indices in a of the nearest values to each value in v. Has the same</span>
<span class="sd">                shape as v.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gracefully handle single-value versus array inputs, returning in the</span>
        <span class="c1"># corresponding type.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_monotonic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">val</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">v</span><span class="p">,(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">v</span><span class="p">),(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(())</span>

            

    <span class="k">def</span> <span class="nf">_getFluxBiSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the spline corresponding to the given time index, generating as needed.</span>
<span class="sd">        </span>
<span class="sd">        This returns a bivariate spline for when the instance is created with</span>
<span class="sd">        keyword tspline=False.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            An instance of scipy.interpolate.RectBivariateSpline corresponding</span>
<span class="sd">                to the given time index idx.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Note the order of the arguments -- psiRZ is stored with t along</span>
            <span class="c1"># the first dimension, Z along the second and R along the third.</span>
            <span class="c1"># This leads to intuitive behavior when contour plotting, but</span>
            <span class="c1"># mandates the syntax here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_getFluxTriSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the tricubic interpolating spline for the flux.</span>
<span class="sd">        </span>
<span class="sd">        This is for use when the instance is created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            trispline.spline to give the flux as a function of R, Z and t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">Spline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span>

    <span class="k">def</span> <span class="nf">_getPhiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to phinorm.</span>
<span class="sd">        </span>
<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to phinorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz don&#39;t</span>
                <span class="c1"># support the initial keyword to make the initial value zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">]),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">)),</span>
                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz don&#39;t</span>
                <span class="c1"># support the initial keyword to make the initial value zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">(),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span>
                                                                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                                                                    <span class="n">bounds_error</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span>
    
    <span class="k">def</span> <span class="nf">_getPhiNormToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert phinorm to psinorm.</span>
<span class="sd">        </span>
<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to phinorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz don&#39;t</span>
                <span class="c1"># support the initial keyword to make the initial value zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">]),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">)),</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz don&#39;t</span>
                <span class="c1"># support the initial keyword to make the initial value zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># TODO: Ian, did I do this right?</span>
                <span class="c1"># I had to take out the bounds error...</span>
                <span class="n">t_grid</span><span class="p">,</span> <span class="n">psinorm_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span>
                    <span class="n">t_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>  
                    <span class="n">phi_norm_meas</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">psinorm_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="c1"># bounds_error = False</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span>
    
    <span class="k">def</span> <span class="nf">_getVolNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to volnorm.</span>
<span class="sd">        </span>
<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to volnorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">)),</span>
                                                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                                                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#BiSpline for time variant interpolation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span>
                                                                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                                                                    <span class="n">bounds_error</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span>
    
    <span class="k">def</span> <span class="nf">_getVolNormToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert volnorm to psinorm.</span>
<span class="sd">        </span>
<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to volnorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">)),</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#BiSpline for time variant interpolation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="n">t_grid</span><span class="p">,</span> <span class="n">psinorm_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="c1"># TODO: Ian, did I do this right?</span>
                <span class="c1"># I had to take out the bounds error...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span>
                    <span class="n">t_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">vol_norm_meas</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">psinorm_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="c1"># bounds_error = False</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span>
                                                                        
    <span class="k">def</span> <span class="nf">_getRmidSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        There are two approaches that come to mind:</span>
<span class="sd">            -- In Steve Wolfe&#39;s implementation of efit_rz2mid and efit_psi2rmid,</span>
<span class="sd">                he uses the EFIT output Rmid as a function of normalized flux</span>
<span class="sd">                (i.e., what is returned by self.getRmidPsi()) in the core, then</span>
<span class="sd">                expands the grid beyond this manually.</span>
<span class="sd">            -- A simpler approach would be to just compute the psi_norm(R_mid)</span>
<span class="sd">                grid directly from the radial grid.</span>

<span class="sd">        The latter approach is selected for simplicity.</span>
<span class="sd">        </span>
<span class="sd">        The units of R_mid are always meters, and are converted by the wrapper</span>
<span class="sd">        functions to whatever the user wants.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to R_mid. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># New approach: create a fairly dense radial grid from the global</span>
                <span class="c1"># flux grid to avoid 1d interpolation problems in the core. The</span>
                <span class="c1"># bivariate spline seems to be a little more robust in this respect.</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">resample_factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)))</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R_grid</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()[</span><span class="n">idx</span><span class="p">])</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">psi_norm_on_grid</span><span class="p">,</span>
                                                    <span class="n">R_grid</span><span class="p">,</span>
                                                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>

                <span class="c1"># generate timebase and R_grid through a meshgrid</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span><span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,)))</span>
                <span class="n">Z_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
                                   <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">R_grid</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                   <span class="n">resample_factor</span><span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R_grid</span><span class="p">,</span> <span class="n">Z_grid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">psi_norm_on_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">R_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>
            
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span>
    
    <span class="k">def</span> <span class="nf">_getRmidToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        There are two approaches that come to mind:</span>
<span class="sd">            -- In Steve Wolfe&#39;s implementation of efit_rz2mid and efit_psi2rmid,</span>
<span class="sd">                he uses the EFIT output Rmid as a function of normalized flux</span>
<span class="sd">                (i.e., what is returned by self.getRmidPsi()) in the core, then</span>
<span class="sd">                expands the grid beyond this manually.</span>
<span class="sd">            -- A simpler approach would be to just compute the psi_norm(R_mid)</span>
<span class="sd">                grid directly from the radial grid.</span>

<span class="sd">        The latter approach is selected for simplicity.</span>
<span class="sd">        </span>
<span class="sd">        The units of R_mid are always meters, and are converted by the wrapper</span>
<span class="sd">        functions to whatever the user wants.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from R_mid to psinorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># New approach: create a fairly dense radial grid from the global</span>
                <span class="c1"># flux grid to avoid 1d interpolation problems in the core. The</span>
                <span class="c1"># bivariate spline seems to be a little more robust in this respect.</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="c1"># self.getMagR(length_unit=&#39;m&#39;)[idx],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">resample_factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()[</span><span class="n">idx</span><span class="p">])</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span>
                    <span class="n">psi_norm_on_grid</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>

                <span class="c1">#generate timebase and R_grid through a meshgrid</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,))</span>
                <span class="p">)</span>
                <span class="n">Z_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="c1"># TODO: This can be done much more efficiently!</span>
                    <span class="n">R_grid</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">resample_factor</span>
                    <span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R_grid</span><span class="p">,</span> <span class="n">Z_grid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>                   
                    <span class="n">R_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">psi_norm_on_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>
                
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span>

    <span class="k">def</span> <span class="nf">_getPsi0Spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate psi0 as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to psi0. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to psi0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">(),</span>
                                                                   <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly call this method</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">],</span>
                                                                   <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                                   <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
          
                
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span>

    <span class="k">def</span> <span class="nf">_getLCFSPsiSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate psi_a as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to psi_a. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to psi_a.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">(),</span>
                                                                   <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly call this method</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">],</span>
                                                                   <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                                   <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
          

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span>

<div class="viewcode-block" id="Equilibrium.getMagRSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagRSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getMagRSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate R_mag as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to R_mag. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to R_mid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                                                              <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                              <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly call this method</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">],</span>
                                                                   <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                                   <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
                
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMagZSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagZSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getMagZSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate Z_mag as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Generated for completeness of the core position calculation when using</span>
<span class="sd">        tspline = True</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to R_mag. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to R_mid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                                                              <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                              <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly call this method</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">],</span>
                                                              <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                              <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                              <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
                

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span>
    </div>
<div class="viewcode-block" id="Equilibrium.getRmidOutSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidOutSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidOutSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate R_mid_out as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Generated for completeness of the core position calculation when using</span>
<span class="sd">        tspline = True</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to R_mag. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to R_mid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                                                                 <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                 <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly call this method</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">],</span>
                                                                 <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                                 <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                                 <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
                


            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span>
    </div>
<div class="viewcode-block" id="Equilibrium.getAOutSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAOutSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getAOutSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate a_out as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that a_out is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                </span>
<span class="sd">                    ==========  ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    ==========  ===========</span>
<span class="sd">                    </span>
<span class="sd">                If `length_unit` is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (a_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to a_out. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to a_out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getAOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly call this method</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
                <span class="p">)</span>
            
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span>
</div>
<div class="viewcode-block" id="Equilibrium.getInfo"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getInfo">[docs]</a>    <span class="k">def</span> <span class="nf">getInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns namedtuple of instance parameters (shot, equilibrium type, size, timebase, etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getTimeBase"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getTimeBase">[docs]</a>    <span class="k">def</span> <span class="nf">getTimeBase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns timebase array [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        returns 3D grid of psi(r,z,t)</span>
<span class="sd">         The array returned should have the following dimensions:</span>
<span class="sd">           First dimension: time</span>
<span class="sd">           Second dimension: Z</span>
<span class="sd">           Third dimension: R</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getRGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns vector of R-values for psiRZ grid [r]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getZGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getZGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getZGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns vector of Z-values for psiRZ grid [z]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxAxis"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxAxis">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns psi at magnetic axis [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns psi a separatrix [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getRLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns R-positions (n points) mapping LCFS [t,n]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getZLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getZLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getZLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns Z-positions (n points) mapping LCFS [t,n]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="Equilibrium.remapLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.remapLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">remapLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Overwrites stored R,Z positions of LCFS with explicitly calculated psinorm=1</span>
<span class="sd">        surface.  This surface is then masked using core.inPolygon() to only draw within</span>
<span class="sd">        vacuum vessel, the end result replacing RLCFS, ZLCFS with an R,Z array showing</span>
<span class="sd">        the divertor legs of the flux surface in addition to the core-enclosing closed</span>
<span class="sd">        flux surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxVol"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxVol">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxVol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns volume contained within flux surface as function of psi [psi,t].</span>
<span class="sd">        Psi assumed to be evenly-spaced grid on [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getVolLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getVolLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getVolLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns plasma volume within LCFS [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRmidPsi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidPsi">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidPsi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns outboard-midplane major radius of flux surface [t,psi]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getF"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getF">[docs]</a>    <span class="k">def</span> <span class="nf">getF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns F=RB_{\Phi}(\Psi), often calculated for grad-shafranov solutions  [psi,t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="Equilibrium.getFluxPres"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxPres">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxPres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated pressure profile [psi,t].</span>
<span class="sd">        Psi assumed to be evenly-spaced grid on [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">getFFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns FF&#39; function used for grad-shafranov solutions [psi,t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getPPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getPPrime">[docs]</a>    <span class="k">def</span> <span class="nf">getPPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns plasma pressure gradient as a function of psi [psi,t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getElongation"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getElongation">[docs]</a>    <span class="k">def</span> <span class="nf">getElongation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns LCFS elongation [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getUpperTriangularity"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getUpperTriangularity">[docs]</a>    <span class="k">def</span> <span class="nf">getUpperTriangularity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns LCFS upper triangularity [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getLowerTriangularity"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getLowerTriangularity">[docs]</a>    <span class="k">def</span> <span class="nf">getLowerTriangularity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns LCFS lower triangularity [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getShaping"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getShaping">[docs]</a>    <span class="k">def</span> <span class="nf">getShaping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns dimensionless shaping parameters for plasma.</span>
<span class="sd">        Namedtuple containing {LCFS elongation, LCFS upper/lower triangularity}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMagR"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagR">[docs]</a>    <span class="k">def</span> <span class="nf">getMagR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns magnetic-axis major radius [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMagZ"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagZ">[docs]</a>    <span class="k">def</span> <span class="nf">getMagZ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns magnetic-axis Z [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getAreaLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAreaLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getAreaLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns LCFS surface area [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getAOut"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAOut">[docs]</a>    <span class="k">def</span> <span class="nf">getAOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns outboard-midplane minor radius [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRmidOut"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidOut">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns outboard-midplane major radius [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getGeometry"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getGeometry">[docs]</a>    <span class="k">def</span> <span class="nf">getGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns dimensional geometry parameters</span>
<span class="sd">        Namedtuple containing {mag axis R,Z, LCFS area, volume, outboard-midplane major radius}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQProfile"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQProfile">[docs]</a>    <span class="k">def</span> <span class="nf">getQProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns safety factor q profile [psi,t]</span>
<span class="sd">        Psi assumed to be evenly-spaced grid on [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ0"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ0">[docs]</a>    <span class="k">def</span> <span class="nf">getQ0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns q on magnetic axis [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ95"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ95">[docs]</a>    <span class="k">def</span> <span class="nf">getQ95</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns q on 95% flux surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getQLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns q on LCFS [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ1Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ1Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ1Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns outboard-midplane minor radius of q=1 surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="Equilibrium.getQ2Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ2Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ2Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns outboard-midplane minor radius of q=2 surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ3Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ3Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ3Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns outboard-midplane minor radius of q=3 surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQs"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQs">[docs]</a>    <span class="k">def</span> <span class="nf">getQs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns specific q-profile values.</span>
<span class="sd">        Namedtuple containing {q0, q95, qLCFS, minor radius of q=1,2,3 surfaces}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBtVac"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtVac">[docs]</a>    <span class="k">def</span> <span class="nf">getBtVac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns vacuum on-axis toroidal field [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBtPla"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtPla">[docs]</a>    <span class="k">def</span> <span class="nf">getBtPla</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns plasma on-axis toroidal field [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBpAvg"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBpAvg">[docs]</a>    <span class="k">def</span> <span class="nf">getBpAvg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns average poloidal field [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> 
</div>
<div class="viewcode-block" id="Equilibrium.getFields"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFields">[docs]</a>    <span class="k">def</span> <span class="nf">getFields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns magnetic-field values.</span>
<span class="sd">        Namedtuple containing {Btor on magnetic axis (plasma and vacuum), avg Bpol}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getIpCalc"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getIpCalc">[docs]</a>    <span class="k">def</span> <span class="nf">getIpCalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated plasma current [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getIpMeas"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getIpMeas">[docs]</a>    <span class="k">def</span> <span class="nf">getIpMeas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns measured plasma current [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getJp"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getJp">[docs]</a>    <span class="k">def</span> <span class="nf">getJp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns grid of calculated toroidal current density [t,z,r]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBetaT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetaT">[docs]</a>    <span class="k">def</span> <span class="nf">getBetaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated global toroidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBetaP"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetaP">[docs]</a>    <span class="k">def</span> <span class="nf">getBetaP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated global poloidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getLi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getLi">[docs]</a>    <span class="k">def</span> <span class="nf">getLi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated internal inductance of plasma [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBetas"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetas">[docs]</a>    <span class="k">def</span> <span class="nf">getBetas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated betas and inductance.</span>
<span class="sd">        Namedtuple of {betat,betap,Li}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagFlux"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns diamagnetic flux [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagBetaT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagBetaT">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagBetaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns diamagnetic-loop toroidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagBetaP"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagBetaP">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagBetaP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns diamagnetic-loop poloidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagTauE"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagTauE">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagTauE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns diamagnetic-loop energy confinement time [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagWp"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagWp">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagWp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns diamagnetic-loop plasma stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamag"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamag">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns diamagnetic measurements of plasma parameters.</span>
<span class="sd">        Namedtuple of {diamag. flux, betat, betap from coils, tau_E from diamag., diamag. stored energy}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getWMHD"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWMHD">[docs]</a>    <span class="k">def</span> <span class="nf">getWMHD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated MHD stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getTauMHD"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getTauMHD">[docs]</a>    <span class="k">def</span> <span class="nf">getTauMHD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated MHD energy confinement time [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getPinj"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getPinj">[docs]</a>    <span class="k">def</span> <span class="nf">getPinj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated injected power [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getCurrentSign"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getCurrentSign">[docs]</a>    <span class="k">def</span> <span class="nf">getCurrentSign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated current direction, where CCW = +</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getWbdot"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWbdot">[docs]</a>    <span class="k">def</span> <span class="nf">getWbdot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated d/dt of magnetic stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getWpdot"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWpdot">[docs]</a>    <span class="k">def</span> <span class="nf">getWpdot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns calculated d/dt of plasma stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getEnergy"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getEnergy">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns stored-energy parameters.</span>
<span class="sd">        Namedtuple of {stored energy, confinement time, injected power, d/dt of magnetic, plasma stored energy}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getParam"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getParam">[docs]</a>    <span class="k">def</span> <span class="nf">getParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Backup function: takes parameter name for variable, returns variable directly.</span>
<span class="sd">        Acts as wrapper to direct data-access routines from within object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#backup function - takes parameter name for EFIT variable, returns that variable</span>
        <span class="c1">#acts as wrapper for EFIT tree access from within object</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMachineCrossSection"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMachineCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getMachineCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns (R,Z) coordinates of vacuum wall cross-section for plotting/masking routines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMachineCrossSectionFull"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMachineCrossSectionFull">[docs]</a>    <span class="k">def</span> <span class="nf">getMachineCrossSectionFull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>
<span class="sd">        </span>
<span class="sd">        Returns (R,Z) coordinates of machine wall cross-section for plotting routines.</span>
<span class="sd">        Returns a more detailed cross-section than getLimiter(), generally a vector map</span>
<span class="sd">        displaying non-critical cross-section information.  If this is unavailable, this</span>
<span class="sd">        should point to self.getMachineCrossSection(), which pulls the limiter outline</span>
<span class="sd">        stored by default in data files e.g. g-eqdsk files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;function to return machine cross-section not implemented for this class yet!&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.gfile"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.gfile">[docs]</a>    <span class="k">def</span> <span class="nf">gfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nw</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shot</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tunit</span><span class="o">=</span><span class="s1">&#39;ms&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;EQTOOLS&#39;</span><span class="p">,</span> <span class="n">nbbbs</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates an EFIT gfile with gfile naming convention</span>
<span class="sd">                  </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            time (scalar float): Time of equilibrium to</span>
<span class="sd">                generate the gfile from. This will use the specified</span>
<span class="sd">                spline functionality to do so. Allows for it to be </span>
<span class="sd">                unspecified for single-time-frame equilibria.</span>
<span class="sd">            nw (scalar integer): Number of points in R.</span>
<span class="sd">                R is the major radius, and describes the &#39;width&#39; of the </span>
<span class="sd">                gfile.</span>
<span class="sd">            nh (scalar integer): Number of points in Z. In cylindrical</span>
<span class="sd">                coordinates Z is the height, and nh describes the &#39;height&#39; </span>
<span class="sd">                of the gfile.</span>
<span class="sd">            shot (scalar integer): The shot numer of the equilibrium.</span>
<span class="sd">                Used to help generate the gfile name if unspecified.</span>
<span class="sd">            name (String): Name of the gfile.  If unspecified, will follow</span>
<span class="sd">                standard gfile naming convention (g+shot.time) under current</span>
<span class="sd">                python operating directory.  This allows for it to be saved</span>
<span class="sd">                in other directories, etc.</span>
<span class="sd">            tunit (String): Specified unit for tin. It can only be &#39;ms&#39; for</span>
<span class="sd">                milliseconds or &#39;s&#39; for seconds.</span>
<span class="sd">            title (String): Title of the gfile on the first line. Name cannot</span>
<span class="sd">                exceed 10 digits. This is so that the style of the first line</span>
<span class="sd">                is preserved.</span>
<span class="sd">            nbbbs (scalar integer): Number of points to define the plasma </span>
<span class="sd">                seperatrix within the gfile.  The points are defined equally</span>
<span class="sd">                spaced in angle about the plasma center.  This will cause the </span>
<span class="sd">                x-point to be poorly defined.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If title is longer than 10 characters.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class (example</span>
<span class="sd">            shot number of 1001).</span>
<span class="sd">            </span>
<span class="sd">            Generate a gfile at t=0.26s, output of g1001.26::</span>
<span class="sd">            </span>
<span class="sd">                Eq_instance.gfile(.26)</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filewriter</span><span class="o">.</span><span class="n">gfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">time</span><span class="p">,</span>
                         <span class="n">nw</span><span class="o">=</span><span class="n">nw</span><span class="p">,</span>
                         <span class="n">nh</span><span class="o">=</span><span class="n">nh</span><span class="p">,</span>
                         <span class="n">shot</span><span class="o">=</span><span class="n">shot</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">tunit</span><span class="o">=</span><span class="n">tunit</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                         <span class="n">nbbbs</span><span class="o">=</span><span class="n">nbbbs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.plotFlux"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.plotFlux">[docs]</a>    <span class="k">def</span> <span class="nf">plotFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fill</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots flux contours directly from psi grid.</span>
<span class="sd">        </span>
<span class="sd">        Keyword Args:</span>
<span class="sd">            fill (Boolean):</span>
<span class="sd">                Set True to plot filled contours.  Set False (default) to plot white-background</span>
<span class="sd">                color contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">psiRZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()</span>
            <span class="n">rGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">zGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>

            <span class="n">RLCFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRLCFS</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">ZLCFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZLCFS</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;cannot plot EFIT flux map.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">limx</span><span class="p">,</span> <span class="n">limy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMachineCrossSection</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No machine cross-section implemented!&#39;</span><span class="p">)</span>
            <span class="n">limx</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">limy</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">macx</span><span class="p">,</span> <span class="n">macy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMachineCrossSectionFull</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">macx</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">macy</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1">#event handler for arrow key events in plot windows.  Pass slider object</span>
        <span class="c1">#to update as masked argument using lambda function</span>
        <span class="c1">#lambda evt: arrow_respond(my_slider,evt)</span>
        <span class="k">def</span> <span class="nf">arrowRespond</span><span class="p">(</span><span class="n">slider</span><span class="p">,</span><span class="n">event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmax</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmin</span><span class="p">))</span>

        <span class="c1">#make time-slice window</span>
        <span class="n">fluxPlot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">psi</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">timeSliderSub</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># dummy plot to get x,ylims</span>
        <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span><span class="n">zGrid</span><span class="p">,</span><span class="n">psiRZ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># generate graphical mask for limiter wall</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="n">bound_verts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">poly_verts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">limx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">limy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

            <span class="n">bound_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span>
            <span class="n">poly_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span>

            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">bound_verts</span> <span class="o">+</span> <span class="n">poly_verts</span><span class="p">,</span> <span class="n">bound_codes</span> <span class="o">+</span> <span class="n">poly_codes</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">updateTime</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">t_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timeSlider</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;EFIT Reconstruction, $t = </span><span class="si">%(t).2f</span><span class="s1">$ s&#39;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]})</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$R$ [m]&#39;</span><span class="p">)</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$Z$ [m]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">macx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">macx</span><span class="p">,</span><span class="n">macy</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">limx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">limx</span><span class="p">,</span><span class="n">limy</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="c1"># catch NaNs separating disjoint sections of R,ZLCFS in mask</span>
            <span class="n">maskarr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">RLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">])))</span>
            <span class="n">RLCFSframe</span> <span class="o">=</span> <span class="n">RLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span><span class="n">maskarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ZLCFSframe</span> <span class="o">=</span> <span class="n">ZLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span><span class="n">maskarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">RLCFSframe</span><span class="p">,</span><span class="n">ZLCFSframe</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span><span class="n">zGrid</span><span class="p">,</span><span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span><span class="mi">50</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span><span class="n">zGrid</span><span class="p">,</span><span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span><span class="mi">50</span><span class="p">,</span><span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span><span class="n">zGrid</span><span class="p">,</span><span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span><span class="mi">50</span><span class="p">,</span><span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">patchdraw</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="n">patchdraw</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">fluxPlot</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="n">timeSlider</span> <span class="o">=</span> <span class="n">mplw</span><span class="o">.</span><span class="n">Slider</span><span class="p">(</span><span class="n">timeSliderSub</span><span class="p">,</span><span class="s1">&#39;t index&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">valinit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">valfmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">timeSlider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">updateTime</span><span class="p">)</span>
        <span class="n">updateTime</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fluxPlot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">fluxPlot</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">evt</span><span class="p">:</span> <span class="n">arrowRespond</span><span class="p">(</span><span class="n">timeSlider</span><span class="p">,</span> <span class="n">evt</span><span class="p">))</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">eqtools 1.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Chilenski, Ian Faust and John Walk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>