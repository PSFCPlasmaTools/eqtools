

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>eqtools.core &mdash; eqtools 0.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="eqtools 0.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">eqtools 0.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for eqtools.core</h1><div class="highlight"><pre>
<span class="c"># This program is distributed under the terms of the GNU General Purpose License (GPL).</span>
<span class="c"># Refer to http://www.gnu.org/licenses/gpl.txt</span>
<span class="c">#</span>
<span class="c"># This file is part of EqTools.</span>
<span class="c">#</span>
<span class="c"># EqTools is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># EqTools is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with EqTools.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;This module contains the core classes for EqTools, including the base</span>
<span class="sd">Equilibrium class.</span>

<span class="sd">Classes:</span>
<span class="sd">    ModuleWarning: Warning class for unavailable modules.</span>
<span class="sd">    Equilibrium: Base class for all other equilibrium access objects. Includes</span>
<span class="sd">        the main mapping routines and method stubs for all suggested methods</span>
<span class="sd">        that should be implemented in subclasses.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="ModuleWarning"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.ModuleWarning">[docs]</a><span class="k">class</span> <span class="nc">ModuleWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning class to notify the user of unavailable modules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">trispline</span>
    <span class="n">_has_trispline</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;trispline module could not be loaded -- tricubic spline &quot;</span>
                  <span class="s">&quot;interpolation will not be available.&quot;</span><span class="p">,</span>
                  <span class="n">ModuleWarning</span><span class="p">)</span>
    <span class="n">_has_trispline</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">MDSplus</span>
    <span class="kn">from</span> <span class="nn">MDSplus._treeshr</span> <span class="kn">import</span> <span class="n">TreeException</span>
    <span class="n">_has_MDS</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_e_MDS</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_e_MDS</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;MDSplus module could not be loaded -- classes that use &quot;</span>
                      <span class="s">&quot;MDSplus for data access will not work.&quot;</span><span class="p">,</span>
                      <span class="n">ModuleWarning</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;MDSplus module could not be loaded -- classes that use &quot;</span>
                      <span class="s">&quot;MDSplus for data access will not work. Exception raised &quot;</span>
                      <span class="s">&quot;was of type </span><span class="si">%s</span><span class="s">, message was &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">_e_MDS</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">_e_MDS</span><span class="o">.</span><span class="n">message</span><span class="p">),</span>
                      <span class="n">ModuleWarning</span><span class="p">)</span>
    <span class="n">_has_MDS</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">matplotlib.widgets</span> <span class="kn">as</span> <span class="nn">mplw</span>
    <span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="kn">as</span> <span class="nn">mplgs</span>
    <span class="kn">import</span> <span class="nn">time</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;WARNING: matplotlib modules could not be loaded -- plotting &quot;</span>
                  <span class="s">&quot;will not be available.&quot;</span><span class="p">,</span>
                  <span class="n">ModuleWarning</span><span class="p">)</span>

<div class="viewcode-block" id="PropertyAccessMixin"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin">[docs]</a><span class="k">class</span> <span class="nc">PropertyAccessMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin to implement access of getter methods through a property-type</span>
<span class="sd">    interface without the need to apply a decorator to every property.</span>
<span class="sd">    </span>
<span class="sd">    For any getter obj.getSomething(), the call obj.Something will work.</span>
<span class="sd">    </span>
<span class="sd">    This is accomplished by overriding __getattribute__ such that if an</span>
<span class="sd">    attribute ATTR does not exist it then attempts to call self.getATTR(). If</span>
<span class="sd">    self.getATTR() does not exist, an AttributeError will be raised as usual.</span>
<span class="sd">    </span>
<span class="sd">    Also overrides __setattr__ such that it will raise an AttributeError when</span>
<span class="sd">    attempting to write an attribute ATTR for which there is already a method</span>
<span class="sd">    getATTR.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PropertyAccessMixin.__getattribute__"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin.__getattribute__">[docs]</a>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an attribute.</span>
<span class="sd">        </span>
<span class="sd">        Tries to get attribute as-written. If this fails, tries to call the</span>
<span class="sd">        method get[name] with no arguments. If this fails, raises</span>
<span class="sd">        AttributeError. This effectively generates a Python &#39;property&#39; for</span>
<span class="sd">        each getter method.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            name: String. Name of the attribute to retrieve. If the instance</span>
<span class="sd">                has an attribute with this name, the attribute is returned. If</span>
<span class="sd">                the instance does not have an attribute with this name but does</span>
<span class="sd">                have a method called &#39;get&#39;+name, this method is called and the</span>
<span class="sd">                result is returned.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            The value of the attribute requested.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If neither attribute name or method &#39;get&#39;+name exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="s">&#39;get&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">)()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(class)s</span><span class="s"> object has no attribute &#39;</span><span class="si">%(n)s</span><span class="s">&#39;&quot;</span>
                                     <span class="s">&quot; or method &#39;get</span><span class="si">%(n)s</span><span class="s">&#39;&quot;</span>
                                      <span class="o">%</span> <span class="p">{</span><span class="s">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                         <span class="s">&#39;n&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">})</span>
</div>
<div class="viewcode-block" id="PropertyAccessMixin.__setattr__"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin.__setattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an attribute.</span>
<span class="sd">        </span>
<span class="sd">        Raises AttributeError if the object already has a method get[name], as</span>
<span class="sd">        creation of such an attribute would interfere with the automatic</span>
<span class="sd">        property generation in __getattribute__.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            name: String. Name of the attribute to set.</span>
<span class="sd">            value: Object. Value to set the attribute to.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If a method called &#39;get&#39;+name already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;get&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(class)s</span><span class="s"> object already has getter method &quot;</span>
                                 <span class="s">&quot;&#39;get</span><span class="si">%(n)s</span><span class="s">&#39;, creating attribute &#39;</span><span class="si">%(n)s</span><span class="s">&#39; will&quot;</span>
                                 <span class="s">&quot; conflict with automatic property generation.&quot;</span>
                                 <span class="o">%</span> <span class="p">{</span><span class="s">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                    <span class="s">&#39;n&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">EFITTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div></div>
<span class="sd">&quot;&quot;&quot;The following is a dictionary to implement length unit conversions. The</span>
<span class="sd">first key is the unit are converting FROM, the second the unit you are</span>
<span class="sd">converting TO. Supports: m, cm, mm, in, ft, yd, smoot, cubit, hand</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">_length_conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
                            <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">,</span>
                            <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span><span class="p">,</span>
                            <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                            <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                            <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                            <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                            <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
                             <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>
                             <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
                             <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">),</span>
                             <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">67.0</span><span class="p">),</span>
                             <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">18.0</span><span class="p">),</span>
                             <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)},</span>
                      <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
                             <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
                             <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span>
                             <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">),</span>
                             <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">67.0</span><span class="p">),</span>
                             <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">18.0</span><span class="p">),</span>
                             <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)},</span>
                      <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span>
                             <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>
                             <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">67.0</span><span class="p">,</span>
                                <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                                <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                                <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                                <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">18.0</span><span class="p">,</span>
                                <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                                <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                                <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                                <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s">&#39;in&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
                               <span class="s">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                               <span class="s">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                               <span class="s">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                               <span class="s">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                               <span class="s">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}}</span>


<div class="viewcode-block" id="Equilibrium"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium">[docs]</a><span class="k">class</span> <span class="nc">Equilibrium</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class of data handling object for magnetic reconstruction outputs.</span>
<span class="sd">    </span>
<span class="sd">    Defines the mapping routines and method fingerprints necessary.</span>
<span class="sd">    Each variable or set of variables is recovered with a corresponding</span>
<span class="sd">    getter method. Essential data for mapping are pulled on initialization</span>
<span class="sd">    (psirz grid, for example) to frontload timing overhead. Additional data</span>
<span class="sd">    are pulled at the first request and stored for subsequent usage.</span>

<span class="sd">    NOTE: this abstract class should not be used directly. Device- and code-</span>
<span class="sd">    specific subclasses are set up to account for inter-device/-code differences</span>
<span class="sd">    in data storage.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="n">tspline</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new Equilibrium instance.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            length_unit: String. Sets the base unit used for any quantity whose</span>
<span class="sd">                dimensions are length to any power. Valid options are:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   whatever the default in the tree is (no</span>
<span class="sd">                                    conversion is performed, units may be</span>
<span class="sd">                                    inconsistent)</span>
<span class="sd">                Default is &#39;m&#39; (all units taken and returned in meters).</span>
<span class="sd">            tspline: Boolean. Sets whether or not interpolation in time is</span>
<span class="sd">                performed using a tricubic spline or nearest-neighbor</span>
<span class="sd">                interpolation. Tricubic spline interpolation requires at least</span>
<span class="sd">                four complete equilibria at different times. It is also assumed</span>
<span class="sd">                that they are functionally correlated, and that parameters do</span>
<span class="sd">                not vary out of their boundaries (derivative = 0 boundary</span>
<span class="sd">                condition). Default is False (use nearest neighbor interpolation).</span>
<span class="sd">            fast: Boolean. Sets whether or not the &quot;fast&quot; form of time window</span>
<span class="sd">                finding is used. If True, the timebase must be monotonically</span>
<span class="sd">                increasing. Default is False (use slower, safer method).</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If length_unit is not a valid unit specifier.</span>
<span class="sd">            ValueError: If tspline is True by module trispline did not load</span>
<span class="sd">                successfully.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">length_unit</span> <span class="o">!=</span> <span class="s">&#39;default&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">length_unit</span> <span class="ow">in</span> <span class="n">_length_conversion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unit &#39;</span><span class="si">%s</span><span class="s">&#39; not a valid unit specifier!&quot;</span> <span class="o">%</span> <span class="n">length_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">=</span> <span class="n">length_unit</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tspline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fast</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">fast</span><span class="p">)</span>  <span class="c"># assumes timebase is monotonically increasing</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_trispline</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;trispline module did NOT load, so argument &quot;</span>
                                 <span class="s">&quot;tspline=True is invalid!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># variables that are purely time dependent require splines rather</span>
                <span class="c"># than indexes for interpolation.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c"># MagR and RmidOut only used for rho (r/a) calculations</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MagRSpline</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
            
        <span class="c"># These are indexes of splines, and become higher dimensional splines</span>
        <span class="c"># with the setting of the tspline keyword.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="p">{}</span>
        
    
<div class="viewcode-block" id="Equilibrium.__str__"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of this instance.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            String describing this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;This is an abstract class.  Please use machine-specific subclass.&#39;</span>
    
    <span class="c">####################</span>
    <span class="c"># Mapping routines #</span>
    <span class="c">####################</span>
    </div>
<div class="viewcode-block" id="Equilibrium.rz2psi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2psi">[docs]</a>    <span class="k">def</span> <span class="nf">rz2psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the passed R, Z, t arrays to psi values.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to poloidal flux. If R and Z are both scalar values, they</span>
<span class="sd">                are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as Z unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to poloidal flux. If R and Z are both scalar values, they</span>
<span class="sd">                are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as R unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (psi, time_idxs),</span>
<span class="sd">                where time_idxs is the array of time indices actually used in</span>
<span class="sd">                evaluating psi with nearest-neighbor interpolation. (This is</span>
<span class="sd">                mostly present as an internal helper.) Default is False (only</span>
<span class="sd">                return psi).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            psi: Array or scalar float. If all of the input arguments are scalar,</span>
<span class="sd">                then a scalar is returned. Otherwise, a scipy Array instance is</span>
<span class="sd">                returned. If R and Z both have the same shape then psi has this</span>
<span class="sd">                shape as well. If the make_grid keyword was True then psi has</span>
<span class="sd">                shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as psi. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>
<span class="sd">        </span>
<span class="sd">        Find single psi value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        psi_val = Eq_instance.rz2psi(0.6, 0, 0.26)</span>
<span class="sd">        </span>
<span class="sd">        Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the single</span>
<span class="sd">        time t=0.26s. Note that the Z vector must be fully specified, even if</span>
<span class="sd">        the values are all the same:</span>
<span class="sd">        psi_arr = Eq_instance.rz2psi([0.6, 0.8], [0, 0], 0.26)</span>
<span class="sd">        </span>
<span class="sd">        Find psi values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        psi_arr = Eq_instance.rz2psi(0.6, 0, [0.2, 0.3])</span>
<span class="sd">        </span>
<span class="sd">        Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        psi_arr = Eq_instance.rz2psi([0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>
<span class="sd">        </span>
<span class="sd">        Find psi values on grid defined by 1D vector of radial positions R and</span>
<span class="sd">        1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        psi_mat = Eq_instance.rz2psi(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check inputs and process into flat arrays with units of meters:</span>
        <span class="p">(</span><span class="n">R</span><span class="p">,</span>
         <span class="n">Z</span><span class="p">,</span>
         <span class="n">t</span><span class="p">,</span>
         <span class="n">time_idxs</span><span class="p">,</span>
         <span class="n">original_shape</span><span class="p">,</span>
         <span class="n">single_val</span><span class="p">,</span>
         <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                         <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>

        <span class="c"># Optimized form for single t value case:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="c"># Need to loop over time_idxs</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxTriSpline</span><span class="p">()</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="c"># Correct for current sign:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">out_vals</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span>

        <span class="c"># Restore correct shape:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

        <span class="c"># Unwrap back into single value to match input form, if necessary:</span>
        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out_vals</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="c"># will reshape time_idxs only if it is utilized (otherwise set to None)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux at the given (R, Z, t).</span>
<span class="sd">        </span>
<span class="sd">        Uses the definition:</span>
<span class="sd">        psi_norm = (psi - psi(0)) / (psi(a) - psi(0))</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to normalized poloidal flux. If R and Z are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in t. Must have the same shape as Z unless the make_grid</span>
<span class="sd">                keyword is set. If the make_grid keyword is True, R must have</span>
<span class="sd">                shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to normalized poloidal flux. If R and Z are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in t. Must have the same shape as R unless the make_grid</span>
<span class="sd">                keyword is set. If the make_grid keyword is True, Z must have</span>
<span class="sd">                shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (psinorm,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating psi with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return psinorm).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of normalized</span>
<span class="sd">                flux. Only the square root of positive psi_norm values is taken.</span>
<span class="sd">                Negative values are replaced with zeros, consistent with Steve</span>
<span class="sd">                Wolfe&#39;s IDL implementation efit_rz2rho.pro. Default is False</span>
<span class="sd">                (return psinorm).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            psinorm: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                psinorm has this shape as well. If the make_grid keyword was</span>
<span class="sd">                True then psinorm has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as psinorm. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        psi_val = Eq_instance.rz2psinorm(0.6, 0, 0.26)</span>

<span class="sd">        Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">        single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">        even if the values are all the same:</span>
<span class="sd">        psi_arr = Eq_instance.rz2psinorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">        Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        psi_arr = Eq_instance.rz2psinorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">        Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        psi_arr = Eq_instance.rz2psinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>

<span class="sd">        Find psinorm values on grid defined by 1D vector of radial positions R</span>
<span class="sd">        and 1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        psi_mat = Eq_instance.rz2psinorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">psi</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                     <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">psi_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()[</span><span class="n">time_idxs</span><span class="p">]</span>
            <span class="n">psi_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()[</span><span class="n">time_idxs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># use 1d spline to generate the psi at the core and at boundary.</span>
            <span class="n">psi_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLCFSPsiSpline</span><span class="p">()(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">psi_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPsi0Spline</span><span class="p">()(</span><span class="n">t</span><span class="p">)</span>

        <span class="n">psi_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi</span> <span class="o">-</span> <span class="n">psi_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psi_boundary</span> <span class="o">-</span> <span class="n">psi_0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">psi_norm</span>

        <span class="c"># Unwrap single values to ensure least surprise:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux.</span>
<span class="sd">        </span>
<span class="sd">        Uses the definitions:</span>
<span class="sd">        phi = integral(q(psi), dpsi)</span>
<span class="sd">        phi_norm = phi / phi(a),</span>
<span class="sd">        based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to normalized toroidal flux. If R and Z are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in t. Must have the same shape as Z unless the make_grid</span>
<span class="sd">                keyword is set. If the make_grid keyword is True, R must have</span>
<span class="sd">                shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to normalized toroidal flux. If R and Z are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in t. Must have the same shape as R unless the make_grid</span>
<span class="sd">                keyword is set. If the make_grid keyword is True, Z must have</span>
<span class="sd">                shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (phinorm,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating phinorm with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return phinorm).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of normalized</span>
<span class="sd">                flux. Only the square root of positive phi_norm values is taken.</span>
<span class="sd">                Negative values are replaced with zeros, consistent with Steve</span>
<span class="sd">                Wolfe&#39;s IDL implementation efit_rz2rho.pro. Default is False</span>
<span class="sd">                (return phinorm).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho: Boolean. For phinorm, this should always be set to False, the</span>
<span class="sd">                default value.</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to phinorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            phinorm: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                phinorm has this shape as well. If the make_grid keyword was</span>
<span class="sd">                True then phinorm has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as phinorm. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        phi_val = Eq_instance.rz2phinorm(0.6, 0, 0.26)</span>
<span class="sd">        </span>
<span class="sd">        Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">        single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">        even if the values are all the same:</span>
<span class="sd">        phi_arr = Eq_instance.rz2phinorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">        Find phinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        phi_arr = Eq_instance.rz2phinorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">        Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        phi_arr = Eq_instance.rz2phinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>

<span class="sd">        Find phinorm values on grid defined by 1D vector of radial positions R</span>
<span class="sd">        and 1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        phi_mat = Eq_instance.rz2phinorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume.</span>
<span class="sd">        </span>
<span class="sd">        Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to normalized volume. If R and Z are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as Z unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to normalized volume. If R and Z are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as R unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (volnorm,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating volnorm with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return volnorm).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of normalized</span>
<span class="sd">                volume. Only the square root of positive volnorm values is</span>
<span class="sd">                taken. Negative values are replaced with zeros, consistent with</span>
<span class="sd">                Steve Wolfe&#39;s IDL implementation efit_rz2rho.pro. Default is</span>
<span class="sd">                False (return volnorm).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho: Boolean. For volnorm, this should always be set to False, the</span>
<span class="sd">                default value.</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to volnorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            volnorm: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                volnorm has this shape as well. If the make_grid keyword was</span>
<span class="sd">                True then volnorm has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as volnorm. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        psi_val = Eq_instance.rz2volnorm(0.6, 0, 0.26)</span>

<span class="sd">        Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">        single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">        even if the values are all the same:</span>
<span class="sd">        vol_arr = Eq_instance.rz2volnorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">        Find volnorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        vol_arr = Eq_instance.rz2volnorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">        Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        vol_arr = Eq_instance.rz2volnorm([0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>

<span class="sd">        Find volnorm values on grid defined by 1D vector of radial positions R</span>
<span class="sd">        and 1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        vol_mat = Eq_instance.rz2volnorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rz2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (R, Z, t) coordinates into one of several normalized coordinates.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method: String. Indicates which normalized coordinates to use.</span>
<span class="sd">                Valid options are:</span>
<span class="sd">                    psinorm     Normalized poloidal flux</span>
<span class="sd">                    phinorm     Normalized toroidal flux</span>
<span class="sd">                    volnorm     Normalized volume</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to normalized coordinate. If R and Z are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as Z unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to normalized coordinate. If R and Z are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as R unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (volnorm,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating volnorm with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return volnorm).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of normalized</span>
<span class="sd">                coordinate. Only the square root of positive values is taken.</span>
<span class="sd">                Negative values are replaced with zeros, consistent with Steve</span>
<span class="sd">                Wolfe&#39;s IDL implementation efit_rz2rho.pro. Default is False</span>
<span class="sd">                (return normalized coordinate itself).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho (phinorm and volnorm only): Boolean. For phinorm and volnorm,</span>
<span class="sd">                this should always be set to False, the default value.</span>
<span class="sd">            kind (phinorm and volnorm only): String or non-negative int.</span>
<span class="sd">                Specifies the type of interpolation to be performed in getting</span>
<span class="sd">                from psinorm to phinorm or volnorm. This is passed to</span>
<span class="sd">                scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            rho: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                rho has this shape as well. If the make_grid keyword was True</span>
<span class="sd">                then rho has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as rho. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If method is not one of the supported values.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        psi_val = Eq_instance.rz2rho(&#39;psinorm&#39;, 0.6, 0, 0.26)</span>

<span class="sd">        Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">        single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">        even if the values are all the same:</span>
<span class="sd">        psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, [0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">        Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, 0.6, 0, [0.2, 0.3])</span>

<span class="sd">        Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, [0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>

<span class="sd">        Find psinorm values on grid defined by 1D vector of radial positions R</span>
<span class="sd">        and 1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        psi_mat = Eq_instance.rz2rho(&#39;psinorm&#39;, R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;rz2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.rz2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">rz2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps the given points to the outboard midplane major radius, R_mid.</span>
<span class="sd">        </span>
<span class="sd">        Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to midplane radius. If R and Z are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as Z unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to midplane radius. If R and Z are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in t.</span>
<span class="sd">                Must have the same shape as R unless the make_grid keyword is</span>
<span class="sd">                set. If the make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (R_mid,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return R_mid).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of midplane</span>
<span class="sd">                radius. Only the square root of positive values is taken.</span>
<span class="sd">                Negative values are replaced with zeros, consistent with Steve</span>
<span class="sd">                Wolfe&#39;s IDL implementation efit_rz2rho.pro. Default is False</span>
<span class="sd">                (return R_mid itself).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho: Boolean. Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of R_mid. Default is False (return major radius, R_mid).</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to R_mid. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in AND that R_mid is returned in. If a string is given, it</span>
<span class="sd">                must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters, R_mid returned in meters).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            R_mid: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                R_mid has this shape as well. If the make_grid keyword was True</span>
<span class="sd">                then R_mid has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as R_mid. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single R_mid value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        R_mid_val = Eq_instance.rz2rmid(0.6, 0, 0.26)</span>

<span class="sd">        Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">        single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">        even if the values are all the same:</span>
<span class="sd">        R_mid_arr = Eq_instance.rz2rmid([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">        Find R_mid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        R_mid_arr = Eq_instance.rz2rmid(0.6, 0, [0.2, 0.3])</span>

<span class="sd">        Find R_mid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        R_mid_arr = Eq_instance.rz2rmid([0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>

<span class="sd">        Find R_mid values on grid defined by 1D vector of radial positions R</span>
<span class="sd">        and 1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        R_mid_mat = Eq_instance.rz2rmid(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Steve Wolfe&#39;s version has an extra (linear) interpolation step for</span>
        <span class="c"># small psi_norm. Should check to see if we need this still with the</span>
        <span class="c"># scipy spline. So far looks fine...</span>
        
        <span class="c"># Convert units from meters to desired target:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">length_unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;length_unit&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">length_unit</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the outboard R_mid location corresponding to the passed psi_norm (normalized poloidal flux) values.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            psi_norm: Array-like or scalar float. Values of the normalized</span>
<span class="sd">                poloidal flux to map to midplane radius. If psi_norm is a scalar,</span>
<span class="sd">                it is used as the value for all of the values in t.</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of psi_norm. If neither t nor psi_norm</span>
<span class="sd">                are scalars, t must have the same shape as psi_norm.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (R_mid,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return R_mid).</span>
<span class="sd">            rho: Boolean. Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of R_mid. Default is False (return major radius, R_mid).</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to R_mid. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit: String or 1. Length unit that R_mid is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_mid returned in meters).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            R_mid: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. R_mid will have the same shape as t and</span>
<span class="sd">                psi_norm (or whichever one is Array-like).</span>
<span class="sd">            time_idxs: Array with same shape as R_mid. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single R_mid value for psinorm=0.7, t=0.26s:</span>
<span class="sd">        R_mid_val = Eq_instance.psinorm2rmid(0.7, 0.26)</span>

<span class="sd">        Find R_mid values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">        t=0.26s. Note that the Z vector must be fully specified, even if the</span>
<span class="sd">        values are all the same:</span>
<span class="sd">        R_mid_arr = Eq_instance.psinorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">        Find R_mid values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</span>
<span class="sd">        R_mid_arr = Eq_instance.psinorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">        Find R_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</span>
<span class="sd">        R_mid_arr = Eq_instance.psinorm2rmid([0.6, 0.5], [0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">psi_norm_proc</span><span class="p">,</span>
         <span class="n">dum</span><span class="p">,</span>
         <span class="n">t_proc</span><span class="p">,</span>
         <span class="n">time_idxs</span><span class="p">,</span>
         <span class="n">original_shape</span><span class="p">,</span>
         <span class="n">single_val</span><span class="p">,</span>
         <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># Handling for single-value case:</span>
        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">psi_norm_proc</span> <span class="o">=</span> <span class="n">psi_norm</span>
        
        <span class="c"># Convert units from meters to desired target:</span>
        <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span>
                                                <span class="n">psi_norm_proc</span><span class="p">,</span>
                                                <span class="n">time_idxs</span><span class="p">,</span>
                                                <span class="n">psi_norm</span><span class="p">,</span>
                                                <span class="n">t</span><span class="p">,</span>
                                                <span class="n">return_t</span><span class="o">=</span><span class="n">return_t</span><span class="p">,</span>
                                                <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span>
                                                <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized volume corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            psi_norm: Array-like or scalar float. Values of the normalized</span>
<span class="sd">                poloidal flux to map to normalized volume. If psi_norm is a</span>
<span class="sd">                scalar, it is used as the value for all of the values in t.</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of psi_norm. If neither t nor psi_norm</span>
<span class="sd">                are scalars, t must have the same shape as psi_norm.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (volnorm,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating volnorm with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return volnorm).</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to volnorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            volnorm: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. volnorm will have the same shape as t and</span>
<span class="sd">                psi_norm (or whichever one is Array-like).</span>
<span class="sd">            time_idxs: Array with same shape as volnorm. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single volnorm value for psinorm=0.7, t=0.26s:</span>
<span class="sd">        volnorm_val = Eq_instance.psinorm2volnorm(0.7, 0.26)</span>

<span class="sd">        Find volnorm values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">        t=0.26s. Note that the Z vector must be fully specified, even if the</span>
<span class="sd">        values are all the same:</span>
<span class="sd">        volnorm_arr = Eq_instance.psinorm2volnorm([0.5, 0.7], 0.26)</span>

<span class="sd">        Find volnorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</span>
<span class="sd">        volnorm_arr = Eq_instance.psinorm2volnorm(0.5, [0.2, 0.3])</span>

<span class="sd">        Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</span>
<span class="sd">        volnorm_arr = Eq_instance.psinorm2volnorm([0.6, 0.5], [0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">psi_norm_proc</span><span class="p">,</span>
         <span class="n">dum</span><span class="p">,</span>
         <span class="n">t_proc</span><span class="p">,</span>
         <span class="n">time_idxs</span><span class="p">,</span>
         <span class="n">original_shape</span><span class="p">,</span>
         <span class="n">single_val</span><span class="p">,</span>
         <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># Handling for single-value case:</span>
        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">psi_norm_proc</span> <span class="o">=</span> <span class="n">psi_norm</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="n">psi_norm_proc</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="n">return_t</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.psinorm2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            psi_norm: Array-like or scalar float. Values of the normalized</span>
<span class="sd">                poloidal flux to map to normalized toroidal flux. If psi_norm</span>
<span class="sd">                is a scalar, it is used as the value for all of the values in t.</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of psi_norm. If neither t nor psi_norm</span>
<span class="sd">                are scalars, t must have the same shape as psi_norm.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (phinorm,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating phinorm with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return phinorm).</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to phinorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            phinorm: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. phinorm will have the same shape as t and</span>
<span class="sd">                psi_norm (or whichever one is Array-like).</span>
<span class="sd">            time_idxs: Array with same shape as phinorm. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single phinorm value for psinorm=0.7, t=0.26s:</span>
<span class="sd">        phinorm_val = Eq_instance.psinorm2phinorm(0.7, 0.26)</span>

<span class="sd">        Find phinorm values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">        t=0.26s. Note that the Z vector must be fully specified, even if the</span>
<span class="sd">        values are all the same:</span>
<span class="sd">        phinorm_arr = Eq_instance.psinorm2phinorm([0.5, 0.7], 0.26)</span>

<span class="sd">        Find phinorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]:</span>
<span class="sd">        phinorm_arr = Eq_instance.psinorm2phinorm(0.5, [0.2, 0.3])</span>

<span class="sd">        Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):</span>
<span class="sd">        phinorm_arr = Eq_instance.psinorm2phinorm([0.6, 0.5], [0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">psi_norm_proc</span><span class="p">,</span>
         <span class="n">dum</span><span class="p">,</span>
         <span class="n">t_proc</span><span class="p">,</span>
         <span class="n">time_idxs</span><span class="p">,</span>
         <span class="n">original_shape</span><span class="p">,</span>
         <span class="n">single_val</span><span class="p">,</span>
         <span class="n">single_time</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># Handling for single-value case:</span>
        <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="n">psi_norm_proc</span> <span class="o">=</span> <span class="n">psi_norm</span>

            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="n">psi_norm_proc</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="n">return_t</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>

    <span class="c">###########################</span>
    <span class="c"># Backend Mapping Drivers #</span>
    <span class="c">###########################</span>
</div>
    <span class="k">def</span> <span class="nf">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert psinorm to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for computing a variety of quantities given psi_norm</span>
<span class="sd">        and the relevant time indices.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func: Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            psi_norm: Array or scalar float. psi_norm values to evaluate at.</span>
<span class="sd">            time_idxs: Array or scalar float. Time indices for each of the</span>
<span class="sd">                psi_norm values. Shape must match that of psi_norm.</span>
<span class="sd">            x: Array or scalar float. Representative spatial array that</span>
<span class="sd">                psi_norm and time_idxs was formed from (used to determine</span>
<span class="sd">                output shape).</span>
<span class="sd">            t: Array or scalar float. Representative time array that psi_norm</span>
<span class="sd">                and time_idxs was formed from (used to determine output shape).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (Quan,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating Quan with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return Quan).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of the quantity</span>
<span class="sd">                obtained from spline_func. Only the square root of positive</span>
<span class="sd">                values is taken. Negative values are replaced with zeros,</span>
<span class="sd">                consistent with Steve Wolfe&#39;s IDL implementation efit_rz2rho.pro.</span>
<span class="sd">                Default is False (return Quan itself).</span>
<span class="sd">            rho: Boolean. Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of R_mid. Default is False (return major radius, R_mid).</span>
<span class="sd">                Note that this will have unexpected results if spline_func</span>
<span class="sd">                returns anything other than R_mid.</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to Quan. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Quan will have the same shape as t and</span>
<span class="sd">                psi_norm (or whichever one is Array-like).</span>
<span class="sd">            time_idxs: Array with same shape as Quan. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Handle single value case properly:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">single_value</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">psi_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">psi_norm</span><span class="p">])</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time_idxs</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_value</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Check for single time for speedy evaluation of these cases:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">psi_norm</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">psi_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)(</span><span class="n">psi_norm</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="p">((</span><span class="n">quan_norm</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                                 <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psi_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">)):</span>
                    <span class="n">quan_norm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)(</span><span class="n">psi_norm</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                        <span class="n">quan_norm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">quan_norm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                                        <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                                           <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">[</span><span class="n">k</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">psi_norm</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="c">#time_idxs is set to None</span>
            <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMagRSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">quan_norm</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidOutSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span>

        <span class="c"># Restore original shape:</span>
        <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
 
        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">quan_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">quan_norm</span>

        <span class="k">if</span> <span class="n">single_value</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 
        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert RZ to a given quantity.</span>
<span class="sd">        </span>
<span class="sd">        Utility function for converting R, Z coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular phi_norm, vol_norm and R_mid.</span>
<span class="sd">        </span>
<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            spline_func: Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate to</span>
<span class="sd">                map to Quan. If R and Z are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in t. Must have</span>
<span class="sd">                the same shape as Z unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate to</span>
<span class="sd">                map to Quan. If R and Z are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in t. Must have</span>
<span class="sd">                the same shape as R unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            return_t: Boolean. Set to True to return a tuple of (Quan,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return Quan).</span>
<span class="sd">            sqrt: Boolean. Set to True to return the square root of Quan. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho: Boolean. Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of R_mid. Default is False (return major radius, R_mid).</span>
<span class="sd">                Note that this will have unexpected results if spline_func</span>
<span class="sd">                returns anything other than R_mid.</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to Quan. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                Quand has this shape as well. If the make_grid keyword was True</span>
<span class="sd">                then R_mid has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as R_mid. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        All assume that Eq_instance is a valid instance of the appropriate</span>
<span class="sd">        extension of the Equilibrium abstract class.</span>

<span class="sd">        Find single R_mid value at R=0.6m, Z=0.0m, t=0.26s:</span>
<span class="sd">        R_mid_val = Eq_instance.rz2rmid(0.6, 0, 0.26)</span>

<span class="sd">        Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">        single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">        even if the values are all the same:</span>
<span class="sd">        R_mid_arr = Eq_instance.rz2rmid([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">        Find R_mid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]:</span>
<span class="sd">        R_mid_arr = Eq_instance.rz2rmid(0.6, 0, [0.2, 0.3])</span>

<span class="sd">        Find R_mid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):</span>
<span class="sd">        R_mid_arr = Eq_instance.rz2rmid([0.6, 0.5], [0, 0.2], [0.2, 0.3])</span>

<span class="sd">        Find R_mid values on grid defined by 1D vector of radial positions R</span>
<span class="sd">        and 1D vector of vertical positions Z at time t=0.2s:</span>
<span class="sd">        R_mid_mat = Eq_instance.rz2rmid(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="n">sqrt</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="n">spline_func</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="n">return_t</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="n">sqrt</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>

    <span class="c">####################</span>
    <span class="c"># Helper Functions #</span>
    <span class="c">####################</span>

    <span class="k">def</span> <span class="nf">_getLengthConversionFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the conversion factor to convert from units start to units end.</span>
<span class="sd">        </span>
<span class="sd">        Uses a regex to parse units of the form:</span>
<span class="sd">        &#39;m&#39;</span>
<span class="sd">        &#39;m^2&#39;</span>
<span class="sd">        &#39;m2&#39;</span>
<span class="sd">        Leading and trailing spaces are NOT allowed.</span>
<span class="sd">        </span>
<span class="sd">        Valid unit specifiers are:</span>
<span class="sd">            &#39;m&#39;         meters</span>
<span class="sd">            &#39;cm&#39;        centimeters</span>
<span class="sd">            &#39;mm&#39;        millimeters</span>
<span class="sd">            &#39;in&#39;        inches</span>
<span class="sd">            &#39;ft&#39;        feet</span>
<span class="sd">            &#39;yd&#39;        yards</span>
<span class="sd">            &#39;smoot&#39;     smoots</span>
<span class="sd">            &#39;cubit&#39;     cubits</span>
<span class="sd">            &#39;hand&#39;      hands</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            start: String, int or None. Starting unit for the conversion.</span>
<span class="sd">                - If None, uses the unit specified when the instance was created.</span>
<span class="sd">                - If start is an int, the starting unit is taken to be the unit</span>
<span class="sd">                    specified when the instance was created raised to that power.</span>
<span class="sd">                - If start is &#39;default&#39;, either explicitly or because of</span>
<span class="sd">                    reverting to the instance-level unit, then the value passed</span>
<span class="sd">                    in the kwarg default is used. In this case, default must be</span>
<span class="sd">                    a complete unit string (i.e., not None, not an int and not</span>
<span class="sd">                    &#39;default&#39;).</span>
<span class="sd">                - Otherwise, start must be a valid unit specifier as given above.</span>
<span class="sd">            end: String, int or None. Target (ending) unit for the conversion.</span>
<span class="sd">                - If None, uses the unit specified when the instance was created.</span>
<span class="sd">                - If end is an int, the target unit is taken to be the unit</span>
<span class="sd">                    specified when the instance was created raised to that power.</span>
<span class="sd">                - If end is &#39;default&#39;, either explicitly or because of</span>
<span class="sd">                    reverting to the instance-level unit, then the value passed</span>
<span class="sd">                    in the kwarg default is used. In this case, default must be</span>
<span class="sd">                    a complete unit string (i.e., not None, not an int and not</span>
<span class="sd">                    &#39;default&#39;).</span>
<span class="sd">                - Otherwise, end must be a valid unit specifier as given above.</span>
<span class="sd">                    In this case, if end does not specify an exponent, it uses</span>
<span class="sd">                    whatever the exponent on start is. This allows a user to</span>
<span class="sd">                    ask for an area in units of m^2 by specifying</span>
<span class="sd">                    length_unit=&#39;m&#39;, for instance. An error will still be</span>
<span class="sd">                    raised if the user puts in a completely inconsistent</span>
<span class="sd">                    specification such as length_unit=&#39;m^3&#39; or length_unit=&#39;m^1&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            default: String, int or None. The default unit to use in cases</span>
<span class="sd">                where start or end is &#39;default&#39;. If default is None, an int, or </span>
<span class="sd">                &#39;default&#39;, then the value given for start is used. (A circular</span>
<span class="sd">                definition is prevented for cases in which start is default by</span>
<span class="sd">                checking for this case during the handling of the case</span>
<span class="sd">                start==&#39;default&#39;.)</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Conversion factor: Scalar float. The conversion factor to get from</span>
<span class="sd">                the start unit to the end unit.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If start is &#39;default&#39; and default is None, an int, or</span>
<span class="sd">                &#39;default&#39;.</span>
<span class="sd">            ValueError: If the (processed) exponents of start and end or start</span>
<span class="sd">                and default are incompatible.</span>
<span class="sd">            ValueError: If the processed units for start and end are not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Input handling:</span>
        <span class="c"># Starting unit:</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># If start is None, it means to use the instance&#39;s default unit (implied to the power of 1):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="c"># If start is an integer type, this is used as the power applied to the instance&#39;s default unit:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">!=</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">+</span> <span class="s">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If the instance&#39;s default unit is &#39;default&#39;, this is handled next:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
            <span class="c"># If start is &#39;default&#39;, the thing passed to default is used, but only if it is a complete unit specification:</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">default</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;You must specify a complete unit (i.e., &quot;</span>
                                 <span class="s">&quot;non-None, non-integer and not &#39;default&#39;) &quot;</span>
                                 <span class="s">&quot;when using &#39;default&#39; for the starting unit.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">default</span>
        
        <span class="c"># Default unit:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">default</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
            <span class="c"># If start is &#39;default&#39;, these cases have already been caught above.</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">start</span>
        
        <span class="c"># Target (ending) unit:</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># If end is None, it means to use the instance&#39;s default unit (implied to the power of 1):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="c"># If end is an integer type, this is used as the power applied to the instance&#39;s default unit:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">!=</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">+</span> <span class="s">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If the instance&#39;s default unit is &#39;default&#39;, this is handled next:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
            <span class="c"># If end is &#39;default&#39;, the thing passed to default is used, which</span>
            <span class="c"># defaults to start, which itself is not allowed to be &#39;default&#39;:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">default</span>
        
        <span class="n">unit_regex</span> <span class="o">=</span> <span class="s">r&#39;^([A-Za-z]+)\^?([0-9]*)$&#39;</span>
        
        <span class="c"># Need to explicitly cast because MDSplus returns its own classes and</span>
        <span class="c"># re.split doesn&#39;t seem to handle the polymorphism properly:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        
        <span class="n">dum1</span><span class="p">,</span> <span class="n">start_u</span><span class="p">,</span> <span class="n">start_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">dum1</span><span class="p">,</span> <span class="n">end_u</span><span class="p">,</span> <span class="n">end_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">dum1</span><span class="p">,</span> <span class="n">default_u</span><span class="p">,</span> <span class="n">default_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        
        <span class="n">start_pow</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">start_pow</span> <span class="o">==</span> <span class="s">&#39;&#39;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">start_pow</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_pow</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">end_pow</span> <span class="o">=</span> <span class="n">start_pow</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_pow</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_pow</span><span class="p">)</span>
        <span class="n">default_pow</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">default_pow</span> <span class="o">==</span> <span class="s">&#39;&#39;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">default_pow</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">start_pow</span> <span class="o">!=</span> <span class="n">end_pow</span> <span class="ow">or</span> <span class="n">start_pow</span> <span class="o">!=</span> <span class="n">default_pow</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Incompatible exponents between &#39;</span><span class="si">%s</span><span class="s">&#39;, &#39;</span><span class="si">%s</span><span class="s">&#39; and &#39;</span><span class="si">%s</span><span class="s">&#39;!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">_length_conversion</span><span class="p">[</span><span class="n">start_u</span><span class="p">][</span><span class="n">end_u</span><span class="p">])</span><span class="o">**</span><span class="n">start_pow</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unit &#39;</span><span class="si">%s</span><span class="s">&#39; is not a recognized length unit!&quot;</span> <span class="o">%</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_processRZt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Input checker/processor.</span>
<span class="sd">        </span>
<span class="sd">        Takes R, Z and t. Appropriately packages them into scipy arrays. Checks</span>
<span class="sd">        the validity of the R, Z ranges. If there is a single time value but</span>
<span class="sd">        multiple R, Z values, creates matching time vector. If there is a single</span>
<span class="sd">        R, Z value but multiple t values, creates matching R and Z vectors.</span>
<span class="sd">        Finds list of nearest-neighbor time indices.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array-like or scalar float. Values of the radial coordinate. If</span>
<span class="sd">                R and Z are both scalar values, they are used as the coordinate</span>
<span class="sd">                pair for all of the values in t. Must have the same shape as Z</span>
<span class="sd">                unless the make_grid keyword is set. If the make_grid keyword</span>
<span class="sd">                is True, R must have shape (len_R,).</span>
<span class="sd">            Z: Array-like or scalar float. Values of the vertical coordinate.</span>
<span class="sd">                If R and Z are both scalar values, they are used as the</span>
<span class="sd">                coordinate pair for all of the values in t. Must have the same</span>
<span class="sd">                shape as R unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t: Array-like or single value. If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            make_grid: Boolean. Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            check_space: Boolean. If True, R and Z are converted to meters and</span>
<span class="sd">                checked against the extents of the spatial grid.</span>
<span class="sd">            length_unit: String or 1. Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            R: Flattened R array with out-of-range values replaced with NaN.</span>
<span class="sd">            Z: Flattened Z array with out-of-range values replaced with NaN.</span>
<span class="sd">            t: Flattened t array with out-of-range values replaced with NaN.</span>
<span class="sd">            time_idxs: Flattened array of nearest-neighbor time indices.</span>
<span class="sd">            original_shape: Original shape tuple, used to return the arrays to</span>
<span class="sd">                their starting form.</span>
<span class="sd">            single_val: Boolean indicating whether a single point is used. If</span>
<span class="sd">                True, then the final step of the calling code should unpack the</span>
<span class="sd">                result from the array.</span>
<span class="sd">            single_time: Boolean indicating whether a single time value is used.</span>
<span class="sd">                If True, then certain simplifying steps can be made.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Handle single-value form of R and Z:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Z</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c"># Cast into scipy.array so we can handle list inputs:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c"># Make the grid, if called for:</span>
        <span class="k">if</span> <span class="n">make_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;_processRZt: When using the make_grid keyword, the &#39;</span>
                                 <span class="s">&#39;number of dimensions of R and Z must both be one!&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;_processRZt: Shape of R and Z arrays must match!&#39;</span><span class="p">)</span>

        <span class="c"># Check that R, Z points are fine:</span>
        <span class="k">if</span> <span class="n">check_space</span><span class="p">:</span>
            <span class="c"># Convert units to meters:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="n">length_unit</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">R</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">Z</span>
            
            <span class="n">good_points</span><span class="p">,</span> <span class="n">num_good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkRZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">num_good</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;_processRZt: No valid points!&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">single_val</span><span class="p">:</span>
                <span class="c"># Mask out the bad points here so we don&#39;t interfere with the</span>
                <span class="c"># single-value case (which must be valid to have made it past the</span>
                <span class="c"># test above):</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">~</span><span class="n">good_points</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">~</span><span class="n">good_points</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c"># Handle single-value time cases:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_time</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="c"># Handle case where there is a single R/Z but multiple t:</span>
            <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">Z</span>

        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">make_grid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;_processRZt: shape of t does not match shape of R &#39;</span>
                                 <span class="s">&#39;and Z. Recall that use of the make_grid &#39;</span>
                                 <span class="s">&#39;keyword requires that t either be a single &#39;</span>
                                 <span class="s">&#39;value, or that its shape matches that of &#39;</span>
                                 <span class="s">&#39;scipy.meshgrid(R, Z).&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;_processRZt: t must either be a single number, &#39;</span>
                                 <span class="s">&#39;or must match the shape of R and Z!&#39;</span><span class="p">)</span>

        <span class="c"># Handle non-vector array inputs: store the shape, then flatten the arrays.</span>
        <span class="c"># Don&#39;t bother with a test/flag -- just use the shape vector at the end.</span>
        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># takes keyword to bypass for tricubic interpolation</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>
            <span class="c"># Set up times to use -- essentially use nearest-neighbor interpolation</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getNearestIdx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timebase</span><span class="p">)</span>
            <span class="c"># Check errors and warn if needed:</span>
            <span class="n">t_errs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">timebase</span><span class="p">[</span><span class="n">time_idxs</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">timebase</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t_errs</span> <span class="o">&gt;</span> <span class="n">scipy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">timebase</span><span class="p">))</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Some time points are off by more than 1/3 &quot;</span>
                              <span class="s">&quot;the EFIT point spacing. Using nearest-neighbor interpolation &quot;</span>
                              <span class="s">&quot;between time points. You may want to run EFIT on the timebase &quot;</span>
                              <span class="s">&quot;you need. Max error: </span><span class="si">%.3f</span><span class="s">s&quot;</span> <span class="o">%</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_errs</span><span class="p">),</span>
                              <span class="ne">RuntimeWarning</span><span class="p">)</span>

                <span class="c"># If a single time value is passed with multiple R, Z points, evaluate</span>
                <span class="c"># them all at that time point:</span>
            <span class="k">if</span> <span class="n">single_time</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">single_val</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">None</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">single_time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_checkRZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks whether or not the passed arrays of (R, Z) are within the bounds of the reconstruction data.</span>
<span class="sd">        </span>
<span class="sd">        Returns the mask array of booleans indicating the goodness of each point</span>
<span class="sd">        at the corresponding index. Raises warnings if there are no good_points</span>
<span class="sd">        and if there are some values out of bounds.</span>
<span class="sd">        </span>
<span class="sd">        Assumes R and Z are in meters and that the R and Z arrays returned by</span>
<span class="sd">        this instance&#39;s getRGrid() and getZGrid() are monotonically increasing.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R: Array. Radial coordinate to check. Must have the same size as Z.</span>
<span class="sd">            Z: Array. Vertical coordinate to check. Must have the same size as R.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            good_points: Boolean array. True where points are within the bounds</span>
<span class="sd">                defined by self.getRGrid and self.getZGrid.</span>
<span class="sd">            num_good: The number of good points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">good_points</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">R</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">Z</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">Z</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c"># Gracefully handle single-value versus array inputs, returning in the</span>
        <span class="c"># corresponding type.</span>
        <span class="n">num_good</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_points</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_good</span> <span class="o">=</span> <span class="n">good_points</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Warning: _checkRZ: No valid (R, Z) points!&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_good</span> <span class="o">!=</span> <span class="n">num_pts</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Warning: _checkRZ: Some (R, Z) values out of bounds. &quot;</span>
                          <span class="s">&quot;(</span><span class="si">%(bad)d</span><span class="s"> bad out of </span><span class="si">%(tot)d</span><span class="s">)&quot;</span>
                          <span class="o">%</span> <span class="p">{</span><span class="s">&#39;bad&#39;</span><span class="p">:</span> <span class="n">num_pts</span> <span class="o">-</span> <span class="n">num_good</span><span class="p">,</span> <span class="s">&#39;tot&#39;</span><span class="p">:</span> <span class="n">num_pts</span><span class="p">},</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">good_points</span><span class="p">,</span> <span class="n">num_good</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getNearestIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the array of indices of the nearest value in a corresponding to each value in v.</span>
<span class="sd">        </span>
<span class="sd">        If the fast keyword in the instance is True, then this is done using</span>
<span class="sd">        scipy.digitize under the assumption that a is monotonic. Otherwise,</span>
<span class="sd">        this is done in a general manner by looking for the minimum distance</span>
<span class="sd">        between the points in v and a.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            v: Array. Input values to match to nearest neighbors in a.</span>
<span class="sd">            a: Array. Given values to match against.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Indices in a of the nearest values to each value in v. Has the same</span>
<span class="sd">                shape as v.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Gracefully handle single-value versus array inputs, returning in the</span>
        <span class="c"># corresponding type.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">val</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">v</span><span class="p">,(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">SP</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">v</span><span class="p">),(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(())</span>

            

    <span class="k">def</span> <span class="nf">_getFluxBiSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the spline corresponding to the given time index, generating as needed.</span>
<span class="sd">        </span>
<span class="sd">        This returns a bivariate spline for when the instance is created with</span>
<span class="sd">        keyword tspline=False.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx: Scalar int. The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            An instance of scipy.interpolate.RectBivariateSpline corresponding</span>
<span class="sd">                to the given time index idx.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c"># Note the order of the arguments -- psiRZ is stored with t along</span>
            <span class="c"># the first dimension, Z along the second and R along the third.</span>
            <span class="c"># This leads to intuitive behavior when contour plotting, but</span>
            <span class="c"># mandates the syntax here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_getFluxTriSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the tricubic interpolating spline for the flux.</span>
<span class="sd">        </span>
<span class="sd">        This is for use when the instance is created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            trispline.spline to give the flux as a function of R, Z and t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">spline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span>

    <span class="k">def</span> <span class="nf">_getPhiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to phinorm.</span>
<span class="sd">        </span>
<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx: Scalar int. The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to phinorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c"># Insert zero at beginning because older versions of cumtrapz don&#39;t</span>
                <span class="c"># support the initial keyword to make the initial value zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[:,</span> <span class="n">idx</span><span class="p">]),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">)),</span>
                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Insert zero at beginning because older versions of cumtrapz don&#39;t</span>
                <span class="c"># support the initial keyword to make the initial value zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">(),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                                                                    <span class="n">bounds_error</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span>
                                                                        
    <span class="k">def</span> <span class="nf">_getVolNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to volnorm.</span>
<span class="sd">        </span>
<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx: Scalar int. The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to volnorm. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()[:,</span> <span class="n">idx</span><span class="p">]</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">)),</span>
                                                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                                                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#BiSpline for time variant interpolation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                                                                    <span class="n">bounds_error</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span>
                                                                        
    <span class="k">def</span> <span class="nf">_getRmidSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        There are two approaches that come to mind:</span>
<span class="sd">            -- In Steve Wolfe&#39;s implementation of efit_rz2mid and efit_psi2rmid,</span>
<span class="sd">                he uses the EFIT output Rmid as a function of normalized flux</span>
<span class="sd">                (i.e., what is returned by self.getRmidPsi()) in the core, then</span>
<span class="sd">                expands the grid beyond this manually.</span>
<span class="sd">            -- A simpler approach would be to just compute the psi_norm(R_mid)</span>
<span class="sd">                grid directly from the radial grid.</span>

<span class="sd">        The latter approach is selected for simplicity.</span>
<span class="sd">        </span>
<span class="sd">        The units of R_mid are always meters, and are converted by the wrapper</span>
<span class="sd">        functions to whatever the user wants.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx: Scalar int. The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from psinorm to R_mid. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d or tripline.RectBivariateSpline depending</span>
<span class="sd">                on whether or not the instance was created with the tspline</span>
<span class="sd">                keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c"># New approach: create a fairly dense radial grid from the global</span>
                <span class="c"># flux grid to avoid 1d interpolation problems in the core. The</span>
                <span class="c"># bivariate spline seems to be a little more robust in this respect.</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">resample_factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)))</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R_grid</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()[</span><span class="n">idx</span><span class="p">])</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">psi_norm_on_grid</span><span class="p">,</span>
                                                    <span class="n">R_grid</span><span class="p">,</span>
                                                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">kind</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">))</span>

            <span class="c">#generate timebase and R_grid through a meshgrid</span>
                <span class="n">t</span><span class="p">,</span><span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span><span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,)))</span>
                <span class="n">Z_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
                                   <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">R_grid</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                   <span class="n">resample_factor</span><span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R_grid</span><span class="p">,</span> <span class="n">Z_grid</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span><span class="n">psi_norm_on_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                           <span class="n">t</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                           <span class="n">R_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span>

    <span class="k">def</span> <span class="nf">_getPsi0Spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate psi0 as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to psi0. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to psi0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">(),</span>
                                                               <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                               <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span>

    <span class="k">def</span> <span class="nf">_getLCFSPsiSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate psi_a as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to psi_a. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to psi_a.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">(),</span>
                                                               <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                               <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span>

    <span class="k">def</span> <span class="nf">_getMagRSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate R_mag as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            length_unit: String or 1. Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to R_mag. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to R_mid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MagRSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MagRSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MagRSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                                                          <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                          <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MagRSpline</span>

    <span class="k">def</span> <span class="nf">_getRmidOutSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;cubic&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate R_out as a function of time.</span>
<span class="sd">        </span>
<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            length_unit: String or 1. Length unit that R_out is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind: String or non-negative int. Specifies the type of interpolation</span>
<span class="sd">                to be performed in getting from t to R_out. This is</span>
<span class="sd">                passed to scipy.interpolate.interp1d. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation). On</span>
<span class="sd">                some builds of scipy, this can cause problems, in which case</span>
<span class="sd">                you should try &#39;linear&#39; until you can rebuild your scipy install.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.interp1d to convert from t to R_out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                                                             <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                                             <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span>

<div class="viewcode-block" id="Equilibrium.getInfo"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getInfo">[docs]</a>    <span class="k">def</span> <span class="nf">getInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns namedtuple of instance parameters (shot, EFIT tree, size and timebase info)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getTimeBase"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getTimeBase">[docs]</a>    <span class="k">def</span> <span class="nf">getTimeBase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT time base array (t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns 3D grid of psi(r,z,t)</span>
        <span class="c"># The array returned should have the following dimensions:</span>
        <span class="c">#   First dimension: time</span>
        <span class="c">#   Second dimension: Z</span>
        <span class="c">#   Third dimension: R</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getRGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns vector of R-values for psirz grid (r)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getZGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getZGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getZGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns vector of Z-values for psirz grid (z)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxAxis"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxAxis">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns psi at magnetic axis as simagx(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns psi at separatrix, sibdry(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getRLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns R-positions mapping LCFS, rbbbs(t,n)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getZLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getZLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getZLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns Z-positions mapping LCFS, zbbbs(t,n)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxVol"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxVol">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxVol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns volume contained within a flux surface as function of psi, volp(psi,t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getVolLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getVolLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getVolLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns plasma volume in LCFS, vout(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRmidPsi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidPsi">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidPsi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns max major radius of flux surface, rpres(t,psi)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getFluxPres"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxPres">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxPres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated pressure p(psi,t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getElongation"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getElongation">[docs]</a>    <span class="k">def</span> <span class="nf">getElongation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns LCFS elongation, kappa(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getUpperTriangularity"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getUpperTriangularity">[docs]</a>    <span class="k">def</span> <span class="nf">getUpperTriangularity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns LCFS upper triangularity, delta_u(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getLowerTriangularity"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getLowerTriangularity">[docs]</a>    <span class="k">def</span> <span class="nf">getLowerTriangularity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns LCFS lower triangularity, delta_l(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getShaping"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getShaping">[docs]</a>    <span class="k">def</span> <span class="nf">getShaping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns dimensionless shaping parameters for plasma</span>
        <span class="c">#namedtuple containing {LCFS elongation, LCFS upper/lower triangularity)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMagR"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagR">[docs]</a>    <span class="k">def</span> <span class="nf">getMagR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns magnetic-axis major radius, rmagx(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMagZ"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagZ">[docs]</a>    <span class="k">def</span> <span class="nf">getMagZ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns magnetic-axis Z, zmagx(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getAreaLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAreaLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getAreaLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns LCFS surface area, areao(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getAOut"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAOut">[docs]</a>    <span class="k">def</span> <span class="nf">getAOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns outboard-midplane minor radius</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getRmidOut"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidOut">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns outboard-midplane major radius</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getGeometry"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getGeometry">[docs]</a>    <span class="k">def</span> <span class="nf">getGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns dimensional geometry parameters for plasma</span>
        <span class="c">#namedtuple containing {mag axis r,z, LCFS area, volume, outboard midplane major radius}</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQProfile"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQProfile">[docs]</a>    <span class="k">def</span> <span class="nf">getQProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns safety factor profile q(psi,t):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ0"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ0">[docs]</a>    <span class="k">def</span> <span class="nf">getQ0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns q-value on magnetic axis, q0(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ95"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ95">[docs]</a>    <span class="k">def</span> <span class="nf">getQ95</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns q at 95% flux, psib(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getQLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns q on LCFS, qout(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ1Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ1Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ1Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns outboard-midplane minor radius of q=1 surface, aaq1(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="Equilibrium.getQ2Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ2Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ2Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns outboard-midplane minor radius of q=2 surface, aaq2(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQ3Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ3Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ3Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns outboard-midplane minor radius of q=3 surface, aaq3(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getQs"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQs">[docs]</a>    <span class="k">def</span> <span class="nf">getQs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns specific q-profile values</span>
        <span class="c">#namedtuple containing {q0, q95, q(LCFS), minor radius of q=1,2,3 surfaces}</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBtVac"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtVac">[docs]</a>    <span class="k">def</span> <span class="nf">getBtVac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns vacuum on-axis toroidal field btaxv(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBtPla"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtPla">[docs]</a>    <span class="k">def</span> <span class="nf">getBtPla</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns plasma on-axis toroidal field btaxp(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBpAvg"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBpAvg">[docs]</a>    <span class="k">def</span> <span class="nf">getBpAvg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns avg poloidal field, bpolav(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span> 
</div>
<div class="viewcode-block" id="Equilibrium.getFields"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFields">[docs]</a>    <span class="k">def</span> <span class="nf">getFields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns magnetic-field measurements from EFIT</span>
        <span class="c">#dict containing {Btor on magnetic axis (plasma and vacuum), avg Bpol)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getIpCalc"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getIpCalc">[docs]</a>    <span class="k">def</span> <span class="nf">getIpCalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated plasma current</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getIpMeas"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getIpMeas">[docs]</a>    <span class="k">def</span> <span class="nf">getIpMeas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns measured plasma current</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getJp"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getJp">[docs]</a>    <span class="k">def</span> <span class="nf">getJp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns (r,z,t) grid of EFIT-calculated current density</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBetaT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetaT">[docs]</a>    <span class="k">def</span> <span class="nf">getBetaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns calculated toroidal beta, betat(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBetaP"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetaP">[docs]</a>    <span class="k">def</span> <span class="nf">getBetaP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns calculated avg poloidal beta, betap(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getLi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getLi">[docs]</a>    <span class="k">def</span> <span class="nf">getLi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns calculated internal inductance of plasma, ali(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getBetas"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetas">[docs]</a>    <span class="k">def</span> <span class="nf">getBetas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns calculated beta and inductive values</span>
        <span class="c">#namedtuple of {betat,betap,li}</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagFlux"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns diamagnetic flux, diamag(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagBetaT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagBetaT">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagBetaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns diamagnetic-loop toroidal beta, betatd(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagBetaP"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagBetaP">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagBetaP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns diamagnetic-loop poloidal beta, betapd(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagTauE"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagTauE">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagTauE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns diamagnetic-loop energy confinement time, taudia(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamagWp"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagWp">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagWp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns diamagnetic-loop plasma stored energy, wplasmd(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getDiamag"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamag">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns diamagnetic measurements of plasma parameters</span>
        <span class="c">#namedtuple of {diamag flux, betat,betap from diamag coils, tau_E from diamag, diamag stored energy)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getWMHD"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWMHD">[docs]</a>    <span class="k">def</span> <span class="nf">getWMHD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated MHD stored energy wplasm(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getTauMHD"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getTauMHD">[docs]</a>    <span class="k">def</span> <span class="nf">getTauMHD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated MHD energy confinement time taumhd(s)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getPinj"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getPinj">[docs]</a>    <span class="k">def</span> <span class="nf">getPinj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated injected power, pbinj(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getCurrentSign"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getCurrentSign">[docs]</a>    <span class="k">def</span> <span class="nf">getCurrentSign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated current direction, where counterclockwise = +</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getWbdot"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWbdot">[docs]</a>    <span class="k">def</span> <span class="nf">getWbdot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated d/dt of magnetic stored energy, wbdot(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getWpdot"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWpdot">[docs]</a>    <span class="k">def</span> <span class="nf">getWpdot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns EFIT-calculated d/dt of plasma stored energy, wpdot(t)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getEnergy"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getEnergy">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#returns stored-energy parameters</span>
        <span class="c">#dict of {stored energy, MHD tau_E, injected power, d/dt of magnetic, plasma stored energy)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getParam"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getParam">[docs]</a>    <span class="k">def</span> <span class="nf">getParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
        <span class="c">#backup function - takes parameter name for EFIT variable, returns that variable</span>
        <span class="c">#acts as wrapper for EFIT tree access from within object</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Equilibrium.getMachineCrossSection"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMachineCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getMachineCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;function to return machine cross-section not implemented for this class yet!&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Equilibrium.plotFlux"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.plotFlux">[docs]</a>    <span class="k">def</span> <span class="nf">plotFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots flux contours directly from psi grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">psiRZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()</span>
            <span class="n">rGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">zGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>

            <span class="n">RLCFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRLCFS</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">ZLCFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZLCFS</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMachineCrossSection</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;No machine cross-section implemented!&#39;</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&#39;cannot plot EFIT flux map.&#39;</span><span class="p">)</span>

        <span class="c">#event handler for arrow key events in plot windows.  Pass slider object</span>
        <span class="c">#to update as masked argument using lambda function</span>
        <span class="c">#lambda evt: arrow_respond(my_slider,evt)</span>
        <span class="k">def</span> <span class="nf">arrowRespond</span><span class="p">(</span><span class="n">slider</span><span class="p">,</span><span class="n">event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmax</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmin</span><span class="p">))</span>

        <span class="c">#make time-slice window</span>
        <span class="n">fluxPlot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">psi</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">timeSliderSub</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">updateTime</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="n">psi</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">t_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timeSlider</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s">&#39;EFIT Reconstruction, $t = </span><span class="si">%(t).2f</span><span class="s">$ s&#39;</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;t&#39;</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]})</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;$R$ [m]&#39;</span><span class="p">)</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;$Z$ [m]&#39;</span><span class="p">)</span>
            <span class="n">machine</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">RLCFS</span><span class="p">[:,</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">RLCFSframe</span> <span class="o">=</span> <span class="n">RLCFS</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_idx</span><span class="p">]</span>
            <span class="n">ZLCFSframe</span> <span class="o">=</span> <span class="n">ZLCFS</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_idx</span><span class="p">]</span>
            <span class="n">LCFS</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">RLCFSframe</span><span class="p">,</span><span class="n">ZLCFSframe</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">fillcont</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span><span class="n">zGrid</span><span class="p">,</span><span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span><span class="n">zGrid</span><span class="p">,</span><span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span><span class="mi">50</span><span class="p">,</span><span class="n">colors</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="n">linestyles</span><span class="o">=</span><span class="s">&#39;solid&#39;</span><span class="p">)</span>
            <span class="n">fluxPlot</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

            <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">print</span> <span class="s">&#39;elapsed time: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>

        <span class="n">timeSlider</span> <span class="o">=</span> <span class="n">mplw</span><span class="o">.</span><span class="n">Slider</span><span class="p">(</span><span class="n">timeSliderSub</span><span class="p">,</span><span class="s">&#39;t index&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">valinit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">valfmt</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">timeSlider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">updateTime</span><span class="p">)</span>
        <span class="n">updateTime</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">fluxPlot</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">evt</span><span class="p">:</span> <span class="n">arrowRespond</span><span class="p">(</span><span class="n">timeSlider</span><span class="p">,</span> <span class="n">evt</span><span class="p">))</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">eqtools 0.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Mark Chilenski, Ian Faust and John Walk.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>