
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>eqtools.core &#8212; eqtools 1.3.2 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">eqtools 1.3.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for eqtools.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># This program is distributed under the terms of the GNU General Purpose License (GPL).</span>
<span class="c1"># Refer to http://www.gnu.org/licenses/gpl.txt</span>
<span class="c1">#</span>
<span class="c1"># This file is part of eqtools.</span>
<span class="c1">#</span>
<span class="c1"># eqtools is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># eqtools is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with eqtools.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;This module provides the core classes for :py:mod:`eqtools`, including the</span>
<span class="sd">base :py:class:`Equilibrium` class.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="c1"># Python 2/3 cross compatibility:</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="c1"># Constants to determine how plot labels are formatted:</span>
<span class="n">B_LABEL</span> <span class="o">=</span> <span class="s1">&#39;$B$ [T]&#39;</span>
<span class="n">J_LABEL</span> <span class="o">=</span> <span class="s1">&#39;$j$ [MA/m$^2$]&#39;</span>


<div class="viewcode-block" id="ModuleWarning"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.ModuleWarning">[docs]</a><span class="k">class</span> <span class="nc">ModuleWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning class to notify the user of unavailable modules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">trispline</span>
    <span class="n">_has_trispline</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;trispline module could not be loaded -- tricubic spline &quot;</span>
                  <span class="s2">&quot;interpolation will not be available.&quot;</span><span class="p">,</span>
                  <span class="n">ModuleWarning</span><span class="p">)</span>
    <span class="n">_has_trispline</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">matplotlib.widgets</span> <span class="k">as</span> <span class="nn">mplw</span>
    <span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">mplgs</span>
    <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
    <span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
    <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span>
    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="k">import</span> <span class="n">make_axes_locatable</span>
    <span class="kn">from</span> <span class="nn">matplotlib.colorbar</span> <span class="k">import</span> <span class="n">ColorbarBase</span>
    <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">Normalize</span>
    <span class="kn">from</span> <span class="nn">.filewriter</span> <span class="k">import</span> <span class="n">gfile</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;matplotlib modules could not be loaded -- plotting and gfile&quot;</span>
        <span class="s2">&quot; writing will not be available.&quot;</span><span class="p">,</span>
        <span class="n">ModuleWarning</span>
    <span class="p">)</span>


<div class="viewcode-block" id="PropertyAccessMixin"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.PropertyAccessMixin">[docs]</a><span class="k">class</span> <span class="nc">PropertyAccessMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin to implement access of getter methods through a property-type</span>
<span class="sd">    interface without the need to apply a decorator to every property.</span>

<span class="sd">    For any getter `obj.getSomething()`, the call `obj.Something` will do the</span>
<span class="sd">    same thing.</span>

<span class="sd">    This is accomplished by overriding :py:meth:`__getattribute__` such that if</span>
<span class="sd">    an attribute `ATTR` does not exist it then attempts to call `self.getATTR()`.</span>
<span class="sd">    If `self.getATTR()` does not exist, an :py:class:`AttributeError` will be</span>
<span class="sd">    raised as usual.</span>

<span class="sd">    Also overrides :py:meth:`__setattr__` such that it will raise an</span>
<span class="sd">    :py:class:`AttributeError` when attempting to write an attribute `ATTR` for</span>
<span class="sd">    which there is already a method `getATTR`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an attribute.</span>

<span class="sd">        Tries to get attribute as-written. If this fails, tries to call the</span>
<span class="sd">        method `get&lt;name&gt;` with no arguments. If this fails, raises</span>
<span class="sd">        :py:class:`AttributeError`. This effectively generates a Python</span>
<span class="sd">        &#39;property&#39; for each getter method.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (String): Name of the attribute to retrieve. If the instance</span>
<span class="sd">                has an attribute with this name, the attribute is returned. If</span>
<span class="sd">                the instance does not have an attribute with this name but does</span>
<span class="sd">                have a method called &#39;get&#39;+name, this method is called and the</span>
<span class="sd">                result is returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The value of the attribute requested.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If neither attribute name or method &#39;get&#39;+name exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">)()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%(class)s</span><span class="s2"> object has no attribute &#39;</span><span class="si">%(n)s</span><span class="s2">&#39; or method &#39;get</span><span class="si">%(n)s</span><span class="s2">&#39;&quot;</span>
                    <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an attribute.</span>

<span class="sd">        Raises :py:class:`AttributeError` if the object already has a method</span>
<span class="sd">        &#39;get&#39;+name, as creation of such an attribute would interfere with the</span>
<span class="sd">        automatic property generation in :py:meth:`__getattribute__`.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (String): Name of the attribute to set.</span>
<span class="sd">            value (Object): Value to set the attribute to.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If a method called &#39;get&#39;+name already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%(class)s</span><span class="s2"> object already has getter method &#39;get</span><span class="si">%(n)s</span><span class="s2">&#39;, creating &quot;</span>
                <span class="s2">&quot;attribute &#39;</span><span class="si">%(n)s</span><span class="s2">&#39; will conflict with automatic property &quot;</span>
                <span class="s2">&quot;generation.&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Equilibrium</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;The following is a dictionary to implement length unit conversions. The first</span>
<span class="sd">key is the unit are converting FROM, the second the unit you are converting TO.</span>
<span class="sd">Supports: m, cm, mm, in, ft, yd, smoot, cubit, hand</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">_length_conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
                            <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">,</span>
                            <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span><span class="p">,</span>
                            <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                            <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                            <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                            <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                            <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">),</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">67.0</span><span class="p">),</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">18.0</span><span class="p">),</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)},</span>
                      <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">),</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">67.0</span><span class="p">),</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">18.0</span><span class="p">),</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">39.37</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)},</span>
                      <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                             <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span><span class="p">,</span>
                             <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>
                             <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                             <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                             <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">67.0</span><span class="p">,</span>
                                <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                                <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                                <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                                <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">67.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                                <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">18.0</span><span class="p">,</span>
                                <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                                <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                                <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                                <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">},</span>
                      <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s1">&#39;mm&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">39.37</span><span class="p">,</span>
                               <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
                               <span class="s1">&#39;ft&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">,</span>
                               <span class="s1">&#39;yd&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">),</span>
                               <span class="s1">&#39;smoot&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">67.0</span><span class="p">,</span>
                               <span class="s1">&#39;cubit&#39;</span><span class="p">:</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">,</span>
                               <span class="s1">&#39;hand&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}}</span>


<div class="viewcode-block" id="inPolygon"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.inPolygon">[docs]</a><span class="k">def</span> <span class="nf">inPolygon</span><span class="p">(</span><span class="n">polyx</span><span class="p">,</span> <span class="n">polyy</span><span class="p">,</span> <span class="n">pointx</span><span class="p">,</span> <span class="n">pointy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function calculating whether a given point is within a 2D polygon.</span>

<span class="sd">    Given an array of X,Y coordinates describing a 2D polygon, checks whether a</span>
<span class="sd">    point given by x,y coordinates lies within the polygon. Operates via a</span>
<span class="sd">    ray-casting approach - the function projects a semi-infinite ray parallel to</span>
<span class="sd">    the positive horizontal axis, and counts how many edges of the polygon this</span>
<span class="sd">    ray intersects. For a simply-connected polygon, this determines whether the</span>
<span class="sd">    point is inside (even number of crossings) or outside (odd number of</span>
<span class="sd">    crossings) the polygon, by the Jordan Curve Theorem.</span>

<span class="sd">    Args:</span>
<span class="sd">        polyx (Array-like): Array of x-coordinates of the vertices of the polygon.</span>
<span class="sd">        polyy (Array-like): Array of y-coordinates of the vertices of the polygon.</span>
<span class="sd">        pointx (Int or float): x-coordinate of test point.</span>
<span class="sd">        pointy (Int or float): y-coordinate of test point.</span>

<span class="sd">    Returns:</span>
<span class="sd">        result (Boolean): True/False result for whether the point is contained within the polygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># generator function for &quot;lines&quot; - pairs of (x,y) coords describing each edge of the polygon.</span>
    <span class="k">def</span> <span class="nf">lines</span><span class="p">():</span>
        <span class="n">p0x</span> <span class="o">=</span> <span class="n">polyx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p0y</span> <span class="o">=</span> <span class="n">polyy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">(</span><span class="n">p0x</span><span class="p">,</span> <span class="n">p0y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polyx</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">polyy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>

    <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pointy</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pointy</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">pointx</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">pointy</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Equilibrium"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium">[docs]</a><span class="k">class</span> <span class="nc">Equilibrium</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class of data handling object for magnetic reconstruction outputs.</span>

<span class="sd">    Defines the mapping routines and method fingerprints necessary. Each</span>
<span class="sd">    variable or set of variables is recovered with a corresponding getter method.</span>
<span class="sd">    Essential data for mapping are pulled on initialization (psirz grid, for</span>
<span class="sd">    example) to frontload overhead. Additional data are pulled at the first</span>
<span class="sd">    request and stored for subsequent usage.</span>

<span class="sd">    .. note:: This abstract class should not be used directly. Device- and code-</span>
<span class="sd">        specific subclasses are set up to account for inter-device/-code</span>
<span class="sd">        differences in data storage.</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        length_unit (String): Sets the base unit used for any quantity whose</span>
<span class="sd">            dimensions are length to any power. Valid options are:</span>

<span class="sd">                ===========  ===========================================================================================</span>
<span class="sd">                &#39;m&#39;          meters</span>
<span class="sd">                &#39;cm&#39;         centimeters</span>
<span class="sd">                &#39;mm&#39;         millimeters</span>
<span class="sd">                &#39;in&#39;         inches</span>
<span class="sd">                &#39;ft&#39;         feet</span>
<span class="sd">                &#39;yd&#39;         yards</span>
<span class="sd">                &#39;smoot&#39;      smoots</span>
<span class="sd">                &#39;cubit&#39;      cubits</span>
<span class="sd">                &#39;hand&#39;       hands</span>
<span class="sd">                &#39;default&#39;    whatever the default in the tree is (no conversion is performed, units may be inconsistent)</span>
<span class="sd">                ===========  ===========================================================================================</span>

<span class="sd">            Default is &#39;m&#39; (all units taken and returned in meters).</span>
<span class="sd">        tspline (Boolean): Sets whether or not interpolation in time is</span>
<span class="sd">            performed using a tricubic spline or nearest-neighbor interpolation.</span>
<span class="sd">            Tricubic spline interpolation requires at least four complete</span>
<span class="sd">            equilibria at different times. It is also assumed that they are</span>
<span class="sd">            functionally correlated, and that parameters do not vary out of</span>
<span class="sd">            their boundaries (derivative = 0 boundary condition). Default is</span>
<span class="sd">            False (use nearest-neighbor interpolation).</span>
<span class="sd">        monotonic (Boolean): Sets whether or not the &quot;monotonic&quot; form of time</span>
<span class="sd">            window finding is used. If True, the timebase must be monotonically</span>
<span class="sd">            increasing. Default is False (use slower, safer method).</span>
<span class="sd">        verbose (Boolean): Allows or blocks console readout during operation.</span>
<span class="sd">            Defaults to True, displaying useful information for the user. Set to</span>
<span class="sd">            False for quiet usage or to avoid console clutter for multiple</span>
<span class="sd">            instances.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `length_unit` is not a valid unit specifier.</span>
<span class="sd">        ValueError: If `tspline` is True but module trispline did not load</span>
<span class="sd">            successfully.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">tspline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monotonic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">length_unit</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">length_unit</span> <span class="ow">in</span> <span class="n">_length_conversion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit &#39;</span><span class="si">%s</span><span class="s2">&#39; not a valid unit specifier!&quot;</span> <span class="o">%</span> <span class="n">length_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">=</span> <span class="n">length_unit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tspline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_monotonic</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">monotonic</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># These are indexes of splines, and become higher dimensional splines</span>
        <span class="c1"># with the setting of the tspline keyword.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of this instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string (String): String describing this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;This is an abstract class. Please use machine-specific subclass.&#39;</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes all of the stored splines, since they aren&#39;t pickleable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="c1">####################</span>
    <span class="c1"># Mapping routines #</span>
    <span class="c1">####################</span>

<div class="viewcode-block" id="Equilibrium.rho2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rho2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert from one coordinate to another.</span>

<span class="sd">        Args:</span>
<span class="sd">            origin (String): Indicates which coordinates the data are given in.</span>
<span class="sd">                Valid options are:</span>

<span class="sd">                    ======= ========================</span>
<span class="sd">                    RZ      R,Z coordinates</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    ======= ========================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            destination (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    q       Safety factor</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            rho (Array-like or scalar float): Values of the starting coordinate</span>
<span class="sd">                to map to the new coordinate. Will be two arguments `R`, `Z` if</span>
<span class="sd">                `origin` is &#39;RZ&#39;.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `rho`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `rho` (or the meshgrid of `R`</span>
<span class="sd">                and `Z` if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of `rho`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `rho` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `rho` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `rho` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            make_grid (Boolean): Only applicable if `origin` is &#39;RZ&#39;. Set to</span>
<span class="sd">                True to pass `R` and `Z` through :py:func:`scipy.meshgrid`</span>
<span class="sd">                before evaluating. If this is set to True, `R` and `Z` must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                Default is False (do not form meshgrid).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid when `destination` is Rmid. Default is False</span>
<span class="sd">                (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that quantities are</span>
<span class="sd">                given/returned in, as applicable. If a string is given, it must</span>
<span class="sd">                be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `origin` is not one of the supported values.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at r/a=0.6, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>

<span class="sd">                psi_arr = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.rho2rho(&#39;r/a&#39;, &#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">origin</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">destination</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">destination</span> <span class="o">=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;RZ&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2rho</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;rho2rho: Unsupported origin coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">origin</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2psi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2psi">[docs]</a>    <span class="k">def</span> <span class="nf">rz2psi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts the passed R, Z, t arrays to psi (unnormalized poloidal flux) values.</span>

<span class="sd">        What is usually returned by EFIT is the stream function,</span>
<span class="sd">        :math:`\psi=\psi_p/(2\pi)` which has units of Wb/rad.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to poloidal flux. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to poloidal flux. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psi` or (`psi`, `time_idxs`)</span>

<span class="sd">            * **psi** (`Array or scalar float`) - The unnormalized poloidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `psi` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `psi` has</span>
<span class="sd">              shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psi`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psi value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.rz2psi(0.6, 0, 0.26)</span>

<span class="sd">            Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psi([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find psi values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psi(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psi([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find psi values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                psi_mat = Eq_instance.rz2psi(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check inputs and process into flat arrays with units of meters:</span>
        <span class="p">(</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
            <span class="n">original_shape</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span>
            <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
            <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
            <span class="n">compute_unique</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxTriSpline</span><span class="p">()</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">),</span>
                <span class="n">original_shape</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">out_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),</span> <span class="p">],</span> <span class="n">original_shape</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span>
                        <span class="n">t_idx</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="n">unique_idxs</span><span class="p">:</span>
                    <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_idxs</span> <span class="o">==</span> <span class="n">t_idx</span><span class="p">)</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span>
                        <span class="n">t_idx</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">t_mask</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">t_mask</span><span class="p">])</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

        <span class="c1"># Correct for current sign:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">out_vals</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_vals</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_vals</span><span class="p">,</span> <span class="p">(</span>
                    <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                    <span class="n">original_shape</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_vals</span></div>

<div class="viewcode-block" id="Equilibrium.rz2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux at the given (R, Z, t).</span>

<span class="sd">        Uses the definition:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to psinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to psinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>

<span class="sd">            * **psinorm** (`Array or scalar float`) - The normalized poloidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `psinorm` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `psinorm`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.rz2psinorm(0.6, 0, 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psinorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psinorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.rz2psinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find psinorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                psi_mat = Eq_instance.rz2psinorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">psi</span><span class="p">,</span> <span class="n">blob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psi</span><span class="p">(</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">return_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span>
            <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
            <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">psi_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLCFSPsiSpline</span><span class="p">()(</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">psi_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPsi0Spline</span><span class="p">()(</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psi_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()[</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">psi_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()[</span><span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># If there is more than one time point, we need to expand these</span>
            <span class="c1"># arrays to be broadcastable:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">each_t</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                        <span class="n">psi_boundary</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">psi_boundary</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">psi_0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">psi_0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">psi_boundary</span> <span class="o">=</span> <span class="n">psi_boundary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">psi_0</span> <span class="o">=</span> <span class="n">psi_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">psi_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi</span> <span class="o">-</span> <span class="n">psi_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psi_boundary</span> <span class="o">-</span> <span class="n">psi_0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">psi_norm</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">psi_norm</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">psi_norm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">psi_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">psi_norm</span>

        <span class="c1"># Unwrap single values to ensure least surprise:</span>
        <span class="k">if</span> <span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">blob</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Equilibrium.rz2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux.</span>

<span class="sd">        Uses the definitions:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \texttt{phi} &amp;= \int q(\psi)\,d\psi\\</span>
<span class="sd">            \texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}</span>

<span class="sd">        This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to phinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to phinorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting psinorm to phinorm.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>

<span class="sd">            * **phinorm** (`Array or scalar float`) - The normalized toroidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `phinorm` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `phinorm`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>


<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                phi_val = Eq_instance.rz2phinorm(0.6, 0, 0.26)</span>

<span class="sd">            Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                phi_arr = Eq_instance.rz2phinorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find phinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                phi_arr = Eq_instance.rz2phinorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                phi_arr = Eq_instance.rz2phinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find phinorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                phi_mat = Eq_instance.rz2phinorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">rz2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume.</span>

<span class="sd">        Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to volnorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to volnorm. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting psinorm to volnorm.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>

<span class="sd">            * **volnorm** (`Array or scalar float`) - The normalized volume.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `volnorm` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `volnorm`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.rz2volnorm(0.6, 0, 0.26)</span>

<span class="sd">            Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                vol_arr = Eq_instance.rz2volnorm([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find volnorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                vol_arr = Eq_instance.rz2volnorm(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                vol_arr = Eq_instance.rz2volnorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find volnorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                vol_mat = Eq_instance.rz2volnorm(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">rz2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps the given points to the outboard midplane major radius, Rmid.</span>

<span class="sd">        Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to Rmid. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to Rmid. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in,</span>
<span class="sd">                AND that `Rmid` is returned in. If a string is given, it must</span>
<span class="sd">                be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting psinorm to Rmid.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>

<span class="sd">            * **Rmid** (`Array or scalar float`) - The outboard midplan major</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `Rmid` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `Rmid`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single Rmid value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                R_mid_val = Eq_instance.rz2rmid(0.6, 0, 0.26)</span>

<span class="sd">            Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                R_mid_arr = Eq_instance.rz2rmid([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find Rmid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                R_mid_arr = Eq_instance.rz2rmid(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find Rmid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                R_mid_arr = Eq_instance.rz2rmid([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find Rmid values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                R_mid_mat = Eq_instance.rz2rmid(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Steve Wolfe&#39;s version has an extra (linear) interpolation step for</span>
        <span class="c1"># small psi_norm. Should check to see if we need this still with the</span>
        <span class="c1"># scipy spline. So far looks fine...</span>

        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
                <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2roa">[docs]</a>    <span class="k">def</span> <span class="nf">rz2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps the given points to the normalized minor radius, r/a.</span>

<span class="sd">        Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to r/a. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to r/a. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting psinorm to Rmid.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>

<span class="sd">            * **roa** (`Array or scalar float`) - The normalized minor radius.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `roa` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `roa`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                roa_val = Eq_instance.rz2roa(0.6, 0, 0.26)</span>

<span class="sd">            Find r/a values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the Z vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                roa_arr = Eq_instance.rz2roa([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find r/a values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                roa_arr = Eq_instance.rz2roa(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                roa_arr = Eq_instance.rz2roa([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find r/a values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                roa_mat = Eq_instance.rz2roa(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Steve Wolfe&#39;s version has an extra (linear) interpolation step for</span>
        <span class="c1"># small psi_norm. Should check to see if we need this still with the</span>
        <span class="c1"># scipy spline. So far looks fine...</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rz2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (R, Z, t) coordinates into one of several coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to. Valid</span>
<span class="sd">                options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    q       Safety factor</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to `rho`. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to `rho`. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of `rho`.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid when `destination` is Rmid. Default is False</span>
<span class="sd">                (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in,</span>
<span class="sd">                AND that `Rmid` is returned in. If a string is given, it must</span>
<span class="sd">                be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.rz2rho(&#39;psinorm&#39;, 0.6, 0, 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, [0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, 0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.rz2rho(&#39;psinorm&#39;, [0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find psinorm values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                psi_mat = Eq_instance.rz2rho(&#39;psinorm&#39;, R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2q</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FFPrime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2p</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pprime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2v</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;rz2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2roa">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2roa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sqrt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">blob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (R_mid, t) coordinates into r/a.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>

<span class="sd">            * **roa** (`Array or scalar float`) - Normalized midplane minor</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value at R_mid=0.6m, t=0.26s::</span>

<span class="sd">                roa_val = Eq_instance.rmid2roa(0.6, 0.26)</span>

<span class="sd">            Find roa values at R_mid points 0.6m and 0.8m at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                roa_arr = Eq_instance.rmid2roa([0.6, 0.8], 0.26)</span>

<span class="sd">            Find roa values at R_mid of 0.6m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                roa_arr = Eq_instance.rmid2roa(0.6, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                roa_arr = Eq_instance.rmid2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Make this map inboard to outboard!</span>

        <span class="c1"># It looks like this is never actually called with pre-computed time</span>
        <span class="c1"># indices internally, so I am going to not support that functionality</span>
        <span class="c1"># for now.</span>
        <span class="k">if</span> <span class="n">blob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Passing of time indices not supported!&quot;</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">R_mid</span><span class="p">,</span>
            <span class="n">dum</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">time_idxs</span><span class="p">,</span>
            <span class="n">unique_idxs</span><span class="p">,</span>
            <span class="n">single_time</span><span class="p">,</span>
            <span class="n">single_val</span><span class="p">,</span>
            <span class="n">original_shape</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
            <span class="n">R_mid</span><span class="p">,</span>
            <span class="n">R_mid</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
            <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
            <span class="n">compute_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">convert_only</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">roa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">roa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                    <span class="n">roa</span> <span class="o">=</span> <span class="n">roa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">roa</span> <span class="o">=</span> <span class="n">roa</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">roa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),</span> <span class="p">],</span> <span class="n">original_shape</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                    <span class="n">roa</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span>
                        <span class="n">R_mid</span><span class="p">,</span> <span class="n">t_idx</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">roa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">roa</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">roa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">roa</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">roa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">roa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">roa</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roa</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roa</span><span class="p">,</span> <span class="p">(</span>
                    <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                    <span class="n">original_shape</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">roa</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>

<span class="sd">            * **psinorm** (`Array or scalar float`) - Normalized poloidal flux.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                psinorm_val = Eq_instance.rmid2psinorm(0.7, 0.26)</span>

<span class="sd">            Find psinorm values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                psinorm_arr = Eq_instance.rmid2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psinorm_arr = Eq_instance.rmid2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                psinorm_arr = Eq_instance.rmid2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getRmidToPsiNormSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux.</span>

<span class="sd">        Uses the definitions:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \texttt{phi} &amp;= \int q(\psi)\,d\psi</span>

<span class="sd">            \texttt{phi\_norm} &amp;= \frac{\phi}{\phi(a)}</span>

<span class="sd">        This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>

<span class="sd">            * **phinorm** (`Array or scalar float`) - Normalized toroidal flux.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at R_mid=0.6m, t=0.26s::</span>

<span class="sd">                phi_val = Eq_instance.rmid2phinorm(0.6, 0.26)</span>

<span class="sd">            Find phinorm values at R_mid points 0.6m and 0.8m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                phi_arr = Eq_instance.rmid2phinorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find phinorm values at R_mid point 0.6m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                phi_arr = Eq_instance.rmid2phinorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (R, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                phi_arr = Eq_instance.rmid2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume.</span>

<span class="sd">        Based on the IDL version efit_rz2rho.pro by Steve Wolfe.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>

<span class="sd">            * **volnorm** (`Array or scalar float`) - Normalized volume.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value at R_mid=0.6m, t=0.26s::</span>

<span class="sd">                vol_val = Eq_instance.rmid2volnorm(0.6, 0.26)</span>

<span class="sd">            Find volnorm values at R_mid points 0.6m and 0.8m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                vol_arr = Eq_instance.rmid2volnorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find volnorm values at R_mid points 0.6m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                vol_arr = Eq_instance.rmid2volnorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                vol_arr = Eq_instance.rmid2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2rho">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (R_mid, t) coordinates into one of several coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to. Valid</span>
<span class="sd">                options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at R_mid=0.6m, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.rmid2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at R_mid points 0.6m and 0.8m at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                psi_arr = Eq_instance.rmid2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at R_mid of 0.6m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.rmid2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.rmid2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2roa</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2phinorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2volnorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2q</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2F</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FFPrime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2FFPrime</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2p</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pprime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2pprime</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2v</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default back to the old kuldge that wastes time in rz2psi:</span>
            <span class="c1"># TODO: This doesn&#39;t handle length units properly!</span>
            <span class="n">Z_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagZSpline</span><span class="p">()(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;each_t&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="c1"># Need to override the default in _processRZt, since we are doing</span>
                <span class="c1"># the shaping here:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;each_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># For a single t, there will only be a single value of Z_mid and</span>
                    <span class="c1"># we only need to make it have the same shape as R_mid. Note</span>
                    <span class="c1"># that ones_like appears to be clever enough to handle the case</span>
                    <span class="c1"># of a scalar R_mid.</span>
                    <span class="n">Z_mid</span> <span class="o">=</span> <span class="n">Z_mid</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For multiple t, we need to repeat R_mid for every t, then</span>
                    <span class="c1"># repeat the corresponding Z_mid that many times for each such</span>
                    <span class="c1"># entry.</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;rmid2rho: When using the each_t keyword, &quot;</span>
                            <span class="s2">&quot;t must have only one dimension.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
                        <span class="n">R_mid</span><span class="p">,</span>
                        <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="p">],</span>
                                <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span>
                                    <span class="n">scipy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">R_mid</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>  <span class="c1"># may need to be declared as ints</span>
                    <span class="p">)</span>
                    <span class="c1"># TODO: Is there a clever way to do this without a loop?</span>
                    <span class="n">Z_mid_temp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">t_temp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_mid</span><span class="p">)):</span>
                        <span class="n">Z_mid_temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Z_mid</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">t_temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">Z_mid</span> <span class="o">=</span> <span class="n">Z_mid_temp</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t_temp</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2rho</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">Z_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">roa2rmid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">blob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into Rmid.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>

<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single R_mid value at r/a=0.6, t=0.26s::</span>

<span class="sd">                R_mid_val = Eq_instance.roa2rmid(0.6, 0.26)</span>

<span class="sd">            Find R_mid values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                R_mid_arr = Eq_instance.roa2rmid([0.6, 0.8], 0.26)</span>

<span class="sd">            Find R_mid values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                R_mid_arr = Eq_instance.roa2rmid(0.6, [0.2, 0.3])</span>

<span class="sd">            Find R_mid values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                R_mid_arr = Eq_instance.roa2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># It looks like this is never actually called with pre-computed time</span>
        <span class="c1"># indices internally, so I am going to not support that functionality</span>
        <span class="c1"># for now.</span>
        <span class="k">if</span> <span class="n">blob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Passing of time indices not supported!&quot;</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">roa</span><span class="p">,</span>
            <span class="n">dum</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">time_idxs</span><span class="p">,</span>
            <span class="n">unique_idxs</span><span class="p">,</span>
            <span class="n">single_time</span><span class="p">,</span>
            <span class="n">single_val</span><span class="p">,</span>
            <span class="n">original_shape</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
            <span class="n">roa</span><span class="p">,</span>
            <span class="n">roa</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
            <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
            <span class="n">compute_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">check_space</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">R_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">R_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                    <span class="n">R_mid</span> <span class="o">=</span> <span class="n">R_mid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">R_mid</span> <span class="o">=</span> <span class="n">R_mid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">R_mid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),</span> <span class="p">],</span> <span class="n">original_shape</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                    <span class="n">R_mid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span>
                        <span class="n">roa</span><span class="p">,</span> <span class="n">t_idx</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">roa</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>

        <span class="n">R_mid</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">R_mid</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">R_mid</span><span class="p">,</span> <span class="p">(</span>
                    <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                    <span class="n">original_shape</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">R_mid</span></div>

<div class="viewcode-block" id="Equilibrium.roa2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">roa2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into psinorm.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>

<span class="sd">            * **psinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at r/a=0.6, t=0.26s::</span>

<span class="sd">                psinorm_val = Eq_instance.roa2psinorm(0.6, 0.26)</span>

<span class="sd">            Find psinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                psinorm_arr = Eq_instance.roa2psinorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psinorm_arr = Eq_instance.roa2psinorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                psinorm_arr = Eq_instance.roa2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">roa2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into phinorm.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>

<span class="sd">            * **phinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at r/a=0.6, t=0.26s::</span>

<span class="sd">                phinorm_val = Eq_instance.roa2phinorm(0.6, 0.26)</span>

<span class="sd">            Find phinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                phinorm_arr = Eq_instance.roa2phinorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find phinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                phinorm_arr = Eq_instance.roa2phinorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                phinorm_arr = Eq_instance.roa2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;phinorm&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">roa2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into volnorm.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>

<span class="sd">            * **volnorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value at r/a=0.6, t=0.26s::</span>

<span class="sd">                volnorm_val = Eq_instance.roa2volnorm(0.6, 0.26)</span>

<span class="sd">            Find volnorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                volnorm_arr = Eq_instance.roa2volnorm([0.6, 0.8], 0.26)</span>

<span class="sd">            Find volnorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                volnorm_arr = Eq_instance.roa2volnorm(0.6, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                volnorm_arr = Eq_instance.roa2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;volnorm&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2rho">[docs]</a>    <span class="k">def</span> <span class="nf">roa2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into one of several coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    q       Safety factor</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at r/a=0.6, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.roa2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>

<span class="sd">                psi_arr = Eq_instance.roa2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.roa2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.roa2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;convert_roa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2rho</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the outboard R_mid location corresponding to the passed psinorm (normalized poloidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>

<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single R_mid value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                R_mid_val = Eq_instance.psinorm2rmid(0.7, 0.26)</span>

<span class="sd">            Find R_mid values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                R_mid_arr = Eq_instance.psinorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">            Find R_mid values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                R_mid_arr = Eq_instance.psinorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">            Find R_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                R_mid_arr = Eq_instance.psinorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
                <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span>
            <span class="n">psi_norm</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2roa">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized minor radius location corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>

<span class="sd">            * **roa** (`Array or scalar float`) - Normalized midplane minor</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                roa_val = Eq_instance.psinorm2roa(0.7, 0.26)</span>

<span class="sd">            Find r/a values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                roa_arr = Eq_instance.psinorm2roa([0.5, 0.7], 0.26)</span>

<span class="sd">            Find r/a values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                roa_arr = Eq_instance.psinorm2roa(0.5, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                roa_arr = Eq_instance.psinorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized volume corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>

<span class="sd">            * **volnorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                volnorm_val = Eq_instance.psinorm2volnorm(0.7, 0.26)</span>

<span class="sd">            Find volnorm values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                volnorm_arr = Eq_instance.psinorm2volnorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find volnorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                volnorm_arr = Eq_instance.psinorm2volnorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                volnorm_arr = Eq_instance.psinorm2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>

<span class="sd">            * **phinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                phinorm_val = Eq_instance.psinorm2phinorm(0.7, 0.26)</span>

<span class="sd">            Find phinorm values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                phinorm_arr = Eq_instance.psinorm2phinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find phinorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                phinorm_arr = Eq_instance.psinorm2phinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                phinorm_arr = Eq_instance.psinorm2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2rho">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (psinorm, t) coordinates into one of several coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    q       Safety factor</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value at psinorm=0.6, t=0.26s::</span>

<span class="sd">                phi_val = Eq_instance.psinorm2rho(&#39;phinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find phinorm values at phinorm of 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>

<span class="sd">                phi_arr = Eq_instance.psinorm2rho(&#39;phinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find phinorm values at psinorm of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                phi_arr = Eq_instance.psinorm2rho(&#39;phinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                phi_arr = Eq_instance.psinorm2rho(&#39;phinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2q</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2F</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FFPrime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2FFPrime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2p</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pprime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2pprime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psinorm2v</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;psinorm2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>

<span class="sd">            * **psinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                psinorm_val = Eq_instance.phinorm2psinorm(0.7, 0.26)</span>

<span class="sd">            Find psinorm values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                psinorm_arr = Eq_instance.phinorm2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psinorm_arr = Eq_instance.phinorm2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                psinorm_arr = Eq_instance.phinorm2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormToPsiNormSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2volnorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2volnorm">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2volnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to volnorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of volnorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `volnorm` or (`volnorm`, `time_idxs`)</span>

<span class="sd">            * **volnorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `volnorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single volnorm value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                volnorm_val = Eq_instance.phinorm2volnorm(0.7, 0.26)</span>

<span class="sd">            Find volnorm values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                volnorm_arr = Eq_instance.phinorm2volnorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find volnorm values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                volnorm_arr = Eq_instance.phinorm2volnorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find volnorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                volnorm_arr = Eq_instance.phinorm2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the mapped outboard midplane major radius corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>

<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single Rmid value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                Rmid_val = Eq_instance.phinorm2rmid(0.7, 0.26)</span>

<span class="sd">            Find Rmid values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                Rmid_arr = Eq_instance.phinorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">            Find Rmid values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                Rmid_arr = Eq_instance.phinorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">            Find Rmid values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                Rmid_arr = Eq_instance.phinorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
                <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2roa">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized minor radius corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>

<span class="sd">            * **roa** (`Array or scalar float`) - Normalized midplane minor</span>
<span class="sd">              radius. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                roa_val = Eq_instance.phinorm2roa(0.7, 0.26)</span>

<span class="sd">            Find r/a values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                roa_arr = Eq_instance.phinorm2roa([0.5, 0.7], 0.26)</span>

<span class="sd">            Find r/a values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                roa_arr = Eq_instance.phinorm2roa(0.5, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                roa_arr = Eq_instance.phinorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="n">phi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2rho">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (phinorm, t) coordinates into one of several coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    volnorm Normalized volume</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    q       Safety factor</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `phinorm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `phinorm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at phinorm=0.6, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.phinorm2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at phinorm of 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>

<span class="sd">                psi_arr = Eq_instance.phinorm2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at phinorm of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.phinorm2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.phinorm2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;volnorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2volnorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2roa</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2q</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2F</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FFPrime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2FFPrime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2p</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pprime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2pprime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2v</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;phinorm2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized poloidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>

<span class="sd">            * **psinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                psinorm_val = Eq_instance.volnorm2psinorm(0.7, 0.26)</span>

<span class="sd">            Find psinorm values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                psinorm_arr = Eq_instance.volnorm2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psinorm_arr = Eq_instance.volnorm2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                psinorm_arr = Eq_instance.volnorm2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getVolNormToPsiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2phinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2phinorm">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2phinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized toroidal flux corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to phinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of phinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `phinorm` or (`phinorm`, `time_idxs`)</span>

<span class="sd">            * **phinorm** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `phinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single phinorm value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                phinorm_val = Eq_instance.volnorm2phinorm(0.7, 0.26)</span>

<span class="sd">            Find phinorm values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                phinorm_arr = Eq_instance.volnorm2phinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find phinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                phinorm_arr = Eq_instance.volnorm2phinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find phinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                phinorm_arr = Eq_instance.volnorm2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPhiNormSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2rmid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2rmid">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the mapped outboard midplane major radius corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to Rmid.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of Rmid.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `Rmid` or (`Rmid`, `time_idxs`)</span>

<span class="sd">            * **Rmid** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `Rmid`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single Rmid value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                Rmid_val = Eq_instance.volnorm2rmid(0.7, 0.26)</span>

<span class="sd">            Find Rmid values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                Rmid_arr = Eq_instance.volnorm2rmid([0.5, 0.7], 0.26)</span>

<span class="sd">            Find Rmid values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                Rmid_arr = Eq_instance.volnorm2rmid(0.5, [0.2, 0.3])</span>

<span class="sd">            Find Rmid values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                Rmid_arr = Eq_instance.volnorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert units from meters to desired target but keep units consistent</span>
        <span class="c1"># with rho keyword:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
                <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2roa"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2roa">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the normalized minor radius corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to r/a.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of r/a.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `roa` or (`roa`, `time_idxs`)</span>

<span class="sd">            * **roa** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `roa`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single r/a value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                roa_val = Eq_instance.volnorm2roa(0.7, 0.26)</span>

<span class="sd">            Find r/a values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                roa_arr = Eq_instance.volnorm2roa([0.5, 0.7], 0.26)</span>

<span class="sd">            Find r/a values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                roa_arr = Eq_instance.volnorm2roa(0.5, [0.2, 0.3])</span>

<span class="sd">            Find r/a values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                roa_arr = Eq_instance.volnorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getRmidSpline</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2rho"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2rho">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (volnorm, t) coordinates into one of several coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (String): Indicates which coordinates to convert to.</span>
<span class="sd">                Valid options are:</span>

<span class="sd">                    ======= =================================</span>
<span class="sd">                    psinorm Normalized poloidal flux</span>
<span class="sd">                    phinorm Normalized toroidal flux</span>
<span class="sd">                    Rmid    Midplane major radius</span>
<span class="sd">                    r/a     Normalized minor radius</span>
<span class="sd">                    q       Safety factor</span>
<span class="sd">                    F       Flux function :math:`F=RB_{\phi}`</span>
<span class="sd">                    FFPrime Flux function :math:`FF&#39;`</span>
<span class="sd">                    p       Pressure</span>
<span class="sd">                    pprime  Pressure gradient</span>
<span class="sd">                    v       Flux surface volume</span>
<span class="sd">                    ======= =================================</span>

<span class="sd">                Additionally, each valid option may be prepended with &#39;sqrt&#39;</span>
<span class="sd">                to specify the square root of the desired unit.</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to rho.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of rho. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `volnorm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `volnorm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `Rmid` is returned in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `rho` or (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted coordinates. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `method` is not one of the supported values.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value at volnorm=0.6, t=0.26s::</span>

<span class="sd">                psi_val = Eq_instance.volnorm2rho(&#39;psinorm&#39;, 0.6, 0.26)</span>

<span class="sd">            Find psinorm values at volnorm of 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s::</span>

<span class="sd">                psi_arr = Eq_instance.volnorm2rho(&#39;psinorm&#39;, [0.6, 0.8], 0.26)</span>

<span class="sd">            Find psinorm values at volnorm of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psi_arr = Eq_instance.volnorm2rho(&#39;psinorm&#39;, 0.6, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                psi_arr = Eq_instance.volnorm2rho(&#39;psinorm&#39;, [0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;psinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phinorm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2phinorm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2rmid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;r/a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2roa</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2q</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2F</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FFPrime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2FFPrime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2p</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pprime&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2pprime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2v</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;volnorm2rho: Unsupported normalized coordinate method &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">method</span>
            <span class="p">)</span></div>

    <span class="c1">##################################</span>
    <span class="c1"># Profile interpolation routines #</span>
    <span class="c1">##################################</span>

    <span class="c1"># Safety factor (&quot;q&quot;) profile:</span>

<div class="viewcode-block" id="Equilibrium.rz2q"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2q">[docs]</a>    <span class="k">def</span> <span class="nf">rz2q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the safety factor (&quot;q&quot;) at the given (R, Z, t).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to q. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to q. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of q.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`q`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `q` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `q`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `q` or (`q`, `time_idxs`)</span>

<span class="sd">            * **q** (`Array or scalar float`) - The safety factor (&quot;q&quot;). If all</span>
<span class="sd">              of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `q` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `q`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `q`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single q value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                q_val = Eq_instance.rz2q(0.6, 0, 0.26)</span>

<span class="sd">            Find q values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                q_arr = Eq_instance.rz2q([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find q values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                q_arr = Eq_instance.rz2q(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find q values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                q_arr = Eq_instance.rz2q([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find q values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                q_mat = Eq_instance.rz2q(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getQSpline</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2q"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2q">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the safety factor (&quot;q&quot;) corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to q.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of q.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`q`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `q` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `q`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `q` or (`q`, `time_idxs`)</span>

<span class="sd">            * **q** (`Array or scalar float`) - The safety factor (&quot;q&quot;).</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `q`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single q value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                q_val = Eq_instance.rmid2q(0.7, 0.26)</span>

<span class="sd">            Find q values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                q_arr = Eq_instance.rmid2q([0.5, 0.7], 0.26)</span>

<span class="sd">            Find q values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                q_arr = Eq_instance.rmid2q(0.5, [0.2, 0.3])</span>

<span class="sd">            Find q values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                q_arr = Eq_instance.rmid2q([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getQSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2q"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2q">[docs]</a>    <span class="k">def</span> <span class="nf">roa2q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into safety factor (&quot;q&quot;).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to q.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of q.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`q`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `q` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `q`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `q` or (`q`, `time_idxs`)</span>

<span class="sd">            * **q** (`Array or scalar float`) - The safety factor (&quot;q&quot;). If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `q`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single q value at r/a=0.6, t=0.26s::</span>

<span class="sd">                q_val = Eq_instance.roa2q(0.6, 0.26)</span>

<span class="sd">            Find q values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                q_arr = Eq_instance.roa2q([0.6, 0.8], 0.26)</span>

<span class="sd">            Find q values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                q_arr = Eq_instance.roa2q(0.6, [0.2, 0.3])</span>

<span class="sd">            Find q values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                q_arr = Eq_instance.roa2q([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2q"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2q">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the safety factor (&quot;q&quot;) corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to q.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of q. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`q`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `q` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `q`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `q` or (`q`, `time_idxs`)</span>

<span class="sd">            * **q** (`Array or scalar float`) - The safety factor (&quot;q&quot;). If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `q`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single q value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                q_val = Eq_instance.psinorm2q(0.7, 0.26)</span>

<span class="sd">            Find q values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                q_arr = Eq_instance.psinorm2q([0.5, 0.7], 0.26)</span>

<span class="sd">            Find q values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                q_arr = Eq_instance.psinorm2q(0.5, [0.2, 0.3])</span>

<span class="sd">            Find q values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                q_arr = Eq_instance.psinorm2q([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getQSpline</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2q"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2q">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the safety factor (&quot;q&quot;) corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to q.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of q.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`q`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `q` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `q`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `q` or (`q`, `time_idxs`)</span>

<span class="sd">            * **q** (`Array or scalar float`) - The safety factor (&quot;q&quot;). If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `q`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single q value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                q_val = Eq_instance.phinorm2q(0.7, 0.26)</span>

<span class="sd">            Find q values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                q_arr = Eq_instance.phinorm2q([0.5, 0.7], 0.26)</span>

<span class="sd">            Find q values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                q_arr = Eq_instance.phinorm2q(0.5, [0.2, 0.3])</span>

<span class="sd">            Find q values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                q_arr = Eq_instance.phinorm2q([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getQSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2q"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2q">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the safety factor (&quot;q&quot;) corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to q.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of q.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`q`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `q` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `q`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `q` or (`q`, `time_idxs`)</span>

<span class="sd">            * **q** (`Array or scalar float`) - The safety factor (&quot;q&quot;). If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `q`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single q value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                q_val = Eq_instance.volnorm2q(0.7, 0.26)</span>

<span class="sd">            Find q values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                q_arr = Eq_instance.volnorm2q([0.5, 0.7], 0.26)</span>

<span class="sd">            Find q values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                q_arr = Eq_instance.volnorm2q(0.5, [0.2, 0.3])</span>

<span class="sd">            Find q values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                q_arr = Eq_instance.volnorm2q([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getQSpline</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Flux function (&quot;F&quot;) profile:</span>

<div class="viewcode-block" id="Equilibrium.rz2F"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2F">[docs]</a>    <span class="k">def</span> <span class="nf">rz2F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`F=RB_{\phi}` at the given (R, Z, t).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to F. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to F. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of F.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`F`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `F` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `F`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `F` or (`F`, `time_idxs`)</span>

<span class="sd">            * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `F` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `F`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `F`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single F value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                F_val = Eq_instance.rz2F(0.6, 0, 0.26)</span>

<span class="sd">            Find F values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                F_arr = Eq_instance.rz2F([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find F values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                F_arr = Eq_instance.rz2F(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find F values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                F_arr = Eq_instance.rz2F([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find F values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                F_mat = Eq_instance.rz2F(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFSpline</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2F"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2F">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to F.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of F.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`F`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `F` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `F`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `F` or (`F`, `time_idxs`)</span>

<span class="sd">            * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `F`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single F value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                F_val = Eq_instance.rmid2F(0.7, 0.26)</span>

<span class="sd">            Find F values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                F_arr = Eq_instance.rmid2F([0.5, 0.7], 0.26)</span>

<span class="sd">            Find F values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                F_arr = Eq_instance.rmid2F(0.5, [0.2, 0.3])</span>

<span class="sd">            Find F values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                F_arr = Eq_instance.rmid2F([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2F"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2F">[docs]</a>    <span class="k">def</span> <span class="nf">roa2F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into the flux function :math:`F=RB_{\phi}`.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to F.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of F.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`F`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `F` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `F`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `F` or (`F`, `time_idxs`)</span>

<span class="sd">            * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `F`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single F value at r/a=0.6, t=0.26s::</span>

<span class="sd">                F_val = Eq_instance.roa2F(0.6, 0.26)</span>

<span class="sd">            Find F values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                F_arr = Eq_instance.roa2F([0.6, 0.8], 0.26)</span>

<span class="sd">            Find F values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                F_arr = Eq_instance.roa2F(0.6, [0.2, 0.3])</span>

<span class="sd">            Find F values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                F_arr = Eq_instance.roa2F([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2F"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2F">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to F.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of F. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`F`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `F` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `F`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `F` or (`F`, `time_idxs`)</span>

<span class="sd">            * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `F`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single F value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                F_val = Eq_instance.psinorm2F(0.7, 0.26)</span>

<span class="sd">            Find F values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                F_arr = Eq_instance.psinorm2F([0.5, 0.7], 0.26)</span>

<span class="sd">            Find F values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                F_arr = Eq_instance.psinorm2F(0.5, [0.2, 0.3])</span>

<span class="sd">            Find F values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                F_arr = Eq_instance.psinorm2F([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFSpline</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2F"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2F">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to F.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of F.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`F`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `F` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `F`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `F` or (`F`, `time_idxs`)</span>

<span class="sd">            * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `F`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single F value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                F_val = Eq_instance.phinorm2F(0.7, 0.26)</span>

<span class="sd">            Find F values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                F_arr = Eq_instance.phinorm2F([0.5, 0.7], 0.26)</span>

<span class="sd">            Find F values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                F_arr = Eq_instance.phinorm2F(0.5, [0.2, 0.3])</span>

<span class="sd">            Find F values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                F_arr = Eq_instance.phinorm2F([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2F"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2F">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to F.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of F.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`F`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `F` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `F`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `F` or (`F`, `time_idxs`)</span>

<span class="sd">            * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `F`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single F value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                F_val = Eq_instance.volnorm2F(0.7, 0.26)</span>

<span class="sd">            Find F values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                F_arr = Eq_instance.volnorm2F([0.5, 0.7], 0.26)</span>

<span class="sd">            Find F values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                F_arr = Eq_instance.volnorm2F(0.5, [0.2, 0.3])</span>

<span class="sd">            Find F values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                F_arr = Eq_instance.volnorm2F([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFSpline</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.Fnorm2psinorm"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.Fnorm2psinorm">[docs]</a>    <span class="k">def</span> <span class="nf">Fnorm2psinorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the psinorm (normalized poloidal flux) corresponding to the passed normalized flux function :math:`F=RB_{\phi}` values.</span>

<span class="sd">        This is provided as a convenience method to plot current lines with the</span>
<span class="sd">        correct spacing: current lines launched from a grid uniformly-spaced in</span>
<span class="sd">        Fnorm will have spacing directly proportional to the magnitude.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS. Furthermore, it is</span>
<span class="sd">        truncated at the radius at which is becomes non-monotonic.</span>

<span class="sd">        Args:</span>
<span class="sd">            F (Array-like or scalar float): Values of F to map to psinorm.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of psinorm.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `F` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `F` or be a</span>
<span class="sd">                scalar. Default is True (evaluate ALL `volnorm` at EACH element</span>
<span class="sd">                in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`psinorm`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `psinorm` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `psinorm`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `psinorm` or (`psinorm`, `time_idxs`)</span>

<span class="sd">            * **psinorm** (`Array or scalar float`) - The normalized poloidal</span>
<span class="sd">              flux. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `psinorm`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single psinorm value for F=0.7, t=0.26s::</span>

<span class="sd">                psinorm_val = Eq_instance.F2psinorm(0.7, 0.26)</span>

<span class="sd">            Find psinorm values at F values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                psinorm_arr = Eq_instance.F2psinorm([0.5, 0.7], 0.26)</span>

<span class="sd">            Find psinorm values at F=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                psinorm_arr = Eq_instance.F2psinorm(0.5, [0.2, 0.3])</span>

<span class="sd">            Find psinorm values at (F, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                psinorm_arr = Eq_instance.F2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getFNormToPsiNormSpline</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

    <span class="c1"># Flux function (&quot;FF&#39;&quot;) profile:</span>

<div class="viewcode-block" id="Equilibrium.rz2FFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2FFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">rz2FFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`FF&#39;` at the given (R, Z, t).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to FFPrime. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to FFPrime. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of FFPrime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`FFPrime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `FFPrime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `FFPrime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `FFPrime` or (`FFPrime`, `time_idxs`)</span>

<span class="sd">            * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF&#39;`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `FFPrime` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `FFPrime`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `FFPrime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single FFPrime value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                FFPrime_val = Eq_instance.rz2FFPrime(0.6, 0, 0.26)</span>

<span class="sd">            Find FFPrime values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                FFPrime_arr = Eq_instance.rz2FFPrime([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find FFPrime values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                FFPrime_arr = Eq_instance.rz2FFPrime(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find FFPrime values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                FFPrime_arr = Eq_instance.rz2FFPrime([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find FFPrime values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                FFPrime_mat = Eq_instance.rz2FFPrime(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFFPrimeSpline</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2FFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2FFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2FFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`FF&#39;` corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to FFPrime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of FFPrime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`FFPrime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `FFPrime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `FFPrime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `FFPrime` or (`FFPrime`, `time_idxs`)</span>

<span class="sd">            * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF&#39;`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `FFPrime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single FFPrime value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                FFPrime_val = Eq_instance.rmid2FFPrime(0.7, 0.26)</span>

<span class="sd">            Find FFPrime values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                FFPrime_arr = Eq_instance.rmid2FFPrime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find FFPrime values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                FFPrime_arr = Eq_instance.rmid2FFPrime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find FFPrime values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                FFPrime_arr = Eq_instance.rmid2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFFPrimeSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2FFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2FFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">roa2FFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into the flux function :math:`FF&#39;`.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to FFPrime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of FFPrime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`FFPrime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `FFPrime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `FFPrime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `FFPrime` or (`FFPrime`, `time_idxs`)</span>

<span class="sd">            * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF&#39;`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `FFPrime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single FFPrime value at r/a=0.6, t=0.26s::</span>

<span class="sd">                FFPrime_val = Eq_instance.roa2FFPrime(0.6, 0.26)</span>

<span class="sd">            Find FFPrime values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                FFPrime_arr = Eq_instance.roa2FFPrime([0.6, 0.8], 0.26)</span>

<span class="sd">            Find FFPrime values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                FFPrime_arr = Eq_instance.roa2FFPrime(0.6, [0.2, 0.3])</span>

<span class="sd">            Find FFPrime values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                FFPrime_arr = Eq_instance.roa2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;FFPrime&#39;</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2FFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2FFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2FFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`FF&#39;` corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to FFPrime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of FFPrime. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`FFPrime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `FFPrime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `FFPrime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `FFPrime` or (`FFPrime`, `time_idxs`)</span>

<span class="sd">            * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF&#39;`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `FFPrime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single FFPrime value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                FFPrime_val = Eq_instance.psinorm2FFPrime(0.7, 0.26)</span>

<span class="sd">            Find FFPrime values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                FFPrime_arr = Eq_instance.psinorm2FFPrime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find FFPrime values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                FFPrime_arr = Eq_instance.psinorm2FFPrime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find FFPrime values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                FFPrime_arr = Eq_instance.psinorm2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFFPrimeSpline</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2FFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2FFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2FFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`FF&#39;` corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to FFPrime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of FFPrime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`FFPrime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `FFPrime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `FFPrime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `FFPrime` or (`FFPrime`, `time_idxs`)</span>

<span class="sd">            * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF&#39;`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `FFPrime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single FFPrime value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                FFPrime_val = Eq_instance.phinorm2FFPrime(0.7, 0.26)</span>

<span class="sd">            Find FFPrime values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                FFPrime_arr = Eq_instance.phinorm2FFPrime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find FFPrime values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                FFPrime_arr = Eq_instance.phinorm2FFPrime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find FFPrime values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                FFPrime_arr = Eq_instance.phinorm2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFFPrimeSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2FFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2FFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2FFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the flux function :math:`FF&#39;` corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to FFPrime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of FFPrime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`FFPrime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `FFPrime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `FFPrime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `FFPrime` or (`FFPrime`, `time_idxs`)</span>

<span class="sd">            * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF&#39;`.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `FFPrime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single FFPrime value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                FFPrime_val = Eq_instance.volnorm2FFPrime(0.7, 0.26)</span>

<span class="sd">            Find FFPrime values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                FFPrime_arr = Eq_instance.volnorm2FFPrime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find FFPrime values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                FFPrime_arr = Eq_instance.volnorm2FFPrime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find FFPrime values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                FFPrime_arr = Eq_instance.volnorm2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getFFPrimeSpline</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Pressure profile:</span>

<div class="viewcode-block" id="Equilibrium.rz2p"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2p">[docs]</a>    <span class="k">def</span> <span class="nf">rz2p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the pressure at the given (R, Z, t).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to p. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to p. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of p.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `p` or (`p`, `time_idxs`)</span>

<span class="sd">            * **p** (`Array or scalar float`) - The pressure. If all</span>
<span class="sd">              of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `p` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `p`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `p`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single p value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                p_val = Eq_instance.rz2p(0.6, 0, 0.26)</span>

<span class="sd">            Find p values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                p_arr = Eq_instance.rz2p([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find p values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                p_arr = Eq_instance.rz2p(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find p values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                p_arr = Eq_instance.rz2p([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find p values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                p_mat = Eq_instance.rz2p(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPSpline</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2p"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2p">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to p.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of p.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `p` or (`p`, `time_idxs`)</span>

<span class="sd">            * **p** (`Array or scalar float`) - The pressure.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `p`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single p value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                p_val = Eq_instance.rmid2p(0.7, 0.26)</span>

<span class="sd">            Find p values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                p_arr = Eq_instance.rmid2p([0.5, 0.7], 0.26)</span>

<span class="sd">            Find p values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                p_arr = Eq_instance.rmid2p(0.5, [0.2, 0.3])</span>

<span class="sd">            Find p values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                p_arr = Eq_instance.rmid2p([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2p"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2p">[docs]</a>    <span class="k">def</span> <span class="nf">roa2p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into pressure.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to p.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of p.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `p` or (`p`, `time_idxs`)</span>

<span class="sd">            * **p** (`Array or scalar float`) - The pressure. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `p`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single p value at r/a=0.6, t=0.26s::</span>

<span class="sd">                p_val = Eq_instance.roa2p(0.6, 0.26)</span>

<span class="sd">            Find p values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                p_arr = Eq_instance.roa2p([0.6, 0.8], 0.26)</span>

<span class="sd">            Find p values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                p_arr = Eq_instance.roa2p(0.6, [0.2, 0.3])</span>

<span class="sd">            Find p values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                p_arr = Eq_instance.roa2p([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2p"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2p">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to p.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of p. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `p` or (`p`, `time_idxs`)</span>

<span class="sd">            * **p** (`Array or scalar float`) - The pressure. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `p`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single p value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                p_val = Eq_instance.psinorm2p(0.7, 0.26)</span>

<span class="sd">            Find p values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                p_arr = Eq_instance.psinorm2p([0.5, 0.7], 0.26)</span>

<span class="sd">            Find p values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                p_arr = Eq_instance.psinorm2p(0.5, [0.2, 0.3])</span>

<span class="sd">            Find p values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                p_arr = Eq_instance.psinorm2p([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPSpline</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2p"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2p">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to p.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of p.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `p` or (`p`, `time_idxs`)</span>

<span class="sd">            * **p** (`Array or scalar float`) - The pressure. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `p`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single p value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                p_val = Eq_instance.phinorm2p(0.7, 0.26)</span>

<span class="sd">            Find p values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                p_arr = Eq_instance.phinorm2p([0.5, 0.7], 0.26)</span>

<span class="sd">            Find p values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                p_arr = Eq_instance.phinorm2p(0.5, [0.2, 0.3])</span>

<span class="sd">            Find p values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                p_arr = Eq_instance.phinorm2p([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2p"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2p">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to p.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of p.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `p` or (`p`, `time_idxs`)</span>

<span class="sd">            * **p** (`Array or scalar float`) - The pressure. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `p`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single p value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                p_val = Eq_instance.volnorm2p(0.7, 0.26)</span>

<span class="sd">            Find p values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                p_arr = Eq_instance.volnorm2p([0.5, 0.7], 0.26)</span>

<span class="sd">            Find p values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                p_arr = Eq_instance.volnorm2p(0.5, [0.2, 0.3])</span>

<span class="sd">            Find p values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                p_arr = Eq_instance.volnorm2p([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPSpline</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Pressure gradient profile:</span>

<div class="viewcode-block" id="Equilibrium.rz2pprime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2pprime">[docs]</a>    <span class="k">def</span> <span class="nf">rz2pprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the pressure gradient at the given (R, Z, t).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to pprime. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to pprime. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of pprime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`pprime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `pprime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `pprime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `pprime` or (`pprime`, `time_idxs`)</span>

<span class="sd">            * **pprime** (`Array or scalar float`) - The pressure gradient. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `p` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `p`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `pprime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single pprime value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                pprime_val = Eq_instance.rz2pprime(0.6, 0, 0.26)</span>

<span class="sd">            Find pprime values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                pprime_arr = Eq_instance.rz2pprime([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find pprime values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                pprime_arr = Eq_instance.rz2pprime(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find pprime values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                pprime_arr = Eq_instance.rz2pprime([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find pprime values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                pprime_mat = Eq_instance.rz2pprime(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPPrimeSpline</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2pprime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2pprime">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2pprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure gradient corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to pprime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of pprime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`pprime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `pprime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `pprime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `pprime` or (`pprime`, `time_idxs`)</span>

<span class="sd">            * **pprime** (`Array or scalar float`) - The pressure gradient.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `pprime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single pprime value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                pprime_val = Eq_instance.rmid2pprime(0.7, 0.26)</span>

<span class="sd">            Find pprime values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                pprime_arr = Eq_instance.rmid2pprime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find pprime values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                pprime_arr = Eq_instance.rmid2pprime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find pprime values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                pprime_arr = Eq_instance.rmid2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPPrimeSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2pprime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2pprime">[docs]</a>    <span class="k">def</span> <span class="nf">roa2pprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into pressure gradient.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to pprime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of pprime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`pprime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `pprime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `pprime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `pprime` or (`pprime`, `time_idxs`)</span>

<span class="sd">            * **pprime** (`Array or scalar float`) - The pressure gradient. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `pprime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single pprime value at r/a=0.6, t=0.26s::</span>

<span class="sd">                pprime_val = Eq_instance.roa2pprime(0.6, 0.26)</span>

<span class="sd">            Find pprime values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                pprime_arr = Eq_instance.roa2pprime([0.6, 0.8], 0.26)</span>

<span class="sd">            Find pprime values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                pprime_arr = Eq_instance.roa2pprime(0.6, [0.2, 0.3])</span>

<span class="sd">            Find pprime values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                pprime_arr = Eq_instance.roa2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;pprime&#39;</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2pprime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2pprime">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2pprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure gradient corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to pprime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of pprime. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`pprime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `pprime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `pprime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `pprime` or (`pprime`, `time_idxs`)</span>

<span class="sd">            * **pprime** (`Array or scalar float`) - The pressure gradient. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `pprime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single pprime value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                pprime_val = Eq_instance.psinorm2pprime(0.7, 0.26)</span>

<span class="sd">            Find pprime values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                pprime_arr = Eq_instance.psinorm2pprime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find pprime values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                pprime_arr = Eq_instance.psinorm2pprime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find pprime values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                pprime_arr = Eq_instance.psinorm2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPPrimeSpline</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2pprime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2pprime">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2pprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure gradient corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to pprime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of pprime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`pprime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `pprime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `pprime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `pprime` or (`pprime`, `time_idxs`)</span>

<span class="sd">            * **pprime** (`Array or scalar float`) - The pressure gradient. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `pprime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single pprime value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                pprime_val = Eq_instance.phinorm2pprime(0.7, 0.26)</span>

<span class="sd">            Find pprime values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                pprime_arr = Eq_instance.phinorm2pprime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find pprime values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                pprime_arr = Eq_instance.phinorm2pprime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find pprime values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                pprime_arr = Eq_instance.phinorm2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPPrimeSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2pprime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2pprime">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2pprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pressure gradient corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to pprime.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of pprime.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`pprime`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `pprime` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `pprime`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `pprime` or (`pprime`, `time_idxs`)</span>

<span class="sd">            * **pprime** (`Array or scalar float`) - The pressure gradient. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `pprime`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single pprime value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                pprime_val = Eq_instance.volnorm2pprime(0.7, 0.26)</span>

<span class="sd">            Find pprime values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                pprime_arr = Eq_instance.volnorm2pprime([0.5, 0.7], 0.26)</span>

<span class="sd">            Find pprime values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                pprime_arr = Eq_instance.volnorm2pprime(0.5, [0.2, 0.3])</span>

<span class="sd">            Find pprime values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                pprime_arr = Eq_instance.volnorm2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPPrimeSpline</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Flux surface volume profile:</span>

<div class="viewcode-block" id="Equilibrium.rz2v"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2v">[docs]</a>    <span class="k">def</span> <span class="nf">rz2v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the flux surface volume at the given (R, Z, t).</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to v. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to v. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of v.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`v`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `v` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `v`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `v` or (`v`, `time_idxs`)</span>

<span class="sd">            * **v** (`Array or scalar float`) - The flux surface volume. If all</span>
<span class="sd">              of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `v` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `v`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `v`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single v value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                v_val = Eq_instance.rz2v(0.6, 0, 0.26)</span>

<span class="sd">            Find v values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                v_arr = Eq_instance.rz2v([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find v values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                v_arr = Eq_instance.rz2v(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find v values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                v_arr = Eq_instance.rz2v([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find v values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                v_mat = Eq_instance.rz2v(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVSpline</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rmid2v"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rmid2v">[docs]</a>    <span class="k">def</span> <span class="nf">rmid2v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the flux surface volume corresponding to the passed R_mid (mapped outboard midplane major radius) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array-like or scalar float): Values of the outboard midplane</span>
<span class="sd">                major radius to map to v.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R_mid`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `R_mid`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of v.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R_mid` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R_mid`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `R_mid` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R_mid` is given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`p`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `p` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `p`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `v` or (`v`, `time_idxs`)</span>

<span class="sd">            * **v** (`Array or scalar float`) - The flux surface volume.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `v`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single v value for Rmid=0.7m, t=0.26s::</span>

<span class="sd">                v_val = Eq_instance.rmid2v(0.7, 0.26)</span>

<span class="sd">            Find v values at R_mid values of 0.5m and 0.7m at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                v_arr = Eq_instance.rmid2v([0.5, 0.7], 0.26)</span>

<span class="sd">            Find v values at R_mid=0.5m at times t=[0.2s, 0.3s]::</span>

<span class="sd">                v_arr = Eq_instance.rmid2v(0.5, [0.2, 0.3])</span>

<span class="sd">            Find v values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::</span>

<span class="sd">                v_arr = Eq_instance.rmid2v([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVSpline</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.roa2v"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.roa2v">[docs]</a>    <span class="k">def</span> <span class="nf">roa2v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the passed (r/a, t) coordinates into flux surface volume.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array-like or scalar float): Values of the normalized minor</span>
<span class="sd">                radius to map to v.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `roa`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `roa`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of v.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `roa` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `roa`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `roa` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`v`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `v` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `v`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `v` or (`v`, `time_idxs`)</span>

<span class="sd">            * **v** (`Array or scalar float`) - The flux surface volume. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `v`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single v value at r/a=0.6, t=0.26s::</span>

<span class="sd">                v_val = Eq_instance.roa2v(0.6, 0.26)</span>

<span class="sd">            Find v values at r/a points 0.6 and 0.8 at the</span>
<span class="sd">            single time t=0.26s.::</span>

<span class="sd">                v_arr = Eq_instance.roa2v([0.6, 0.8], 0.26)</span>

<span class="sd">            Find v values at r/a of 0.6 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                v_arr = Eq_instance.roa2v(0.6, [0.2, 0.3])</span>

<span class="sd">            Find v values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                v_arr = Eq_instance.roa2v([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roa2rho</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.psinorm2v"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.psinorm2v">[docs]</a>    <span class="k">def</span> <span class="nf">psinorm2v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the flux surface volume corresponding to the passed psi_norm (normalized poloidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            psi_norm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                poloidal flux to map to v.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `psi_norm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of v. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`v`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `v` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `v`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `v` or (`v`, `time_idxs`)</span>

<span class="sd">            * **v** (`Array or scalar float`) - The pressure. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `v`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single v value for psinorm=0.7, t=0.26s::</span>

<span class="sd">                v_val = Eq_instance.psinorm2v(0.7, 0.26)</span>

<span class="sd">            Find v values at psi_norm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                v_arr = Eq_instance.psinorm2v([0.5, 0.7], 0.26)</span>

<span class="sd">            Find v values at psi_norm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                v_arr = Eq_instance.psinorm2v(0.5, [0.2, 0.3])</span>

<span class="sd">            Find v values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                v_arr = Eq_instance.psinorm2v([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVSpline</span><span class="p">,</span> <span class="n">psinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.phinorm2v"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.phinorm2v">[docs]</a>    <span class="k">def</span> <span class="nf">phinorm2v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            phinorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                toroidal flux to map to v.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `phinorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of v.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `phinorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `phinorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `phinorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`v`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `v` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `v`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `v` or (`v`, `time_idxs`)</span>

<span class="sd">            * **v** (`Array or scalar float`) - The flux surface volume. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `v`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single v value for phinorm=0.7, t=0.26s::</span>

<span class="sd">                v_val = Eq_instance.phinorm2v(0.7, 0.26)</span>

<span class="sd">            Find v values at phinorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                v_arr = Eq_instance.phinorm2v([0.5, 0.7], 0.26)</span>

<span class="sd">            Find v values at phinorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                v_arr = Eq_instance.phinorm2v(0.5, [0.2, 0.3])</span>

<span class="sd">            Find v values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                v_arr = Eq_instance.phinorm2v([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVSpline</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.volnorm2v"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.volnorm2v">[docs]</a>    <span class="k">def</span> <span class="nf">volnorm2v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the flux surface volume corresponding to the passed volnorm (normalized flux surface volume) values.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS.</span>

<span class="sd">        Args:</span>
<span class="sd">            volnorm (Array-like or scalar float): Values of the normalized</span>
<span class="sd">                flux surface volume to map to v.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `volnorm`. If the `each_t` keyword is True, then `t` must be scalar</span>
<span class="sd">                or have exactly one dimension. If the `each_t` keyword is False,</span>
<span class="sd">                `t` must have the same shape as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of v.</span>
<span class="sd">                Only the square root of positive values is taken. Negative</span>
<span class="sd">                values are replaced with zeros, consistent with Steve Wolfe&#39;s</span>
<span class="sd">                IDL implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            each_t (Boolean): When True, the elements in `volnorm` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `volnorm`</span>
<span class="sd">                or be a scalar. Default is True (evaluate ALL `volnorm` at EACH</span>
<span class="sd">                element in `t`).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`v`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `v` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `v`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `v` or (`v`, `time_idxs`)</span>

<span class="sd">            * **v** (`Array or scalar float`) - The flux surface volume. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `v`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single v value for volnorm=0.7, t=0.26s::</span>

<span class="sd">                v_val = Eq_instance.volnorm2p(0.7, 0.26)</span>

<span class="sd">            Find v values at volnorm values of 0.5 and 0.7 at the single time</span>
<span class="sd">            t=0.26s::</span>

<span class="sd">                v_arr = Eq_instance.volnorm2v([0.5, 0.7], 0.26)</span>

<span class="sd">            Find v values at volnorm=0.5 at times t=[0.2s, 0.3s]::</span>

<span class="sd">                v_arr = Eq_instance.volnorm2v(0.5, [0.2, 0.3])</span>

<span class="sd">            Find v values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::</span>

<span class="sd">                v_arr = Eq_instance.volnorm2v([0.6, 0.5], [0.2, 0.3], each_t=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getVSpline</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">###########################</span>
    <span class="c1"># Magnetic field routines #</span>
    <span class="c1">###########################</span>

<div class="viewcode-block" id="Equilibrium.rz2BR"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2BR">[docs]</a>    <span class="k">def</span> <span class="nf">rz2BR</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the major radial component of the magnetic field at the given (R, Z, t) coordinates.</span>

<span class="sd">        Uses</span>

<span class="sd">        .. math::</span>

<span class="sd">            B_R = -\frac{1}{R}\frac{\partial \psi}{\partial Z}</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to radial field. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to radial field. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`BR`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `BR` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `BR`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `BR` or (`BR`, `time_idxs`)</span>

<span class="sd">            * **BR** (`Array or scalar float`) - The major radial component of</span>
<span class="sd">              the magnetic field. If all of the input arguments are scalar, then</span>
<span class="sd">              a scalar is returned. Otherwise, a scipy Array is returned. If `R`</span>
<span class="sd">              and `Z` both have the same shape then `BR` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `BR` has</span>
<span class="sd">              shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `BR`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single BR value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                BR_val = Eq_instance.rz2BR(0.6, 0, 0.26)</span>

<span class="sd">            Find BR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                BR_arr = Eq_instance.rz2BR([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find BR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                BR_arr = Eq_instance.rz2BR(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find BR values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                BR_arr = Eq_instance.rz2BR([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find BR values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                BR_mat = Eq_instance.rz2BR(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check inputs and process into flat arrays with units of meters:</span>
        <span class="p">(</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
            <span class="n">original_shape</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span>
            <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
            <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
            <span class="n">compute_unique</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxTriSpline</span><span class="p">()</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">),</span>
                <span class="n">original_shape</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                    <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">out_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),</span> <span class="p">],</span> <span class="n">original_shape</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">t_idx</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                            <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">),</span>
                        <span class="n">original_shape</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="n">unique_idxs</span><span class="p">:</span>
                    <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_idxs</span> <span class="o">==</span> <span class="n">t_idx</span><span class="p">)</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">t_idx</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                            <span class="n">Z</span><span class="p">[</span><span class="n">t_mask</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">t_mask</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

        <span class="c1"># Correct for current sign:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">out_vals</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_vals</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_vals</span><span class="p">,</span> <span class="p">(</span>
                    <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                    <span class="n">original_shape</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_vals</span></div>

<div class="viewcode-block" id="Equilibrium.rz2BZ"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2BZ">[docs]</a>    <span class="k">def</span> <span class="nf">rz2BZ</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the vertical component of the magnetic field at the given (R, Z, t) coordinates.</span>

<span class="sd">        Uses</span>

<span class="sd">        .. math::</span>

<span class="sd">            B_Z = \frac{1}{R}\frac{\partial \psi}{\partial R}</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to vertical field. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to vertical field. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`BZ`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `BZ` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `BZ`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `BZ` or (`BZ`, `time_idxs`)</span>

<span class="sd">            * **BZ** (`Array or scalar float`) - The vertical component of the</span>
<span class="sd">              magnetic field. If all of the input arguments are scalar, then a</span>
<span class="sd">              scalar is returned. Otherwise, a scipy Array is returned. If `R`</span>
<span class="sd">              and `Z` both have the same shape then `BZ` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `BZ` has</span>
<span class="sd">              shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `BZ`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single BZ value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                BZ_val = Eq_instance.rz2BZ(0.6, 0, 0.26)</span>

<span class="sd">            Find BZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                BZ_arr = Eq_instance.rz2BZ([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find BZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                BZ_arr = Eq_instance.rz2BZ(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find BZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                BZ_arr = Eq_instance.rz2BZ([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find BZ values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                BZ_mat = Eq_instance.rz2BZ(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check inputs and process into flat arrays with units of meters:</span>
        <span class="p">(</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
            <span class="n">original_shape</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">make_grid</span><span class="o">=</span><span class="n">make_grid</span><span class="p">,</span>
            <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
            <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
            <span class="n">compute_unique</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxTriSpline</span><span class="p">()</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">),</span>
                <span class="n">original_shape</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                    <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">out_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),</span> <span class="p">],</span> <span class="n">original_shape</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span><span class="n">t_idx</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                            <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">1</span>
                        <span class="p">),</span>
                        <span class="n">original_shape</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="n">unique_idxs</span><span class="p">:</span>
                    <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_idxs</span> <span class="o">==</span> <span class="n">t_idx</span><span class="p">)</span>
                    <span class="n">out_vals</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFluxBiSpline</span><span class="p">(</span>
                        <span class="n">t_idx</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">t_mask</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">t_mask</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">out_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_vals</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

        <span class="c1"># Correct for current sign:</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">out_vals</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_vals</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_vals</span><span class="p">,</span> <span class="p">(</span>
                    <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                    <span class="n">original_shape</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_vals</span></div>

<div class="viewcode-block" id="Equilibrium.rz2BT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2BT">[docs]</a>    <span class="k">def</span> <span class="nf">rz2BT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the toroidal component of the magnetic field at the given (R, Z, t).</span>

<span class="sd">        Uses :math:`B_\phi = F / R`.</span>

<span class="sd">        By default, EFIT only computes this inside the LCFS. To approximate the</span>
<span class="sd">        field outside of the LCFS, :math:`B_\phi \approx B_{t, vac} R_0 / R` is</span>
<span class="sd">        used, where :math:`B_{t, vac}` is obtained with :py:meth:`getBtVac` and</span>
<span class="sd">        :math:`R_0` is the major radius of the magnetic axis obtained from</span>
<span class="sd">        :py:meth:`getMagR`.</span>

<span class="sd">        The coordinate system used is right-handed, such that &quot;forward&quot; field on</span>
<span class="sd">        Alcator C-Mod (clockwise when seen from above) has negative BT.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to BT. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `Z` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `R` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to BT. If `R` and `Z` are both scalar values,</span>
<span class="sd">                they are used as the coordinate pair for all of the values in</span>
<span class="sd">                `t`. Must have the same shape as `R` unless the `make_grid`</span>
<span class="sd">                keyword is set. If the `make_grid` keyword is True, `Z` must</span>
<span class="sd">                have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`BT`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `BT` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `BT`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `BT` or (`BT`, `time_idxs`)</span>

<span class="sd">            * **BT** (`Array or scalar float`) - The toroidal magnetic field.</span>
<span class="sd">              If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `BT` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `BT`</span>
<span class="sd">              has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `BT`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single BT value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                BT_val = Eq_instance.rz2BT(0.6, 0, 0.26)</span>

<span class="sd">            Find BT values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                BT_arr = Eq_instance.rz2BT([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find BT values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                BT_arr = Eq_instance.rz2BT(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find BT values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                BT_arr = Eq_instance.rz2BT([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find BT values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                BT_mat = Eq_instance.rz2BT(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
            <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="n">F</span><span class="p">,</span> <span class="n">blob</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">out</span>

        <span class="n">B_T</span> <span class="o">=</span> <span class="n">F</span> <span class="o">/</span> <span class="n">R</span>

        <span class="c1"># This will have NaN anywhere outside of the LCFS. Only handle if we</span>
        <span class="c1"># we need to.</span>
        <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">B_T</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Flux function F not provided outside of LCFS, assuming field &quot;</span>
                <span class="s2">&quot;goes like 1/R there to compute BT! This may be inaccurate!&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span>
            <span class="p">)</span>
            <span class="c1"># This unfortunately requires a second call to _processRZt:</span>
            <span class="p">(</span>
                <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                <span class="n">original_shape</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
                <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                <span class="n">make_grid</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_grid&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                <span class="n">each_t</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;each_t&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">length_unit</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">compute_unique</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">B_T</span> <span class="o">=</span> <span class="n">B_T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">B_T</span><span class="p">)</span>
                <span class="n">B_T</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getBtVacSpline</span><span class="p">()(</span><span class="n">t</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getMagRSpline</span><span class="p">()(</span><span class="n">t</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">B_T</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_T</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                    <span class="n">B_T</span> <span class="o">=</span> <span class="n">B_T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">B_T</span><span class="p">)</span>
                    <span class="n">B_T</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getBtVac</span><span class="p">()[</span><span class="n">time_idxs</span><span class="p">]</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">()[</span><span class="n">time_idxs</span><span class="p">]</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                        <span class="n">B_T</span> <span class="o">=</span> <span class="n">B_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">B_T</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_T</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;each_t&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                        <span class="n">tmp_out</span> <span class="o">=</span> <span class="n">B_T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp_out</span><span class="p">)</span>
                        <span class="n">tmp_out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getBtVac</span><span class="p">()[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">*</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">()[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">B_T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp_out</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B_T</span> <span class="o">=</span> <span class="n">B_T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="n">unique_idxs</span><span class="p">:</span>
                        <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_idxs</span> <span class="o">==</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">tmp_out</span> <span class="o">=</span> <span class="n">B_T</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp_out</span><span class="p">)</span>
                        <span class="n">tmp_out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getBtVac</span><span class="p">()[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">*</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">()[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">t_mask</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">B_T</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_out</span>
                    <span class="n">B_T</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_T</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">B_T</span><span class="p">,</span> <span class="n">blob</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">B_T</span></div>

<div class="viewcode-block" id="Equilibrium.rz2B"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2B">[docs]</a>    <span class="k">def</span> <span class="nf">rz2B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the magnitude of the magnetic field at the given (R, Z, t).</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to B. If `R` and `Z` are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in `t`. Must have</span>
<span class="sd">                the same shape as `Z` unless the `make_grid` keyword is set. If</span>
<span class="sd">                the `make_grid` keyword is True, `R` must have exactly one</span>
<span class="sd">                dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to B. If `R` and `Z` are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in `t`. Must have</span>
<span class="sd">                the same shape as `R` unless the `make_grid` keyword is set. If</span>
<span class="sd">                the `make_grid` keyword is True, `Z` must have exactly one</span>
<span class="sd">                dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`B`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `B` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `B`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `B` or (`B`, `time_idxs`)</span>

<span class="sd">            * **B** (`Array or scalar float`) - The magnitude of the magnetic</span>
<span class="sd">              field. If all of the input arguments are scalar, then a scalar is</span>
<span class="sd">              returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `B` has this shape as well, unless</span>
<span class="sd">              the `make_grid` keyword was True, in which case `B` has shape</span>
<span class="sd">              (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `B`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the</span>
<span class="sd">            appropriate extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single B value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                B_val = Eq_instance.rz2B(0.6, 0, 0.26)</span>

<span class="sd">            Find B values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully specified,</span>
<span class="sd">            even if the values are all the same::</span>

<span class="sd">                B_arr = Eq_instance.rz2B([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find B values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                B_arr = Eq_instance.rz2B(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find B values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                B_arr = Eq_instance.rz2B([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find B values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                B_mat = Eq_instance.rz2B(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This doesn&#39;t handle return_t properly!</span>
        <span class="n">BR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">BZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">BT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">BR</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">BZ</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">BT</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span></div>

    <span class="c1">############################</span>
    <span class="c1"># Current density routines #</span>
    <span class="c1">############################</span>

<div class="viewcode-block" id="Equilibrium.rz2jR"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2jR">[docs]</a>    <span class="k">def</span> <span class="nf">rz2jR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the major radial component of the current density at the given (R, Z, t) coordinates.</span>

<span class="sd">        .. math::</span>

<span class="sd">            j_R = -\frac{1}{\mu_0 R}F&#39;\frac{\partial \psi}{\partial Z} = \frac{F&#39; B_R}{\mu_0}</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to radial current density. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `Z` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `R` must have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to radial current density. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `R` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `Z` must have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`jR`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `jR` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `jR`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `jR` or (`jR`, `time_idxs`)</span>

<span class="sd">            * **jR** (`Array or scalar float`) - The major radial component of</span>
<span class="sd">              the current density. If all of the input arguments are scalar, then</span>
<span class="sd">              a scalar is returned. Otherwise, a scipy Array is returned. If `R`</span>
<span class="sd">              and `Z` both have the same shape then `jR` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `jR` has</span>
<span class="sd">              shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `jR`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single jR value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                jR_val = Eq_instance.rz2jR(0.6, 0, 0.26)</span>

<span class="sd">            Find jR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                jR_arr = Eq_instance.rz2jR([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find jR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                jR_arr = Eq_instance.rz2jR(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find jR values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                jR_arr = Eq_instance.rz2jR([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find jR values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                jR_mat = Eq_instance.rz2jR(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This doesn&#39;t handle return_t properly!</span>
        <span class="c1"># NOTE: Alcator C-Mod requires the extra factor to correct FF&#39;.</span>
        <span class="c1"># You should check this for your implementation.</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2jZ"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2jZ">[docs]</a>    <span class="k">def</span> <span class="nf">rz2jZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the vertical component of the current density at the given (R, Z, t) coordinates.</span>

<span class="sd">        Uses</span>

<span class="sd">        .. math::</span>

<span class="sd">            j_Z = \frac{1}{\mu_0 R}F&#39;\frac{\partial \psi}{\partial R} = \frac{F&#39; B_Z}{\mu_0}</span>

<span class="sd">        Note that this function includes a factor of -1 to correct the FF&#39; from</span>
<span class="sd">        Alcator C-Mod&#39;s EFIT implementation. You should check the sign of your</span>
<span class="sd">        data.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to vertical current density. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `Z` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `R` must have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to vertical current density. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `R` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `Z` must have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`jZ`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `jZ` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `jZ`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `jZ` or (`jZ`, `time_idxs`)</span>

<span class="sd">            * **jZ** (`Array or scalar float`) - The vertical component of the</span>
<span class="sd">              current density. If all of the input arguments are scalar, then a</span>
<span class="sd">              scalar is returned. Otherwise, a scipy Array is returned. If `R`</span>
<span class="sd">              and `Z` both have the same shape then `jZ` has this shape as well,</span>
<span class="sd">              unless the `make_grid` keyword was True, in which case `jZ` has</span>
<span class="sd">              shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `jZ`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single jZ value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                jZ_val = Eq_instance.rz2jZ(0.6, 0, 0.26)</span>

<span class="sd">            Find jZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                jZ_arr = Eq_instance.rz2jZ([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find jZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                jZ_arr = Eq_instance.rz2jZ(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find jZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                jZ_arr = Eq_instance.rz2jZ([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find jZ values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                jZ_mat = Eq_instance.rz2jZ(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This doesn&#39;t handle return_t properly!</span>
        <span class="c1"># NOTE: Alcator C-Mod requires the extra factor to correct FF&#39;.</span>
        <span class="c1"># You should check this for your implementation.</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2F</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2jT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2jT">[docs]</a>    <span class="k">def</span> <span class="nf">rz2jT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the toroidal component of the current density at the given (R, Z, t) coordinates.</span>

<span class="sd">        Uses</span>

<span class="sd">        .. math::</span>

<span class="sd">            j_\phi = Rp&#39; + \frac{FF&#39;}{\mu_0 R}</span>

<span class="sd">        The coordinate system used is right-handed, such that &quot;forward&quot; field on</span>
<span class="sd">        Alcator C-Mod (clockwise when seen from above) has negative jT.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to toroidal current density. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `Z` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `R` must have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to toroidal current density. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `R` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `Z` must have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`jT`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `jT` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `jT`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `jT` or (`jT`, `time_idxs`)</span>

<span class="sd">            * **jT** (`Array or scalar float`) - The major radial component of</span>
<span class="sd">              the current density. If all of the input arguments are scalar,</span>
<span class="sd">              then a scalar is returned. Otherwise, a scipy Array is returned.</span>
<span class="sd">              If `R` and `Z` both have the same shape then `jT` has this shape</span>
<span class="sd">              as well, unless the `make_grid` keyword was True, in which case</span>
<span class="sd">              `jT` has shape (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `jT`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single jT value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                jT_val = Eq_instance.rz2jT(0.6, 0, 0.26)</span>

<span class="sd">            Find jT values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                jT_arr = Eq_instance.rz2jT([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find jT values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                jT_arr = Eq_instance.rz2jT(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find jT values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                jT_arr = Eq_instance.rz2jT([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find jT values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                jT_mat = Eq_instance.rz2jT(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This doesn&#39;t handle return_t properly!</span>
        <span class="c1"># NOTE: Alcator C-Mod requires the extra factor to correct FF&#39;.</span>
        <span class="c1"># You should check this for your implementation.</span>
        <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
            <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">R</span> <span class="o">/</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2pprime</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">unit_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2FFPrime</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.rz2j"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2j">[docs]</a>    <span class="k">def</span> <span class="nf">rz2j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the magnitude of the current density at the given (R, Z, t) coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to current density magnitude. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `Z` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `R` must have exactly one dimension.</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to current density magnitude. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `R` unless the</span>
<span class="sd">                `make_grid` keyword is set. If the `make_grid` keyword is True,</span>
<span class="sd">                `Z` must have exactly one dimension.</span>
<span class="sd">            t (Array-like or scalar float): Times to perform the conversion at.</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If the `each_t` keyword is True, then `t` must be</span>
<span class="sd">                scalar or have exactly one dimension. If the `each_t` keyword is</span>
<span class="sd">                False, `t` must have the same shape as `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `R`, `Z` are evaluated</span>
<span class="sd">                at each value in `t`. If True, `t` must have only one dimension</span>
<span class="sd">                (or be a scalar). If False, `t` must match the shape of `R` and</span>
<span class="sd">                `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at</span>
<span class="sd">                EACH element in `t`).</span>
<span class="sd">            make_grid (Boolean): Set to True to pass `R` and `Z` through</span>
<span class="sd">                :py:func:`scipy.meshgrid` before evaluating. If this is set to</span>
<span class="sd">                True, `R` and `Z` must each only have a single dimension, but</span>
<span class="sd">                can have different lengths. Default is False (do not form</span>
<span class="sd">                meshgrid).</span>
<span class="sd">            length_unit (String or 1): Length unit that `R`, `Z` are given in.</span>
<span class="sd">                If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (use meters).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`j`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `j` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `j`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `j` or (`j`, `time_idxs`)</span>

<span class="sd">            * **j** (`Array or scalar float`) - The magnitude of the current</span>
<span class="sd">              density. If all of the input arguments are scalar, then a scalar</span>
<span class="sd">              is returned. Otherwise, a scipy Array is returned. If `R` and `Z`</span>
<span class="sd">              both have the same shape then `j` has this shape as well, unless</span>
<span class="sd">              the `make_grid` keyword was True, in which case `j` has shape</span>
<span class="sd">              (len(`Z`), len(`R`)).</span>
<span class="sd">            * **time_idxs** (Array with same shape as `j`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class.</span>

<span class="sd">            Find single j value at R=0.6m, Z=0.0m, t=0.26s::</span>

<span class="sd">                j_val = Eq_instance.rz2j(0.6, 0, 0.26)</span>

<span class="sd">            Find j values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the</span>
<span class="sd">            single time t=0.26s. Note that the `Z` vector must be fully</span>
<span class="sd">            specified, even if the values are all the same::</span>

<span class="sd">                j_arr = Eq_instance.rz2j([0.6, 0.8], [0, 0], 0.26)</span>

<span class="sd">            Find j values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::</span>

<span class="sd">                j_arr = Eq_instance.rz2j(0.6, 0, [0.2, 0.3])</span>

<span class="sd">            Find j values at (R, Z, t) points (0.6m, 0m, 0.2s) and</span>
<span class="sd">            (0.5m, 0.2m, 0.3s)::</span>

<span class="sd">                j_arr = Eq_instance.rz2j([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)</span>

<span class="sd">            Find j values on grid defined by 1D vector of radial positions `R`</span>
<span class="sd">            and 1D vector of vertical positions `Z` at time t=0.2s::</span>

<span class="sd">                j_mat = Eq_instance.rz2j(R, Z, 0.2, make_grid=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This doesn&#39;t handle return_t properly!</span>
        <span class="n">jR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">jZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">jT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jR</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">jZ</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">jT</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span></div>

    <span class="c1">##########################</span>
    <span class="c1"># Field mapping routines #</span>
    <span class="c1">##########################</span>
    <span class="k">def</span> <span class="nf">_fl_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">RZ</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Function which implements the differential equation for field line tracing.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{dR}{d\phi} = \frac{u_R}{u_\phi}R</span>

<span class="sd">            \frac{dZ}{d\phi} = \frac{u_Z}{u_\phi}R</span>

<span class="sd">        Args:</span>
<span class="sd">            phi (float): Toroidal location to use.</span>
<span class="sd">            RZ (array of float, (2,)): Array containing R, Z.</span>
<span class="sd">            t (float): The time to use.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            field ({&#39;B&#39;, &#39;j&#39;}): The field to use. Can be magnetic field (&#39;B&#39;) or</span>
<span class="sd">                current density (&#39;j&#39;). Default is &#39;B&#39; (magnetic field).</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: containing [:math:`dR/d\phi`, :math:`dZ/d\phi`]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">RZ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">RZ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
            <span class="n">uR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">uZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">uT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span>
            <span class="n">uR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">uZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">uT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">uR</span> <span class="o">*</span> <span class="n">R</span> <span class="o">/</span> <span class="n">uT</span><span class="p">,</span> <span class="n">uZ</span> <span class="o">*</span> <span class="n">R</span> <span class="o">/</span> <span class="n">uT</span><span class="p">]</span>

<div class="viewcode-block" id="Equilibrium.rz2FieldLineTrace"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rz2FieldLineTrace">[docs]</a>    <span class="k">def</span> <span class="nf">rz2FieldLineTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">Z0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">phi0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">num_rev</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                          <span class="n">rev_method</span><span class="o">=</span><span class="s1">&#39;toroidal&#39;</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span>
                          <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;dopri5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trace a field line starting from a given (R, phi, Z) point.</span>

<span class="sd">        Args:</span>
<span class="sd">            R0 (float): Major radial coordinate of starting point.</span>
<span class="sd">            Z0 (float): Vertical coordinate of starting point.</span>
<span class="sd">            t (float): Time to trace field line at.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            phi0 (float): Toroidal angle of starting point in radians. Default</span>
<span class="sd">                is 0.0.</span>
<span class="sd">            field ({&#39;B&#39;, &#39;j&#39;}): The field to use. Can be magnetic field (&#39;B&#39;) or</span>
<span class="sd">                current density (&#39;j&#39;). Default is &#39;B&#39; (magnetic field).</span>
<span class="sd">            num_rev (float): The number of revolutions to trace the field line</span>
<span class="sd">                through. Whether this refers to toroidal or poloidal revolutions</span>
<span class="sd">                is determined by the `rev_method` keyword. Default is 1.0.</span>
<span class="sd">            rev_method (&#39;toroidal&#39;, &#39;poloidal&#39;): Whether `num_rev` refers to the</span>
<span class="sd">                number of toroidal or poloidal revolutions the field line should</span>
<span class="sd">                make. Note that &#39;poloidal&#39; only makes sense for close field</span>
<span class="sd">                lines. Default is &#39;toroidal&#39;.</span>
<span class="sd">            dphi (float): Toroidal step size, in radians. Default is 0.02*pi.</span>
<span class="sd">                The number of steps taken is then 2*pi times the number of</span>
<span class="sd">                toroidal rotations divided by dphi. This can be negative to</span>
<span class="sd">                trace a field line clockwise instead of counterclockwise.</span>
<span class="sd">            integrator (str): The integrator to use with</span>
<span class="sd">                :py:class:`scipy.integrate.ode`. Default is &#39;dopri5&#39; (explicit</span>
<span class="sd">                Dormand-Prince of order (4)5). Can also be an instance of</span>
<span class="sd">                :py:class:`scipy.integrate.ode` for which the integrator and its</span>
<span class="sd">                options has been set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            array, (`nsteps` + 1, 3): Containing the (R, Z, phi) coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid field </span><span class="si">{field}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rev_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;toroidal&#39;</span><span class="p">,</span> <span class="s1">&#39;poloidal&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid rev_method </span><span class="si">{rm}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rm</span><span class="o">=</span><span class="n">rev_method</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rev_method</span> <span class="o">==</span> <span class="s1">&#39;poloidal&#39;</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2q</span><span class="p">(</span><span class="n">R0</span><span class="p">,</span> <span class="n">Z0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">num_rev</span> <span class="o">=</span> <span class="n">num_rev</span> <span class="o">*</span> <span class="n">q</span>
        <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_rev</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">dphi</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">ode</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">integrator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">ode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fl_func</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">set_integrator</span><span class="p">(</span><span class="n">integrator</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">set_f_params</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">set_initial_value</span><span class="p">([</span><span class="n">R0</span><span class="p">,</span> <span class="n">Z0</span><span class="p">],</span> <span class="n">phi0</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsteps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># R, Z, Phi</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">R0</span><span class="p">,</span> <span class="n">Z0</span><span class="p">,</span> <span class="n">phi0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsteps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="n">dphi</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">t</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Equilibrium.rho2FieldLineTrace"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.rho2FieldLineTrace">[docs]</a>    <span class="k">def</span> <span class="nf">rho2FieldLineTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;psinorm&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trace a field line starting from a given normalized coordinate point.</span>

<span class="sd">        The field line is started at the outboard midplane.</span>

<span class="sd">        Args:</span>
<span class="sd">            rho (float): Flux surface label of starting point.</span>
<span class="sd">            t (float): Time to trace field line at.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            origin ({&#39;psinorm&#39;, &#39;phinorm&#39;, &#39;volnorm&#39;, &#39;r/a&#39;, &#39;Rmid&#39;, &#39;Fnorm&#39;}):</span>
<span class="sd">                The flux surface coordinates which `rhovals` is given in.</span>
<span class="sd">                Default is &#39;psinorm&#39;.</span>
<span class="sd">            phi0 (float): Toroidal angle of starting point in radians. Default</span>
<span class="sd">                is 0.0.</span>
<span class="sd">            field ({&#39;B&#39;, &#39;j&#39;}): The field to use. Can be magnetic field (&#39;B&#39;) or</span>
<span class="sd">                current density (&#39;j&#39;). Default is &#39;B&#39; (magnetic field).</span>
<span class="sd">            num_rev (float): The number of revolutions to trace the field line</span>
<span class="sd">                through. Whether this refers to toroidal or poloidal revolutions</span>
<span class="sd">                is determined by the `rev_method` keyword. Default is 1.0.</span>
<span class="sd">            rev_method (&#39;toroidal&#39;, &#39;poloidal&#39;): Whether `num_rev` refers to the</span>
<span class="sd">                number of toroidal or poloidal revolutions the field line should</span>
<span class="sd">                make. Note that &#39;poloidal&#39; only makes sense for close field</span>
<span class="sd">                lines. Default is &#39;toroidal&#39;.</span>
<span class="sd">            dphi (float): Toroidal step size, in radians. Default is 0.02*pi.</span>
<span class="sd">                The number of steps taken is then 2*pi times the number of</span>
<span class="sd">                toroidal rotations divided by dphi. This can be negative to</span>
<span class="sd">                trace a field line clockwise instead of counterclockwise.</span>
<span class="sd">            integrator (str): The integrator to use with</span>
<span class="sd">                :py:class:`scipy.integrate.ode`. Default is &#39;dopri5&#39; (explicit</span>
<span class="sd">                Dormand-Prince of order (4)5). Can also be an instance of</span>
<span class="sd">                :py:class:`scipy.integrate.ode` for which the integrator and its</span>
<span class="sd">                options has been set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            array, (`nsteps` + 1, 3): Containing the (R, Z, phi) coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle Fnorm specially since it doesn&#39;t support all of the routines:</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;Fnorm&#39;</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fnorm2psinorm</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;psinorm&#39;</span>
        <span class="n">Rmid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="s1">&#39;Rmid&#39;</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">Zmid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagZSpline</span><span class="p">()(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># Intercept the poloidal rev_method here to avoid numerical issues at</span>
        <span class="c1"># the boundaries:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rev_method&#39;</span><span class="p">,</span> <span class="s1">&#39;toroidal&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;poloidal&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rev_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;toroidal&#39;</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho2rho</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num_rev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_rev&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2FieldLineTrace</span><span class="p">(</span><span class="n">Rmid</span><span class="p">,</span> <span class="n">Zmid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.plotField"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.plotField">[docs]</a>    <span class="k">def</span> <span class="nf">plotField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rhovals</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">rhomin</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">rhomax</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                  <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">arrows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                  <span class="n">arrowlinewidth</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the field lines starting from a number of points.</span>

<span class="sd">        The field lines are started at the outboard midplane.</span>

<span class="sd">        If uniformly-spaced psinorm points are used, the spacing of the magnetic</span>
<span class="sd">        field lines will be directly proportional to the field strength,</span>
<span class="sd">        assuming a sufficient number of revolutions is traced.</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): Time to trace field line at.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            rhovals (int or array of int): The number of uniformly-spaced rho</span>
<span class="sd">                points between `rhomin` and `rhomax` to use, or an explicit grid of rho</span>
<span class="sd">                points to use. Default is 6.</span>
<span class="sd">            rhomin (float): The minimum value of rho to use when using a</span>
<span class="sd">                uniformly-spaced grid. Default is 0.05.</span>
<span class="sd">            rhomax (float): The maximum value of rho to use when using a</span>
<span class="sd">                uniformly-spaced grid. Default is 0.95.</span>
<span class="sd">            color (str): The color to plot the field lines in. Default is &#39;b&#39;.</span>
<span class="sd">                If set to &#39;sequential&#39;, each field line will be a different</span>
<span class="sd">                color, in the sequence matplotlib assigns them. If set to</span>
<span class="sd">                &#39;magnitude&#39;, the coloring will be proportional to the magnitude</span>
<span class="sd">                of the field. Note that this is very time-consuming, as the</span>
<span class="sd">                limitations of matplotlib mean that each line segment must be</span>
<span class="sd">                plotted individually.</span>
<span class="sd">            cmap (str): The colormap to use when `color` is &#39;magnitude&#39;. Default</span>
<span class="sd">                is &#39;plasma&#39;, a perceptually uniform sequential colormap.</span>
<span class="sd">            alpha (float): The transparency to plot the field lines with.</span>
<span class="sd">                Default is 0.5.</span>
<span class="sd">            arrows (bool): If True, an arrowhead indicating the field direction</span>
<span class="sd">                will be drawn at the start of each field line. Default is True.</span>
<span class="sd">            linewidth (float): The line width to use when plotting the field</span>
<span class="sd">                lines. Default is 1.0.</span>
<span class="sd">            arrowlinewidth (float): The line width to use when plotting the</span>
<span class="sd">                arrows. Default is 3.0</span>
<span class="sd">            a (:py:class:`matplotlib.axes._subplots.Axes3DSubplot`): The axes to</span>
<span class="sd">                plot the field lines on. Default is to make a new figure. Note</span>
<span class="sd">                that a colorbar will be drawn when `color` is magnitude, but</span>
<span class="sd">                only if `a` is not provided.</span>
<span class="sd">            origin ({&#39;psinorm&#39;, &#39;phinorm&#39;, &#39;volnorm&#39;, &#39;r/a&#39;, &#39;Rmid&#39;, &#39;Fnorm&#39;}):</span>
<span class="sd">                The flux surface coordinates which `rhovals` is given in.</span>
<span class="sd">                Default is &#39;psinorm&#39;.</span>
<span class="sd">            phi0 (float): Toroidal angle of starting point in radians. Default</span>
<span class="sd">                is 0.0.</span>
<span class="sd">            field ({&#39;B&#39;, &#39;j&#39;}): The field to use. Can be magnetic field (&#39;B&#39;) or</span>
<span class="sd">                current density (&#39;j&#39;). Default is &#39;B&#39; (magnetic field).</span>
<span class="sd">            num_rev (float): The number of revolutions to trace the field line</span>
<span class="sd">                through. Whether this refers to toroidal or poloidal revolutions</span>
<span class="sd">                is determined by the `rev_method` keyword. Default is 1.0.</span>
<span class="sd">            rev_method (&#39;toroidal&#39;, &#39;poloidal&#39;): Whether `num_rev` refers to the</span>
<span class="sd">                number of toroidal or poloidal revolutions the field line should</span>
<span class="sd">                make. Note that &#39;poloidal&#39; only makes sense for close field</span>
<span class="sd">                lines. Default is &#39;toroidal&#39;.</span>
<span class="sd">            dphi (float): Toroidal step size, in radians. Default is 0.02*pi.</span>
<span class="sd">                The number of steps taken is then 2*pi times the number of</span>
<span class="sd">                toroidal rotations divided by dphi. This can be negative to</span>
<span class="sd">                trace a field line clockwise instead of counterclockwise.</span>
<span class="sd">            integrator (str): The integrator to use with</span>
<span class="sd">                :py:class:`scipy.integrate.ode`. Default is &#39;dopri5&#39; (explicit</span>
<span class="sd">                Dormand-Prince of order (4)5). Can also be an instance of</span>
<span class="sd">                :py:class:`scipy.integrate.ode` for which the integrator and its</span>
<span class="sd">                options has been set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (figure, axis): The figure and axis which the field lines were plotted in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rhovals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rhovals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhovals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rhovals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">rhomin</span><span class="p">,</span> <span class="n">rhomax</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">rhovals</span><span class="p">))</span>

        <span class="n">rzt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">rhovals</span><span class="p">:</span>
            <span class="n">rzt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho2FieldLineTrace</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
                <span class="n">gs</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
                <span class="n">a_cb</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
            <span class="c1"># Don&#39;t make colorbar for existing figure:</span>
            <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
                <span class="n">a_cb</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Need to do this ahead of time to get the right scaling for all lines:</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
            <span class="n">mag_max</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">mag_min</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rzt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
                    <span class="n">mag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rz2B</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rz2j</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">))</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">mag</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">mag_max</span><span class="p">:</span>
                    <span class="n">mag_max</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">mag</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">mag_min</span><span class="p">:</span>
                    <span class="n">mag_min</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">if</span> <span class="n">a_cb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span> <span class="k">else</span> <span class="mf">1e-6</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">ColorbarBase</span><span class="p">(</span>
                    <span class="n">a_cb</span><span class="p">,</span>
                    <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">),</span>
                    <span class="n">norm</span><span class="o">=</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">mag_min</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">mag_max</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">B_LABEL</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span> <span class="k">else</span> <span class="n">J_LABEL</span>
                <span class="p">)</span>

        <span class="n">v_ext</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rzt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
                <span class="c1"># Hack from https://stackoverflow.com/questions/15617207/line-colour-of-3d-parametric-curve-in-pythons-matplotlib-pyplot</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)(</span>
                        <span class="nb">int</span><span class="p">(</span>
                            <span class="n">scipy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span>
                                <span class="mi">255</span> <span class="o">*</span> <span class="p">(</span>
                                    <span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">mag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">mag_min</span>
                                <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mag_max</span> <span class="o">-</span> <span class="n">mag_min</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                        <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span><span class="p">,</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
                    <span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
                    <span class="n">v</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;sequential&#39;</span> <span class="k">else</span> <span class="n">color</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span>
                <span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">arrows</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
                    <span class="n">uR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BR</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
                    <span class="n">uZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BZ</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
                    <span class="n">uT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2BT</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">uR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jR</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
                    <span class="n">uZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jZ</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
                    <span class="n">uT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2jT</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uR</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">uZ</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">uT</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
                <span class="n">a</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
                    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
                    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="p">(</span><span class="n">uR</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">uT</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="n">u</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">uR</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">uT</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="n">u</span><span class="p">,</span>
                    <span class="n">uZ</span> <span class="o">/</span> <span class="n">u</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">length</span><span class="o">=</span><span class="n">v_ext</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">,</span>
                    <span class="n">arrow_length_ratio</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">pivot</span><span class="o">=</span><span class="s1">&#39;tail&#39;</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="n">arrowlinewidth</span>
                <span class="p">)</span>

        <span class="n">a</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="c1"># equal doesn&#39;t equalize the Z-axis, so fake it with axis limits:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">v_ext</span><span class="p">,</span> <span class="n">v_ext</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">v_ext</span><span class="p">,</span> <span class="n">v_ext</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="o">-</span><span class="n">v_ext</span><span class="p">,</span> <span class="n">v_ext</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$X$ [m]&#39;</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$Y$ [m]&#39;</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;$Z$ [m]&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">a</span></div>

    <span class="c1">###########################</span>
    <span class="c1"># Backend Mapping Drivers #</span>
    <span class="c1">###########################</span>

    <span class="k">def</span> <span class="nf">_psinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">return_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">sqrt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">blob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">check_space</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">convert_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">convert_roa</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert psinorm to a given quantity.</span>

<span class="sd">        Utility function for computing a variety of quantities given psi_norm</span>
<span class="sd">        and the relevant time indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable): Function which returns a 1d spline for the</span>
<span class="sd">                quantity you want to convert into as a function of `psi_norm`</span>
<span class="sd">                given a time index.</span>
<span class="sd">            psi_norm (Array or scalar float): `psi_norm` values to evaluate at.</span>
<span class="sd">            time_idxs (Array or scalar float): Time indices for each of the</span>
<span class="sd">                `psi_norm` values. Shape must match that of `psi_norm`.</span>
<span class="sd">            t: Array or scalar float. Representative time array that `psi_norm`</span>
<span class="sd">                and `time_idxs` was formed from (used to determine output shape).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean): When True, the elements in `psi_norm` are evaluated at</span>
<span class="sd">                each value in `t`. If True, `t` must have only one dimension (or</span>
<span class="sd">                be a scalar). If False, `t` must match the shape of `psi_norm` or be</span>
<span class="sd">                a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in</span>
<span class="sd">                `t`).</span>
<span class="sd">            return_t (Boolean): Set to True to return a tuple of (`rho`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `rho` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `rho`).</span>
<span class="sd">            sqrt (Boolean): Set to True to return the square root of `rho`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values are</span>
<span class="sd">                replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False.</span>
<span class="sd">            rho (Boolean): Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of Rmid. Default is False (return major radius, Rmid).</span>
<span class="sd">                Note that this will have unexpected results if `spline_func`</span>
<span class="sd">                returns anything other than R_mid.</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            time_idxs (Array with same shape as `psi_norm` or None):</span>
<span class="sd">                The time indices to use (as computed by :py:meth:`_processRZt`).</span>
<span class="sd">                Default is None (compute time indices in method).</span>
<span class="sd">            convert_roa (Boolean): When True, it is assumed that `psi_norm` is</span>
<span class="sd">                actually given as r/a and should be converted to Rmid before</span>
<span class="sd">                being passed to the spline for conversion. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (`rho`, `time_idxs`)</span>

<span class="sd">            * **rho** (`Array or scalar float`) - The converted quantity. If</span>
<span class="sd">              all of the input arguments are scalar, then a scalar is returned.</span>
<span class="sd">              Otherwise, a scipy Array is returned.</span>
<span class="sd">            * **time_idxs** (Array with same shape as `rho`) - The indices</span>
<span class="sd">              (in :py:meth:`self.getTimeBase`) that were used for</span>
<span class="sd">              nearest-neighbor interpolation. Only returned if `return_t` is</span>
<span class="sd">              True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">blob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># When called in this manner, this is just like what was done with</span>
            <span class="c1"># rz2psi.</span>
            <span class="p">(</span>
                <span class="n">psi_norm</span><span class="p">,</span>
                <span class="n">dum</span><span class="p">,</span>
                <span class="n">t</span><span class="p">,</span>
                <span class="n">time_idxs</span><span class="p">,</span>
                <span class="n">unique_idxs</span><span class="p">,</span>
                <span class="n">single_time</span><span class="p">,</span>
                <span class="n">single_val</span><span class="p">,</span>
                <span class="n">original_shape</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processRZt</span><span class="p">(</span>
                <span class="n">psi_norm</span><span class="p">,</span>
                <span class="n">psi_norm</span><span class="p">,</span>
                <span class="n">t</span><span class="p">,</span>
                <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">check_space</span><span class="o">=</span><span class="n">check_space</span><span class="p">,</span>
                <span class="n">each_t</span><span class="o">=</span><span class="n">each_t</span><span class="p">,</span>
                <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
                <span class="n">convert_only</span><span class="o">=</span><span class="n">convert_only</span><span class="p">,</span>
                <span class="n">compute_unique</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
                    <span class="n">psi_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi_norm</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">quan_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
                        <span class="n">psi_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span><span class="n">psi_norm</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">quan_norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),</span> <span class="p">],</span> <span class="n">original_shape</span><span class="p">)</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
                            <span class="n">psi_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">psi_tmp</span> <span class="o">=</span> <span class="n">psi_norm</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span><span class="n">psi_tmp</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">quan_norm</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
                        <span class="n">psi_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="n">unique_idxs</span><span class="p">:</span>
                        <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_idxs</span> <span class="o">==</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span><span class="n">psi_norm</span><span class="p">[</span><span class="n">t_mask</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">quan_norm</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">quan_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quan_norm</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">quan_norm</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">quan_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quan_norm</span><span class="p">,</span> <span class="p">(</span>
                        <span class="n">t</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quan_norm</span><span class="p">,</span> <span class="p">(</span>
                        <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                        <span class="n">original_shape</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">quan_norm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When called in this manner, psi_norm has already been expanded</span>
            <span class="c1"># through a pass through rz2psinorm, so we need to be more clever.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">t_proc</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">original_shape</span> <span class="o">=</span> <span class="n">blob</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
                    <span class="n">original_shape</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">blob</span>
            <span class="c1"># Override original_shape with shape of psi_norm:</span>
            <span class="c1"># psi_norm_shape = psi_norm.shape</span>
            <span class="n">psi_norm_flat</span> <span class="o">=</span> <span class="n">psi_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">t_proc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
                    <span class="n">psi_norm_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm_flat</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">t_proc</span><span class="p">,</span> <span class="n">psi_norm_flat</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">quan_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">convert_roa</span><span class="p">:</span>
                    <span class="n">psi_norm_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roa2rmid</span><span class="p">(</span><span class="n">psi_norm_flat</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">each_t</span><span class="p">:</span>
                        <span class="n">psi_norm</span> <span class="o">=</span> <span class="n">psi_norm_flat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span><span class="n">psi_norm_flat</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">single_val</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">quan_norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">),],</span> <span class="n">original_shape</span><span class="p">)</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">):</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span>
                            <span class="n">psi_norm</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">quan_norm</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t_idx</span> <span class="ow">in</span> <span class="n">unique_idxs</span><span class="p">:</span>
                        <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_idxs</span> <span class="o">==</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">spline_func</span><span class="p">(</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span><span class="n">psi_norm_flat</span><span class="p">[</span><span class="n">t_mask</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">rho</span><span class="p">:</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmid2roa</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">)</span>
                        <span class="n">quan_norm</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                    <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">quan_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sqrt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quan_norm</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">quan_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">quan_norm</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">,</span> <span class="n">quan_norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">quan_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quan_norm</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_t</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">quan_norm</span><span class="p">,</span> <span class="n">blob</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">quan_norm</span>

    <span class="k">def</span> <span class="nf">_rmid2roa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Covert the given `R_mid` at the given `time_idxs` to r/a.</span>

<span class="sd">        If you want to use a different definition of r/a, you should override</span>
<span class="sd">        this function and :py:meth:`_roa2rmid`.</span>

<span class="sd">        The definition used here is</span>

<span class="sd">        .. math::</span>

<span class="sd">            r/a = \frac{R_{mid} - R_0}{R_a - R_0} = \frac{R_{mid} - R_0}{a}</span>

<span class="sd">        Args:</span>
<span class="sd">            R_mid (Array or scalar float): Values of outboard midplane major</span>
<span class="sd">                radius to evaluate r/a at.</span>
<span class="sd">            time_idxs (Array, same shape as `R_mid`): If :py:attr:`self._tricubic`</span>
<span class="sd">                is True, this should be an array of the time points to evaluate</span>
<span class="sd">                at. Otherwise, this should be an array of the time INDICES in</span>
<span class="sd">                :py:meth:`getTimeBase` to evaluate at.</span>

<span class="sd">        Returns:</span>
<span class="sd">            roa (Array): Same shape as `R_mid` and `time_idxs`. The normalized minor radius at the given `R_mid`, `t` points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get necessary quantities at the relevant times:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagRSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOutSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>

        <span class="c1"># Compute r/a according to our definition:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">R_mid</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Rout</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_roa2rmid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roa</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Covert the given r/a at the given time_idxs to R_mid.</span>

<span class="sd">        If you want to use a different definition of r/a, you should override</span>
<span class="sd">        this function and :py:meth:`_rmid2roa`.</span>

<span class="sd">        The definition used here is</span>

<span class="sd">        .. math::</span>

<span class="sd">            r/a = \frac{R_{mid} - R_0}{R_a - R_0} = \frac{R_{mid} - R_0}{a}</span>

<span class="sd">        Args:</span>
<span class="sd">            roa (Array or scalar float): Values of normalized minor radius to</span>
<span class="sd">                evaluate R_mid at.</span>
<span class="sd">            time_idxs (Array, same shape as `roa`): If :py:attr:`self._tricubic`</span>
<span class="sd">                is True, this should be an array of the time points to evaluate</span>
<span class="sd">                at. Otherwise, this should be an array of the time INDICES in</span>
<span class="sd">                :py:meth:`getTimeBase` to evaluate at.</span>

<span class="sd">        Returns:</span>
<span class="sd">            R_mid (Array): Same shape as `roa` and `time_idxs`. The mapped midplane major radius at the given `roa`, `t` points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get necessary quantities at the relevant times:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">time_idxs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">magR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagRSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>
            <span class="n">Rout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOutSpline</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)(</span><span class="n">time_idxs</span><span class="p">)</span>

        <span class="c1"># Compute R_mid according to our definition:</span>
        <span class="k">return</span> <span class="n">roa</span> <span class="o">*</span> <span class="p">(</span><span class="n">Rout</span> <span class="o">-</span> <span class="n">magR</span><span class="p">)</span> <span class="o">+</span> <span class="n">magR</span>

    <span class="k">def</span> <span class="nf">_RZ2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert RZ to a given quantity.</span>

<span class="sd">        Utility function for converting R, Z coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular phi_norm, vol_norm and R_mid.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>

<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable): Function which returns a 1d spline for the</span>
<span class="sd">                quantity you want to convert into as a function of psi_norm</span>
<span class="sd">                given a time index.</span>
<span class="sd">            R (Array-like or scalar float): Values of the radial coordinate to</span>
<span class="sd">                map to Quan. If R and Z are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in t. Must have</span>
<span class="sd">                the same shape as Z unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, R must have shape (len_R,).</span>
<span class="sd">            Z (Array-like or scalar float): Values of the vertical coordinate to</span>
<span class="sd">                map to Quan. If R and Z are both scalar values, they are used</span>
<span class="sd">                as the coordinate pair for all of the values in t. Must have</span>
<span class="sd">                the same shape as R unless the make_grid keyword is set. If the</span>
<span class="sd">                make_grid keyword is True, Z must have shape (len_Z,).</span>
<span class="sd">            t (Array-like or single value): If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R, Z. If t is array-like and the</span>
<span class="sd">                make_grid keyword is False, t must have the same dimensions as</span>
<span class="sd">                R and Z. If t is array-like and the make_grid keyword is True,</span>
<span class="sd">                t must have shape (len(Z), len(R)).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `R` and `Z` (or the meshgrid thereof</span>
<span class="sd">                if `make_grid` is True) are evaluated at each value in `t`. If</span>
<span class="sd">                True, `t` must have only one dimension (or be a scalar). If</span>
<span class="sd">                False, `t` must match the shape of `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True) or be a scalar. Default is True</span>
<span class="sd">                (evaluate ALL `R`, `Z` at each element in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (Quan,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return Quan).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of Quan. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            make_grid (Boolean):</span>
<span class="sd">                Set to True to pass R and Z through meshgrid</span>
<span class="sd">                before evaluating. If this is set to True, R and Z must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                When using this option, it is highly recommended to only pass</span>
<span class="sd">                a scalar value for t (such that each point in the flux grid is</span>
<span class="sd">                evaluated at this same value t). Otherwise, t must have the</span>
<span class="sd">                same shape as the resulting meshgrid, and each element in the</span>
<span class="sd">                returned psi array will be at the corresponding time in the t</span>
<span class="sd">                array. Default is False (do not form meshgrid).</span>
<span class="sd">            rho (Boolean):</span>
<span class="sd">                Set to True to return r/a (normalized minor radius)</span>
<span class="sd">                instead of R_mid. Default is False (return major radius, R_mid).</span>
<span class="sd">                Note that this will have unexpected results if spline_func</span>
<span class="sd">                returns anything other than R_mid.</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    =========== ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    =========== ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. If R and Z both have the same shape then</span>
<span class="sd">                Quand has this shape as well. If the make_grid keyword was True</span>
<span class="sd">                then R_mid has shape (len(Z), len(R)).</span>
<span class="sd">            time_idxs: Array with same shape as R_mid. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Not used by rz2psinorm:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Make sure we don&#39;t convert to sqrtpsinorm first!</span>
        <span class="n">sqrt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">blob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>

        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_grid&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="n">spline_func</span><span class="p">,</span>
            <span class="n">psi_norm</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">blob</span><span class="o">=</span><span class="n">blob</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Rmid2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert R_mid to a given quantity.</span>

<span class="sd">        Utility function for converting R, Z coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular phi_norm and vol_norm.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>

<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable):</span>
<span class="sd">                Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            R_mid (Array-like or scalar float):</span>
<span class="sd">                Values of the radial coordinate to map to Quan.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If t is a single value, it is used</span>
<span class="sd">                for all of the elements of R_mid. If t is array-like it must</span>
<span class="sd">                have the same dimensions as R_mid.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `R` and `Z` (or the meshgrid thereof</span>
<span class="sd">                if `make_grid` is True) are evaluated at each value in `t`. If</span>
<span class="sd">                True, `t` must have only one dimension (or be a scalar). If</span>
<span class="sd">                False, `t` must match the shape of `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True) or be a scalar. Default is True</span>
<span class="sd">                (evaluate ALL `R`, `Z` at each element in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (Quan,</span>
<span class="sd">                time_idxs), where time_idxs is the array of time indices</span>
<span class="sd">                actually used in evaluating R_mid with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return Quan).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of Quan. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R and Z are being given</span>
<span class="sd">                in. If a string is given, it must be a valid unit specifier:</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_mid given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Has the same shape as R_mid.</span>
<span class="sd">            time_idxs: Array with same shape as Quan. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if return_t is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Not used by rmid2psinorm:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">sqrt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">blob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmid2psinorm</span><span class="p">(</span><span class="n">R_mid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;convert_roa&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;blob&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">blob</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>

        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_grid&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="n">spline_func</span><span class="p">,</span>
            <span class="n">psi_norm</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_phinorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert phinorm to a given quantity.</span>

<span class="sd">        Utility function for converting phinorm coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular psi_norm and vol_norm.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>

<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable):</span>
<span class="sd">                Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            phinorm (Array-like or scalar float):</span>
<span class="sd">                Values of the normalized toroidal flux to map to `Quan`.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If `t` is a single value, it is used</span>
<span class="sd">                for all of the elements of `phinorm`. If `t` is array-like it</span>
<span class="sd">                must have the same dimensions as `phinorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `phinorm` are evaluated at each value</span>
<span class="sd">                in `t`. If True, `t` must have only one dimension (or be a</span>
<span class="sd">                scalar). If False, `t` must match the shape of `phinorm` or be a</span>
<span class="sd">                scalar. Default is True (evaluate ALL `phinorm` at each element</span>
<span class="sd">                in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (`Quan`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `phinorm` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `Quan`).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of `Quan`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Has the same shape as `phinorm`.</span>
<span class="sd">            time_idxs: Array with same shape as `Quan`. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if `return_t` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Not used by phinorm2psinorm:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">sqrt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">blob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phinorm2psinorm</span><span class="p">(</span><span class="n">phinorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="n">spline_func</span><span class="p">,</span>
            <span class="n">psi_norm</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">blob</span><span class="o">=</span><span class="n">blob</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_volnorm2Quan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spline_func</span><span class="p">,</span> <span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert volnorm to a given quantity.</span>

<span class="sd">        Utility function for converting volnorm coordinates to a variety of things</span>
<span class="sd">        that are interpolated from something measured on a uniform normalized</span>
<span class="sd">        flux grid, in particular psi_norm and phi_norm.</span>

<span class="sd">        If tspline is False for this Equilibrium instance, uses</span>
<span class="sd">        scipy.interpolate.RectBivariateSpline to interpolate in terms of R and</span>
<span class="sd">        Z. Finds the nearest time slices to those given: nearest-neighbor</span>
<span class="sd">        interpolation in time. Otherwise, uses the tricubic package to perform</span>
<span class="sd">        a trivariate interpolation in space and time.</span>

<span class="sd">        Args:</span>
<span class="sd">            spline_func (callable): Function which returns a 1d spline for the quantity</span>
<span class="sd">                you want to convert into as a function of psi_norm given a</span>
<span class="sd">                time index.</span>
<span class="sd">            volnorm (Array-like or scalar float):</span>
<span class="sd">                Values of the normalized volume to map to `Quan`.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If `t` is a single value, it is used</span>
<span class="sd">                for all of the elements of `volnorm`. If `t` is array-like it</span>
<span class="sd">                must have the same dimensions as `volnorm`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `volnorm` are evaluated at each value</span>
<span class="sd">                in `t`. If True, `t` must have only one dimension (or be a</span>
<span class="sd">                scalar). If False, `t` must match the shape of `volnorm` or be a</span>
<span class="sd">                scalar. Default is True (evaluate ALL `volnorm` at each element</span>
<span class="sd">                in `t`).</span>
<span class="sd">            return_t (Boolean):</span>
<span class="sd">                Set to True to return a tuple of (`Quan`,</span>
<span class="sd">                `time_idxs`), where `time_idxs` is the array of time indices</span>
<span class="sd">                actually used in evaluating `phinorm` with nearest-neighbor</span>
<span class="sd">                interpolation. (This is mostly present as an internal helper.)</span>
<span class="sd">                Default is False (only return `Quan`).</span>
<span class="sd">            sqrt (Boolean):</span>
<span class="sd">                Set to True to return the square root of `Quan`. Only</span>
<span class="sd">                the square root of positive values is taken. Negative values</span>
<span class="sd">                are replaced with zeros, consistent with Steve Wolfe&#39;s IDL</span>
<span class="sd">                implementation efit_rz2rho.pro. Default is False (return Quan</span>
<span class="sd">                itself).</span>
<span class="sd">            k (positive int): The degree of polynomial spline interpolation to</span>
<span class="sd">                use in converting coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Quan: Array or scalar float. If all of the input arguments are</span>
<span class="sd">                scalar, then a scalar is returned. Otherwise, a scipy Array</span>
<span class="sd">                instance is returned. Has the same shape as `volnorm`.</span>
<span class="sd">            time_idxs: Array with same shape as `Quan`. The indices (in</span>
<span class="sd">                self.getTimeBase()) that were used for nearest-neighbor</span>
<span class="sd">                interpolation. Only returned if `return_t` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_t&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Not used by phinorm2psinorm:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">sqrt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">psi_norm</span><span class="p">,</span> <span class="n">blob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volnorm2psinorm</span><span class="p">(</span><span class="n">volnorm</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sqrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;return_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_t</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="c1"># Not used by _psinorm2Quan</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length_unit&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psinorm2Quan</span><span class="p">(</span>
            <span class="n">spline_func</span><span class="p">,</span>
            <span class="n">psi_norm</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">blob</span><span class="o">=</span><span class="n">blob</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="c1">####################</span>
    <span class="c1"># Helper Functions #</span>
    <span class="c1">####################</span>

    <span class="k">def</span> <span class="nf">_getLengthConversionFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the conversion factor to convert from units start to units end.</span>

<span class="sd">        Uses a regex to parse units of the form:</span>
<span class="sd">        &#39;m&#39;</span>
<span class="sd">        &#39;m^2&#39;</span>
<span class="sd">        &#39;m2&#39;</span>
<span class="sd">        Leading and trailing spaces are NOT allowed.</span>

<span class="sd">        Valid unit specifiers are:</span>
<span class="sd">            &#39;m&#39;         meters</span>
<span class="sd">            &#39;cm&#39;        centimeters</span>
<span class="sd">            &#39;mm&#39;        millimeters</span>
<span class="sd">            &#39;in&#39;        inches</span>
<span class="sd">            &#39;ft&#39;        feet</span>
<span class="sd">            &#39;yd&#39;        yards</span>
<span class="sd">            &#39;smoot&#39;     smoots</span>
<span class="sd">            &#39;cubit&#39;     cubits</span>
<span class="sd">            &#39;hand&#39;      hands</span>

<span class="sd">        Args:</span>
<span class="sd">            start (String, int or None):</span>
<span class="sd">                Starting unit for the conversion.</span>
<span class="sd">                - If None, uses the unit specified when the instance was created.</span>
<span class="sd">                - If start is an int, the starting unit is taken to be the unit</span>
<span class="sd">                    specified when the instance was created raised to that power.</span>
<span class="sd">                - If start is &#39;default&#39;, either explicitly or because of</span>
<span class="sd">                    reverting to the instance-level unit, then the value passed</span>
<span class="sd">                    in the kwarg default is used. In this case, default must be</span>
<span class="sd">                    a complete unit string (i.e., not None, not an int and not</span>
<span class="sd">                    &#39;default&#39;).</span>
<span class="sd">                - Otherwise, start must be a valid unit specifier as given above.</span>
<span class="sd">            end (String, int or None):</span>
<span class="sd">                Target (ending) unit for the conversion.</span>
<span class="sd">                - If None, uses the unit specified when the instance was created.</span>
<span class="sd">                - If end is an int, the target unit is taken to be the unit</span>
<span class="sd">                    specified when the instance was created raised to that power.</span>
<span class="sd">                - If end is &#39;default&#39;, either explicitly or because of</span>
<span class="sd">                    reverting to the instance-level unit, then the value passed</span>
<span class="sd">                    in the kwarg default is used. In this case, default must be</span>
<span class="sd">                    a complete unit string (i.e., not None, not an int and not</span>
<span class="sd">                    &#39;default&#39;).</span>
<span class="sd">                - Otherwise, end must be a valid unit specifier as given above.</span>
<span class="sd">                    In this case, if end does not specify an exponent, it uses</span>
<span class="sd">                    whatever the exponent on start is. This allows a user to</span>
<span class="sd">                    ask for an area in units of m^2 by specifying</span>
<span class="sd">                    length_unit=&#39;m&#39;, for instance. An error will still be</span>
<span class="sd">                    raised if the user puts in a completely inconsistent</span>
<span class="sd">                    specification such as length_unit=&#39;m^3&#39; or length_unit=&#39;m^1&#39;.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            default (String, int or None):</span>
<span class="sd">                The default unit to use in cases</span>
<span class="sd">                where start or end is &#39;default&#39;. If default is None, an int, or</span>
<span class="sd">                &#39;default&#39;, then the value given for start is used. (A circular</span>
<span class="sd">                definition is prevented for cases in which start is default by</span>
<span class="sd">                checking for this case during the handling of the case</span>
<span class="sd">                start==&#39;default&#39;.)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Conversion factor: Scalar float. The conversion factor to get from</span>
<span class="sd">                the start unit to the end unit.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If start is &#39;default&#39; and default is None, an int, or</span>
<span class="sd">                &#39;default&#39;.</span>
<span class="sd">            ValueError: If the (processed) exponents of start and end or start</span>
<span class="sd">                and default are incompatible.</span>
<span class="sd">            ValueError: If the processed units for start and end are not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Input handling:</span>
        <span class="c1"># Starting unit:</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If start is None, it means to use the instance&#39;s default unit (implied to the power of 1):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
            <span class="c1"># If start is an integer type, this is used as the power applied to the instance&#39;s default unit:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the instance&#39;s default unit is &#39;default&#39;, this is handled next:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="c1"># If start is &#39;default&#39;, the thing passed to default is used, but only if it is a complete unit specification:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">or</span>
                <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must specify a complete unit (i.e., &quot;</span>
                                 <span class="s2">&quot;non-None, non-integer and not &#39;default&#39;) &quot;</span>
                                 <span class="s2">&quot;when using &#39;default&#39; for the starting unit.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">default</span>

        <span class="c1"># Default unit:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">or</span>
            <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span>
        <span class="p">):</span>
            <span class="c1"># If start is &#39;default&#39;, these cases have already been caught above.</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">start</span>

        <span class="c1"># Target (ending) unit:</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If end is None, it means to use the instance&#39;s default unit (implied to the power of 1):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
            <span class="c1"># If end is an integer type, this is used as the power applied to the instance&#39;s default unit:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the instance&#39;s default unit is &#39;default&#39;, this is handled next:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="c1"># If end is &#39;default&#39;, the thing passed to default is used, which</span>
            <span class="c1"># defaults to start, which itself is not allowed to be &#39;default&#39;:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">default</span>

        <span class="n">unit_regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^([A-Za-z]+)\^?([0-9]*)$&#39;</span>

        <span class="c1"># Need to explicitly cast because MDSplus returns its own classes and</span>
        <span class="c1"># re.split doesn&#39;t seem to handle the polymorphism properly:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>

        <span class="n">dum1</span><span class="p">,</span> <span class="n">start_u</span><span class="p">,</span> <span class="n">start_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">dum1</span><span class="p">,</span> <span class="n">end_u</span><span class="p">,</span> <span class="n">end_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">dum1</span><span class="p">,</span> <span class="n">default_u</span><span class="p">,</span> <span class="n">default_pow</span><span class="p">,</span> <span class="n">dum2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">unit_regex</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

        <span class="n">start_pow</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">start_pow</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">start_pow</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_pow</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">end_pow</span> <span class="o">=</span> <span class="n">start_pow</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_pow</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_pow</span><span class="p">)</span>
        <span class="n">default_pow</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">default_pow</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">default_pow</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_pow</span> <span class="o">!=</span> <span class="n">end_pow</span> <span class="ow">or</span> <span class="n">start_pow</span> <span class="o">!=</span> <span class="n">default_pow</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Incompatible exponents between &#39;</span><span class="si">%s</span><span class="s2">&#39;, &#39;</span><span class="si">%s</span><span class="s2">&#39; and &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">default</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">_length_conversion</span><span class="p">[</span><span class="n">start_u</span><span class="p">][</span><span class="n">end_u</span><span class="p">])</span><span class="o">**</span><span class="n">start_pow</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unit &#39;</span><span class="si">%s</span><span class="s2">&#39; is not a recognized length unit!&quot;</span> <span class="o">%</span> <span class="n">end</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_processRZt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">make_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">convert_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_unique</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Input checker/processor.</span>

<span class="sd">        Takes R, Z and t. Appropriately packages them into scipy arrays. Checks</span>
<span class="sd">        the validity of the R, Z ranges. If there is a single time value but</span>
<span class="sd">        multiple R, Z values, creates matching time vector. If there is a single</span>
<span class="sd">        R, Z value but multiple t values, creates matching R and Z vectors.</span>
<span class="sd">        Finds list of nearest-neighbor time indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array-like or scalar float):</span>
<span class="sd">                Values of the radial coordinate. If `R` and `Z` are both scalar</span>
<span class="sd">                values, they are used as the coordinate pair for all of the</span>
<span class="sd">                values in `t`. Must have the same shape as `Z` unless the</span>
<span class="sd">                `make_grid` keyword is True. If `make_grid` is True, `R` must</span>
<span class="sd">                have only one dimension (or be a scalar).</span>
<span class="sd">            Z (Array-like or scalar float):</span>
<span class="sd">                Values of the vertical coordinate. If `R` and `Z` are both</span>
<span class="sd">                scalar values, they are used as the coordinate pair for all of</span>
<span class="sd">                the values in `t`. Must have the same shape as `R` unless the</span>
<span class="sd">                `make_grid` keyword is True. If `make_grid` is True, `Z` must</span>
<span class="sd">                have only one dimension.</span>
<span class="sd">            t (Array-like or single value):</span>
<span class="sd">                If `t` is a single value, it is used for all of the elements of</span>
<span class="sd">                `R`, `Z`. If `t` is array-like and `make_grid` is False, `t`</span>
<span class="sd">                must have the same dimensions as `R` and `Z`. If `t` is</span>
<span class="sd">                array-like and `make_grid` is True, `t` must have shape</span>
<span class="sd">                (len(Z), len(R)).</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            make_grid (Boolean):</span>
<span class="sd">                Set to True to pass `R` and `Z` through :py:func:`meshgrid`</span>
<span class="sd">                before evaluating. If this is set to True, `R` and `Z` must each</span>
<span class="sd">                only have a single dimension, but can have different lengths.</span>
<span class="sd">                Default is False (do not form meshgrid).</span>
<span class="sd">            each_t (Boolean):</span>
<span class="sd">                When True, the elements in `R` and `Z` (or the meshgrid thereof</span>
<span class="sd">                if `make_grid` is True) are evaluated at each value in `t`. If</span>
<span class="sd">                True, `t` must have only one dimension (or be a scalar). If</span>
<span class="sd">                False, `t` must match the shape of `R` and `Z` (or their</span>
<span class="sd">                meshgrid if `make_grid` is True) or be a scalar. Default is True</span>
<span class="sd">                (evaluate ALL `R`, `Z` at each element in `t`).</span>
<span class="sd">            check_space (Boolean):</span>
<span class="sd">                If True, `R` and `Z` are converted to meters and checked against</span>
<span class="sd">                the extents of the spatial grid.</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that `R` and `Z` are being given in. If a string is</span>
<span class="sd">                given, it must be a valid unit specifier:</span>

<span class="sd">                    ===========  ===========</span>
<span class="sd">                    &#39;m&#39;          meters</span>
<span class="sd">                    &#39;cm&#39;         centimeters</span>
<span class="sd">                    &#39;mm&#39;         millimeters</span>
<span class="sd">                    &#39;in&#39;         inches</span>
<span class="sd">                    &#39;ft&#39;         feet</span>
<span class="sd">                    &#39;yd&#39;         yards</span>
<span class="sd">                    &#39;smoot&#39;      smoots</span>
<span class="sd">                    &#39;cubit&#39;      cubits</span>
<span class="sd">                    &#39;hand&#39;       hands</span>
<span class="sd">                    &#39;default&#39;    meters</span>
<span class="sd">                    ===========  ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R and Z given in meters). Note that this factor is</span>
<span class="sd">                ONLY applied to the inputs in this function -- if Quan needs to</span>
<span class="sd">                be corrected, it must be done in the calling function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple of:</span>

<span class="sd">            * **R** - Flattened `R` array with out-of-range values replaced with NaN.</span>
<span class="sd">            * **Z** - Flattened `Z` array with out-of-range values replaced with NaN.</span>
<span class="sd">            * **t** - Flattened `t` array with out-of-range values replaced with NaN.</span>
<span class="sd">            * **time_idxs** - Flattened array of nearest-neighbor time indices.</span>
<span class="sd">              None if :py:attr:`self._tricubic`.</span>
<span class="sd">            * **unique_idxs** - 1d array of the unique values in time_idxs, can</span>
<span class="sd">              be used to save time elsewhere. None if :py:attr:`self._tricubic`.</span>
<span class="sd">            * **single_time** - Boolean indicating whether a single time value</span>
<span class="sd">              is used. If True, then certain simplifying steps can be made and</span>
<span class="sd">              the output should be unwrapped before returning to ensure the</span>
<span class="sd">              least surprise.</span>
<span class="sd">            * **original_shape** - Original shape tuple, used to return the</span>
<span class="sd">              arrays to their starting form. If `single_time` or `each_t` is</span>
<span class="sd">              True, this is the shape of the (expanded) `R`, `Z` arrays. It is</span>
<span class="sd">              assumed that time will be added as the leading dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get everything into sensical datatypes. Must force it to be float to</span>
        <span class="c1"># keep scipy.interpolate happy.</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">single_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">single_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Check the shape of t:</span>
        <span class="k">if</span> <span class="n">each_t</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;_processRZt: When using the each_t keyword, t can have at most &quot;</span>
                <span class="s2">&quot;one dimension!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Form the meshgrid and check the input dimensions as needed:</span>
        <span class="k">if</span> <span class="n">make_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;_processRZt: When using the make_grid keyword, the number &quot;</span>
                    <span class="s2">&quot;of dimensions of R and Z must both be one!&quot;</span>
                <span class="p">)</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;_processRZt: Shape of R and Z arrays must match! Use &quot;</span>
                    <span class="s2">&quot;make_grid=True to form a meshgrid from 1d R, Z arrays.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">single_time</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">each_t</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;_processRZt: Shape of t does not match shape of R and Z!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check that the R, Z points lie within the grid:</span>
        <span class="k">if</span> <span class="n">check_space</span><span class="p">:</span>
            <span class="c1"># Convert units to meters:</span>
            <span class="n">unit_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLengthConversionFactor</span><span class="p">(</span>
                <span class="n">length_unit</span><span class="p">,</span>
                <span class="s1">&#39;m&#39;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="s1">&#39;m&#39;</span>
            <span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">R</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">unit_factor</span> <span class="o">*</span> <span class="n">Z</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">convert_only</span><span class="p">:</span>
                <span class="n">good_points</span><span class="p">,</span> <span class="n">num_good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkRZ</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">num_good</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_processRZt: No valid points!&#39;</span><span class="p">)</span>

                <span class="c1"># Handle bug in older scipy:</span>
                <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">good_points</span><span class="p">:</span>
                        <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">~</span><span class="n">good_points</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">good_points</span><span class="p">:</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">~</span><span class="n">good_points</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="c1"># When using tricubic spline interpolation, the arrays must be</span>
            <span class="c1"># replicated when using the each_t keyword.</span>
            <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">unique_idxs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>
            <span class="c1"># Get nearest-neighbor points:</span>
            <span class="n">time_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getNearestIdx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">timebase</span><span class="p">)</span>
            <span class="c1"># Check errors and warn if needed:</span>
            <span class="n">t_errs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">timebase</span><span class="p">[</span><span class="n">time_idxs</span><span class="p">])</span>
            <span class="c1"># Assume a constant sampling rate to save time:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">t_errs</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">timebase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timebase</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Some time points are off by more than 1/3 the EFIT point &quot;</span>
                    <span class="s2">&quot;spacing. Using nearest-neighbor interpolation between time &quot;</span>
                    <span class="s2">&quot;points. You may want to run EFIT on the timebase you need. &quot;</span>
                    <span class="s2">&quot;Max error: </span><span class="si">%.3f</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">t_errs</span><span class="p">),),</span>
                    <span class="ne">RuntimeWarning</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">compute_unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">single_time</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">each_t</span><span class="p">:</span>
                <span class="n">unique_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time_idxs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_idxs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">time_idxs</span><span class="p">,</span> <span class="n">unique_idxs</span><span class="p">,</span> <span class="n">single_time</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span>
            <span class="n">original_shape</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_checkRZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks whether or not the passed arrays of (R, Z) are within the bounds of the reconstruction data.</span>

<span class="sd">        Returns the mask array of booleans indicating the goodness of each point</span>
<span class="sd">        at the corresponding index. Raises warnings if there are no good_points</span>
<span class="sd">        and if there are some values out of bounds.</span>

<span class="sd">        Assumes R and Z are in meters and that the R and Z arrays returned by</span>
<span class="sd">        this instance&#39;s getRGrid() and getZGrid() are monotonically increasing.</span>

<span class="sd">        Args:</span>
<span class="sd">            R (Array):</span>
<span class="sd">                Radial coordinate to check. Must have the same size as Z.</span>
<span class="sd">            Z (Array)</span>
<span class="sd">                Vertical coordinate to check. Must have the same size as R.</span>

<span class="sd">        Returns:</span>
<span class="sd">            good_points: Boolean array. True where points are within the bounds</span>
<span class="sd">                defined by self.getRGrid and self.getZGrid.</span>
<span class="sd">            num_good: The number of good points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">good_points</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">R</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">Z</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">Z</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># Gracefully handle single-value versus array inputs, returning in the</span>
        <span class="c1"># corresponding type.</span>
        <span class="n">num_good</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_points</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_good</span> <span class="o">=</span> <span class="n">good_points</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: _checkRZ: No valid (R, Z) points!&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_good</span> <span class="o">!=</span> <span class="n">num_pts</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: _checkRZ: Some (R, Z) values out of bounds. &quot;</span>
                          <span class="s2">&quot;(</span><span class="si">%(bad)d</span><span class="s2"> bad out of </span><span class="si">%(tot)d</span><span class="s2">)&quot;</span>
                          <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;bad&#39;</span><span class="p">:</span> <span class="n">num_pts</span> <span class="o">-</span> <span class="n">num_good</span><span class="p">,</span> <span class="s1">&#39;tot&#39;</span><span class="p">:</span> <span class="n">num_pts</span><span class="p">},</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">good_points</span><span class="p">,</span> <span class="n">num_good</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getNearestIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the array of indices of the nearest value in a corresponding to each value in v.</span>

<span class="sd">        If the monotonic keyword in the instance is True, then this is done using</span>
<span class="sd">        scipy.digitize under the assumption that a is monotonic. Otherwise,</span>
<span class="sd">        this is done in a general manner by looking for the minimum distance</span>
<span class="sd">        between the points in v and a.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Array):</span>
<span class="sd">                Input values to match to nearest neighbors in a.</span>
<span class="sd">            a (Array):</span>
<span class="sd">                Given values to match against.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Indices in a of the nearest values to each value in v. Has the same</span>
<span class="sd">                shape as v.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gracefully handle single-value versus array inputs, returning in the</span>
        <span class="c1"># corresponding type.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_monotonic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">val</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(())</span>

    <span class="k">def</span> <span class="nf">_getFluxBiSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the spline corresponding to the given time index, generating as needed.</span>

<span class="sd">        This returns a bivariate spline for when the instance is created with</span>
<span class="sd">        keyword tspline=False.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An instance of scipy.interpolate.RectBivariateSpline corresponding</span>
<span class="sd">                to the given time index idx.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Note the order of the arguments -- psiRZ is stored with t along</span>
            <span class="c1"># the first dimension, Z along the second and R along the third.</span>
            <span class="c1"># This leads to intuitive behavior when contour plotting, but</span>
            <span class="c1"># mandates the syntax here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_getFluxTriSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the tricubic interpolating spline for the flux.</span>

<span class="sd">        This is for use when the instance is created with keyword tspline=True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            trispline.spline to give the flux as a function of R, Z and t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">Spline</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfRZSpline</span>

    <span class="k">def</span> <span class="nf">_getPhiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to phinorm.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz</span>
                <span class="c1"># don&#39;t support the initial keyword to make the initial value</span>
                <span class="c1"># zero:</span>
                <span class="c1"># we need to add the psi axis</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()[</span><span class="n">idx</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">)),</span>
                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz</span>
                <span class="c1"># don&#39;t support the initial keyword to make the initial value</span>
                <span class="c1"># zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])),</span>
                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormSpline</span>

    <span class="k">def</span> <span class="nf">_getPhiNormToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert phinorm to psinorm.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz</span>
                <span class="c1"># don&#39;t support the initial keyword to make the initial value</span>
                <span class="c1"># zero:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()[</span><span class="n">idx</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">phi_norm_meas</span><span class="p">,</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi_norm_meas</span><span class="p">)),</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insert zero at beginning because older versions of cumtrapz</span>
                <span class="c1"># don&#39;t support the initial keyword to make the initial value</span>
                <span class="c1"># zero:</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">phi_norm_meas</span> <span class="o">=</span> <span class="n">phi_norm_meas</span> <span class="o">/</span> <span class="n">phi_norm_meas</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">psinorm_grid</span><span class="p">,</span> <span class="n">t_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">phi_norm_meas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">BivariateInterpolator</span><span class="p">(</span>
                    <span class="n">t_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">phi_norm_meas</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">psinorm_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phiNormToPsiNormSpline</span>

    <span class="k">def</span> <span class="nf">_getVolNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to volnorm.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">)),</span>
                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># BiSpline for time variant interpolation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])),</span>
                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormSpline</span>

    <span class="k">def</span> <span class="nf">_getVolNormToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert volnorm to psinorm.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">vol_norm_meas</span><span class="p">,</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">)),</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># BiSpline for time variant interpolation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()</span>
                <span class="n">vol_norm_meas</span> <span class="o">=</span> <span class="n">vol_norm_meas</span> <span class="o">/</span> <span class="n">vol_norm_meas</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                <span class="n">psinorm_grid</span><span class="p">,</span> <span class="n">t_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol_norm_meas</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">BivariateInterpolator</span><span class="p">(</span>
                    <span class="n">t_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">vol_norm_meas</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">psinorm_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volNormToPsiNormSpline</span>

    <span class="k">def</span> <span class="nf">_getRmidSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        There are two approaches that come to mind:</span>
<span class="sd">            -- In Steve Wolfe&#39;s implementation of efit_rz2mid and efit_psi2rmid,</span>
<span class="sd">                he uses the EFIT output Rmid as a function of normalized flux</span>
<span class="sd">                (i.e., what is returned by self.getRmidPsi()) in the core, then</span>
<span class="sd">                expands the grid beyond this manually.</span>
<span class="sd">            -- A simpler approach would be to just compute the psi_norm(R_mid)</span>
<span class="sd">                grid directly from the radial grid.</span>

<span class="sd">        The latter approach is selected for simplicity.</span>

<span class="sd">        The units of R_mid are always meters, and are converted by the wrapper</span>
<span class="sd">        functions to whatever the user wants.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># New approach: create a fairly dense radial grid from the</span>
                <span class="c1"># global flux grid to avoid 1d interpolation problems in the</span>
                <span class="c1"># core. The bivariate spline seems to be a little more robust</span>
                <span class="c1"># in this respect.</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">resample_factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># Correct for the slight issues at the magnetic axis:</span>
                <span class="n">psi_norm_on_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="c1"># Find if it ever goes non-monotonic: psinorm is assumed to be</span>
                <span class="c1"># strictly INCREASING from the magnetic axis out.</span>
                <span class="n">decr_idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">psi_norm_on_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">psi_norm_on_grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">decr_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="n">psi_norm_on_grid</span><span class="p">[:</span><span class="n">decr_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">R_grid</span> <span class="o">=</span> <span class="n">R_grid</span><span class="p">[:</span><span class="n">decr_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">psi_norm_on_grid</span><span class="p">,</span> <span class="n">R_grid</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>

                <span class="c1"># generate timebase and R_grid through a meshgrid</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,))</span>
                <span class="p">)</span>
                <span class="n">Z_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">R_grid</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">resample_factor</span>
                    <span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span>
                    <span class="n">Z_grid</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">,</span>
                    <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="c1"># Correct for the slight issues at the magnetic axis:</span>
                <span class="n">psi_norm_on_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">BivariateInterpolator</span><span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">psi_norm_on_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                    <span class="n">R_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidSpline</span>

    <span class="k">def</span> <span class="nf">_getRmidToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the spline which converts Rmid to psinorm.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        There are two approaches that come to mind:</span>
<span class="sd">            -- In Steve Wolfe&#39;s implementation of efit_rz2mid and efit_psi2rmid,</span>
<span class="sd">                he uses the EFIT output Rmid as a function of normalized flux</span>
<span class="sd">                (i.e., what is returned by self.getRmidPsi()) in the core, then</span>
<span class="sd">                expands the grid beyond this manually.</span>
<span class="sd">            -- A simpler approach would be to just compute the psi_norm(R_mid)</span>
<span class="sd">                grid directly from the radial grid.</span>

<span class="sd">        The latter approach is selected for simplicity.</span>

<span class="sd">        The units of R_mid are always meters, and are converted by the wrapper</span>
<span class="sd">        functions to whatever the user wants.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># New approach: create a fairly dense radial grid from the global</span>
                <span class="c1"># flux grid to avoid 1d interpolation problems in the core. The</span>
                <span class="c1"># bivariate spline seems to be a little more robust in this respect.</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="c1"># self.getMagR(length_unit=&#39;m&#39;)[idx],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">resample_factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">R_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span> <span class="n">psi_norm_on_grid</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resample_factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>

                <span class="c1"># generate timebase and R_grid through a meshgrid</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">R_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,))</span>
                <span class="p">)</span>
                <span class="n">Z_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">resample_factor</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="c1"># TODO: This can be done much more efficiently!</span>
                    <span class="n">R_grid</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">resample_factor</span>
                    <span class="p">)</span>

                <span class="n">psi_norm_on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rz2psinorm</span><span class="p">(</span>
                    <span class="n">R_grid</span><span class="p">,</span> <span class="n">Z_grid</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">each_t</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">BivariateInterpolator</span><span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">R_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="n">psi_norm_on_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidToPsiNormSpline</span>

    <span class="k">def</span> <span class="nf">_getQSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to q.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)),</span>
                    <span class="n">q</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQProfile</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">q</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qSpline</span>

    <span class="k">def</span> <span class="nf">_getFSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to F.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getF</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)),</span>
                    <span class="n">F</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getF</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">F</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FSpline</span>

    <span class="k">def</span> <span class="nf">_getFNormToPsiNormSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert normalized F to psinorm.</span>

<span class="sd">        This is provided to help plot current densities.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the spline for. This is ASSUMED to be</span>
<span class="sd">                a valid index for the first dimension of :py:meth:`getFluxGrid`,</span>
<span class="sd">                otherwise an :py:class:`IndexError` will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getF</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span> <span class="o">-</span> <span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                <span class="n">psinorm_grid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>
                <span class="c1"># Find if it ever goes non-monotonic: F hacked to be</span>
                <span class="c1"># strictly INCREASING from the magnetic axis out.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCurrentSign</span><span class="p">()</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="n">incr_idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">F</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">incr_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[:</span><span class="n">incr_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">psinorm_grid</span> <span class="o">=</span> <span class="n">psinorm_grid</span><span class="p">[:</span><span class="n">incr_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># Flip it to be INCREASING:</span>
                    <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">psinorm_grid</span> <span class="o">=</span> <span class="n">psinorm_grid</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">decr_idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">F</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">decr_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[:</span><span class="n">decr_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">psinorm_grid</span> <span class="o">=</span> <span class="n">psinorm_grid</span><span class="p">[:</span><span class="n">decr_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">psinorm_grid</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getF</span><span class="p">()</span>
                <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span> <span class="o">-</span> <span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">F</span><span class="p">,</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FToPsinormSpline</span>

    <span class="k">def</span> <span class="nf">_getFFPrimeSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to FFPrime.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">FFPrime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFFPrime</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">FFPrime</span><span class="p">)),</span>
                    <span class="n">FFPrime</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">FFPrime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFFPrime</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">FFPrime</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">FFPrime</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FFPrimeSpline</span>

    <span class="k">def</span> <span class="nf">_getPSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to pressure.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxPres</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span>
                    <span class="n">p</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxPres</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">p</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pSpline</span>

    <span class="k">def</span> <span class="nf">_getPPrimeSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to pressure gradient.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">pprime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPPrime</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pprime</span><span class="p">)),</span>
                    <span class="n">pprime</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pprime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPPrime</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">pprime</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">pprime</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pPrimeSpline</span>

    <span class="k">def</span> <span class="nf">_getVSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get spline to convert psinorm to flux surface volume.</span>

<span class="sd">        Returns the spline object corresponding to the passed time index idx,</span>
<span class="sd">        generating it if it does not already exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (Scalar int):</span>
<span class="sd">                The time index to retrieve the flux spline for.</span>
<span class="sd">                This is ASSUMED to be a valid index for the first dimension of</span>
<span class="sd">                self.getFluxGrid(), otherwise an IndexError will be raised.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`tripline.RectBivariateSpline` depending on whether or</span>
<span class="sd">                not the instance was created with the `tspline` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">spline</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxVol</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vSpline</span>

    <span class="k">def</span> <span class="nf">_getPsi0Spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate psi0 as a function of time.</span>

<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">(),</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getFluxAxis</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfPsi0Spline</span>

    <span class="k">def</span> <span class="nf">_getLCFSPsiSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate psi_a as a function of time.</span>

<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            k (positive int)</span>
<span class="sd">                Polynomial degree of spline to use. Default is 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">(),</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getFluxLCFS</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psiOfLCFSSpline</span>

<div class="viewcode-block" id="Equilibrium.getMagRSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagRSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getMagRSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate R_mag as a function of time.</span>

<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    =========== ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    =========== ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation to be performed in getting</span>
<span class="sd">                from t to R_mag. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation) when</span>
<span class="sd">                `trispline` is True, &#39;nearest&#39; otherwise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d` to convert from t to MagR.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">k</span><span class="o">=</span><span class="mi">3</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagR</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magRSpline</span></div>

<div class="viewcode-block" id="Equilibrium.getMagZSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagZSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getMagZSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate Z_mag as a function of time.</span>

<span class="sd">        Generated for completeness of the core position calculation when using</span>
<span class="sd">        tspline = True</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    =========== ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    =========== ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation to be performed in getting</span>
<span class="sd">                from t to Z_mag. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation) when</span>
<span class="sd">                `trispline` is True, &#39;nearest&#39; otherwise.</span>

<span class="sd">        Returns:</span>

<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d` to convert from t to MagZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">k</span><span class="o">=</span><span class="mi">3</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getMagZ</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magZSpline</span></div>

<div class="viewcode-block" id="Equilibrium.getRmidOutSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidOutSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidOutSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate R_mid_out as a function of time.</span>

<span class="sd">        Generated for completeness of the core position calculation when using</span>
<span class="sd">        tspline = True</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that R_mag is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    =========== ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    =========== ===========</span>

<span class="sd">                If length_unit is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (R_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation to be performed in getting</span>
<span class="sd">                from t to R_mid_out. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation) when</span>
<span class="sd">                `trispline` is True, &#39;nearest&#39; otherwise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d` to convert from t to R_mid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">k</span><span class="o">=</span><span class="mi">3</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getRmidOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span></div>

<div class="viewcode-block" id="Equilibrium.getAOutSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAOutSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getAOutSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate a_out as a function of time.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            length_unit (String or 1):</span>
<span class="sd">                Length unit that a_out is returned in. If</span>
<span class="sd">                a string is given, it must be a valid unit specifier:</span>

<span class="sd">                    ==========  ===========</span>
<span class="sd">                    &#39;m&#39;         meters</span>
<span class="sd">                    &#39;cm&#39;        centimeters</span>
<span class="sd">                    &#39;mm&#39;        millimeters</span>
<span class="sd">                    &#39;in&#39;        inches</span>
<span class="sd">                    &#39;ft&#39;        feet</span>
<span class="sd">                    &#39;yd&#39;        yards</span>
<span class="sd">                    &#39;smoot&#39;     smoots</span>
<span class="sd">                    &#39;cubit&#39;     cubits</span>
<span class="sd">                    &#39;hand&#39;      hands</span>
<span class="sd">                    &#39;default&#39;   meters</span>
<span class="sd">                    ==========  ===========</span>

<span class="sd">                If `length_unit` is 1 or None, meters are assumed. The default</span>
<span class="sd">                value is 1 (a_out returned in meters).</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation to be performed in getting</span>
<span class="sd">                from t to a_out. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation) when</span>
<span class="sd">                `trispline` is True, &#39;nearest&#39; otherwise.</span>

<span class="sd">        Returns:</span>

<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d` to convert from t to a_out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">k</span><span class="o">=</span><span class="mi">3</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">),</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_RmidOutSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getAOut</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AOutSpline</span></div>

<div class="viewcode-block" id="Equilibrium.getBtVacSpline"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtVacSpline">[docs]</a>    <span class="k">def</span> <span class="nf">getBtVacSpline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the univariate spline to interpolate BtVac as a function of time.</span>

<span class="sd">        Only used if the instance was created with keyword tspline=True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            kind (String or non-negative int):</span>
<span class="sd">                Specifies the type of interpolation to be performed in getting</span>
<span class="sd">                from t to BtVac. This is passed to</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d`. Valid options are:</span>
<span class="sd">                &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">                If this keyword is an integer, it specifies the order of spline</span>
<span class="sd">                to use. See the documentation for interp1d for more details.</span>
<span class="sd">                Default value is &#39;cubic&#39; (3rd order spline interpolation) when</span>
<span class="sd">                `trispline` is True, &#39;nearest&#39; otherwise.</span>

<span class="sd">        Returns:</span>

<span class="sd">            :py:class:`trispline.UnivariateInterpolator` or</span>
<span class="sd">                :py:class:`scipy.interpolate.interp1d` to convert from t to BtVac.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tricubic</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span> <span class="o">=</span> <span class="n">trispline</span><span class="o">.</span><span class="n">UnivariateInterpolator</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getBtVac</span><span class="p">(),</span>
                        <span class="n">k</span><span class="o">=</span><span class="mi">3</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getBtVac</span><span class="p">(),</span>
                        <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># created to allow for single time (such as gfiles) to properly</span>
                <span class="c1"># call this method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.</span><span class="p">],</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getBtVac</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BtVacSpline</span></div>

<div class="viewcode-block" id="Equilibrium.getInfo"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getInfo">[docs]</a>    <span class="k">def</span> <span class="nf">getInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns namedtuple of instance parameters (shot, equilibrium type, size, timebase, etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getTimeBase"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getTimeBase">[docs]</a>    <span class="k">def</span> <span class="nf">getTimeBase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns timebase array [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFluxGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        returns 3D grid of psi(r,z,t)</span>
<span class="sd">         The array returned should have the following dimensions:</span>
<span class="sd">           First dimension: time</span>
<span class="sd">           Second dimension: Z</span>
<span class="sd">           Third dimension: R</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getRGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getRGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns vector of R-values for psiRZ grid [r]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getZGrid"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getZGrid">[docs]</a>    <span class="k">def</span> <span class="nf">getZGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns vector of Z-values for psiRZ grid [z]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFluxAxis"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxAxis">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns psi at magnetic axis [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFluxLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns psi a separatrix [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getRLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getRLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns R-positions (n points) mapping LCFS [t,n]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getZLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getZLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getZLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns Z-positions (n points) mapping LCFS [t,n]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.remapLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.remapLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">remapLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Overwrites stored R,Z positions of LCFS with explicitly calculated psinorm=1</span>
<span class="sd">        surface.  This surface is then masked using core.inPolygon() to only draw within</span>
<span class="sd">        vacuum vessel, the end result replacing RLCFS, ZLCFS with an R,Z array showing</span>
<span class="sd">        the divertor legs of the flux surface in addition to the core-enclosing closed</span>
<span class="sd">        flux surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFluxVol"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxVol">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxVol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns volume contained within flux surface as function of psi [psi,t].</span>
<span class="sd">        Psi assumed to be evenly-spaced grid on [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getVolLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getVolLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getVolLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns plasma volume within LCFS [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getRmidPsi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidPsi">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidPsi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns outboard-midplane major radius of flux surface [t,psi]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getF"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getF">[docs]</a>    <span class="k">def</span> <span class="nf">getF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns F=RB_{\Phi}(\Psi), often calculated for grad-shafranov solutions  [psi,t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFluxPres"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFluxPres">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxPres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated pressure profile [psi,t].</span>
<span class="sd">        Psi assumed to be evenly-spaced grid on [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFFPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFFPrime">[docs]</a>    <span class="k">def</span> <span class="nf">getFFPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns FF&#39; function used for grad-shafranov solutions [psi,t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getPPrime"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getPPrime">[docs]</a>    <span class="k">def</span> <span class="nf">getPPrime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns plasma pressure gradient as a function of psi [psi,t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getElongation"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getElongation">[docs]</a>    <span class="k">def</span> <span class="nf">getElongation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns LCFS elongation [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getUpperTriangularity"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getUpperTriangularity">[docs]</a>    <span class="k">def</span> <span class="nf">getUpperTriangularity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns LCFS upper triangularity [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getLowerTriangularity"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getLowerTriangularity">[docs]</a>    <span class="k">def</span> <span class="nf">getLowerTriangularity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns LCFS lower triangularity [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getShaping"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getShaping">[docs]</a>    <span class="k">def</span> <span class="nf">getShaping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns dimensionless shaping parameters for plasma.</span>
<span class="sd">        Namedtuple containing {LCFS elongation, LCFS upper/lower triangularity}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getMagR"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagR">[docs]</a>    <span class="k">def</span> <span class="nf">getMagR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns magnetic-axis major radius [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getMagZ"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMagZ">[docs]</a>    <span class="k">def</span> <span class="nf">getMagZ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns magnetic-axis Z [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getAreaLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAreaLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getAreaLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns LCFS surface area [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getAOut"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getAOut">[docs]</a>    <span class="k">def</span> <span class="nf">getAOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns outboard-midplane minor radius [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getRmidOut"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRmidOut">[docs]</a>    <span class="k">def</span> <span class="nf">getRmidOut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns outboard-midplane major radius [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getGeometry"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getGeometry">[docs]</a>    <span class="k">def</span> <span class="nf">getGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns dimensional geometry parameters</span>
<span class="sd">        Namedtuple containing {mag axis R,Z, LCFS area, volume, outboard-midplane major radius}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQProfile"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQProfile">[docs]</a>    <span class="k">def</span> <span class="nf">getQProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns safety factor q profile [psi,t]</span>
<span class="sd">        Psi assumed to be evenly-spaced grid on [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQ0"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ0">[docs]</a>    <span class="k">def</span> <span class="nf">getQ0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns q on magnetic axis [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQ95"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ95">[docs]</a>    <span class="k">def</span> <span class="nf">getQ95</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns q on 95% flux surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQLCFS"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQLCFS">[docs]</a>    <span class="k">def</span> <span class="nf">getQLCFS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns q on LCFS [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQ1Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ1Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ1Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns outboard-midplane minor radius of q=1 surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQ2Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ2Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ2Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns outboard-midplane minor radius of q=2 surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQ3Surf"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQ3Surf">[docs]</a>    <span class="k">def</span> <span class="nf">getQ3Surf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns outboard-midplane minor radius of q=3 surface [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getQs"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getQs">[docs]</a>    <span class="k">def</span> <span class="nf">getQs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns specific q-profile values.</span>
<span class="sd">        Namedtuple containing {q0, q95, qLCFS, minor radius of q=1,2,3 surfaces}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBtVac"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtVac">[docs]</a>    <span class="k">def</span> <span class="nf">getBtVac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns vacuum on-axis toroidal field [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBtPla"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBtPla">[docs]</a>    <span class="k">def</span> <span class="nf">getBtPla</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns plasma on-axis toroidal field [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBpAvg"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBpAvg">[docs]</a>    <span class="k">def</span> <span class="nf">getBpAvg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns average poloidal field [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getFields"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getFields">[docs]</a>    <span class="k">def</span> <span class="nf">getFields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns magnetic-field values.</span>
<span class="sd">        Namedtuple containing {Btor on magnetic axis (plasma and vacuum), avg Bpol}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getIpCalc"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getIpCalc">[docs]</a>    <span class="k">def</span> <span class="nf">getIpCalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated plasma current [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getIpMeas"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getIpMeas">[docs]</a>    <span class="k">def</span> <span class="nf">getIpMeas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns measured plasma current [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getJp"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getJp">[docs]</a>    <span class="k">def</span> <span class="nf">getJp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns grid of calculated toroidal current density [t,z,r]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBetaT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetaT">[docs]</a>    <span class="k">def</span> <span class="nf">getBetaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated global toroidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBetaP"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetaP">[docs]</a>    <span class="k">def</span> <span class="nf">getBetaP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated global poloidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getLi"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getLi">[docs]</a>    <span class="k">def</span> <span class="nf">getLi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated internal inductance of plasma [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBetas"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBetas">[docs]</a>    <span class="k">def</span> <span class="nf">getBetas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated betas and inductance.</span>
<span class="sd">        Namedtuple of {betat,betap,Li}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getDiamagFlux"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns diamagnetic flux [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getDiamagBetaT"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagBetaT">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagBetaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns diamagnetic-loop toroidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getDiamagBetaP"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagBetaP">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagBetaP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns diamagnetic-loop poloidal beta [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getDiamagTauE"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagTauE">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagTauE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns diamagnetic-loop energy confinement time [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getDiamagWp"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamagWp">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamagWp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns diamagnetic-loop plasma stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getDiamag"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getDiamag">[docs]</a>    <span class="k">def</span> <span class="nf">getDiamag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns diamagnetic measurements of plasma parameters.</span>
<span class="sd">        Namedtuple of {diamag. flux, betat, betap from coils, tau_E from diamag., diamag. stored energy}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getWMHD"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWMHD">[docs]</a>    <span class="k">def</span> <span class="nf">getWMHD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated MHD stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getTauMHD"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getTauMHD">[docs]</a>    <span class="k">def</span> <span class="nf">getTauMHD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated MHD energy confinement time [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getPinj"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getPinj">[docs]</a>    <span class="k">def</span> <span class="nf">getPinj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated injected power [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getCurrentSign"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getCurrentSign">[docs]</a>    <span class="k">def</span> <span class="nf">getCurrentSign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated current direction, where CCW = +</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getWbdot"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWbdot">[docs]</a>    <span class="k">def</span> <span class="nf">getWbdot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated d/dt of magnetic stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getWpdot"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getWpdot">[docs]</a>    <span class="k">def</span> <span class="nf">getWpdot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns calculated d/dt of plasma stored energy [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getBCentr"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getBCentr">[docs]</a>    <span class="k">def</span> <span class="nf">getBCentr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns Vacuum Toroidal magnetic field at Rcent point [t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getRCentr"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getRCentr">[docs]</a>    <span class="k">def</span> <span class="nf">getRCentr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Radial position for Vacuum Toroidal magnetic field calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getEnergy"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getEnergy">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns stored-energy parameters.</span>
<span class="sd">        Namedtuple of {stored energy, confinement time, injected power, d/dt of magnetic, plasma stored energy}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getParam"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getParam">[docs]</a>    <span class="k">def</span> <span class="nf">getParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Backup function: takes parameter name for variable, returns variable directly.</span>
<span class="sd">        Acts as wrapper to direct data-access routines from within object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># backup function - takes parameter name for EFIT variable, returns that variable</span>
        <span class="c1"># acts as wrapper for EFIT tree access from within object</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getMachineCrossSection"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMachineCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getMachineCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns (R,Z) coordinates of vacuum wall cross-section for plotting/masking routines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Equilibrium.getMachineCrossSectionFull"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.getMachineCrossSectionFull">[docs]</a>    <span class="k">def</span> <span class="nf">getMachineCrossSectionFull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method.  See child classes for implementation.</span>

<span class="sd">        Returns (R,Z) coordinates of machine wall cross-section for plotting routines.</span>
<span class="sd">        Returns a more detailed cross-section than getLimiter(), generally a vector map</span>
<span class="sd">        displaying non-critical cross-section information.  If this is unavailable, this</span>
<span class="sd">        should point to self.getMachineCrossSection(), which pulls the limiter outline</span>
<span class="sd">        stored by default in data files e.g. g-eqdsk files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;function to return machine cross-section not implemented for &quot;</span>
            <span class="s2">&quot;this class yet!&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.gfile"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.gfile">[docs]</a>    <span class="k">def</span> <span class="nf">gfile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tunit</span><span class="o">=</span><span class="s1">&#39;ms&#39;</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s1">&#39;EQTOOLS&#39;</span><span class="p">,</span> <span class="n">nbbbs</span><span class="o">=</span><span class="mi">100</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates an EFIT gfile with gfile naming convention</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            time (scalar float): Time of equilibrium to</span>
<span class="sd">                generate the gfile from. This will use the specified</span>
<span class="sd">                spline functionality to do so. Allows for it to be</span>
<span class="sd">                unspecified for single-time-frame equilibria.</span>
<span class="sd">            nw (scalar integer): Number of points in R.</span>
<span class="sd">                R is the major radius, and describes the &#39;width&#39; of the</span>
<span class="sd">                gfile.</span>
<span class="sd">            nh (scalar integer): Number of points in Z. In cylindrical</span>
<span class="sd">                coordinates Z is the height, and nh describes the &#39;height&#39;</span>
<span class="sd">                of the gfile.</span>
<span class="sd">            shot (scalar integer): The shot numer of the equilibrium.</span>
<span class="sd">                Used to help generate the gfile name if unspecified.</span>
<span class="sd">            name (String): Name of the gfile.  If unspecified, will follow</span>
<span class="sd">                standard gfile naming convention (g+shot.time) under current</span>
<span class="sd">                python operating directory.  This allows for it to be saved</span>
<span class="sd">                in other directories, etc.</span>
<span class="sd">            tunit (String): Specified unit for tin. It can only be &#39;ms&#39; for</span>
<span class="sd">                milliseconds or &#39;s&#39; for seconds.</span>
<span class="sd">            title (String): Title of the gfile on the first line. Name cannot</span>
<span class="sd">                exceed 10 digits. This is so that the style of the first line</span>
<span class="sd">                is preserved.</span>
<span class="sd">            nbbbs (scalar integer): Number of points to define the plasma</span>
<span class="sd">                seperatrix within the gfile.  The points are defined equally</span>
<span class="sd">                spaced in angle about the plasma center.  This will cause the</span>
<span class="sd">                x-point to be poorly defined.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If title is longer than 10 characters.</span>

<span class="sd">        Examples:</span>
<span class="sd">            All assume that `Eq_instance` is a valid instance of the appropriate</span>
<span class="sd">            extension of the :py:class:`Equilibrium` abstract class (example</span>
<span class="sd">            shot number of 1001).</span>

<span class="sd">            Generate a gfile at t=0.26s, output of g1001.26::</span>

<span class="sd">                Eq_instance.gfile(.26)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gfile</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">nw</span><span class="o">=</span><span class="n">nw</span><span class="p">,</span>
            <span class="n">nh</span><span class="o">=</span><span class="n">nh</span><span class="p">,</span>
            <span class="n">shot</span><span class="o">=</span><span class="n">shot</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">tunit</span><span class="o">=</span><span class="n">tunit</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">nbbbs</span><span class="o">=</span><span class="n">nbbbs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Equilibrium.plotFlux"><a class="viewcode-back" href="../../eqtools.html#eqtools.core.Equilibrium.plotFlux">[docs]</a>    <span class="k">def</span> <span class="nf">plotFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">add_title</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots flux contours directly from psi grid.</span>

<span class="sd">        Returns the Figure instance created and the time slider widget (in case</span>
<span class="sd">        you need to modify the callback). `f.axes` contains the contour plot as</span>
<span class="sd">        the first element and the time slice slider as the second element.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            fill (Boolean):</span>
<span class="sd">                Set True to plot filled contours.  Set False (default) to plot white-background</span>
<span class="sd">                color contours.</span>
<span class="sd">            mask (Boolean):</span>
<span class="sd">                Set True (default) to mask the contours according to the vacuum</span>
<span class="sd">                vessel outline.</span>
<span class="sd">            lw (float):</span>
<span class="sd">                Linewidth when plotting LCFS. Default is 3.0.</span>
<span class="sd">            add_title (Boolean):</span>
<span class="sd">                Set True (default) to add a figure title with the time indicated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">psiRZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluxGrid</span><span class="p">()</span>
            <span class="n">rGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">zGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZGrid</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeBase</span><span class="p">()</span>

            <span class="n">RLCFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRLCFS</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">ZLCFS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZLCFS</span><span class="p">(</span><span class="n">length_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;cannot plot EFIT flux map.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">limx</span><span class="p">,</span> <span class="n">limy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMachineCrossSection</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No machine cross-section implemented!&#39;</span><span class="p">)</span>
            <span class="n">limx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">limy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">macx</span><span class="p">,</span> <span class="n">macy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMachineCrossSectionFull</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">macx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">macy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># event handler for arrow key events in plot windows.  Pass slider object</span>
        <span class="c1"># to update as masked argument using lambda function</span>
        <span class="c1"># lambda evt: arrow_respond(my_slider,evt)</span>
        <span class="k">def</span> <span class="nf">arrowRespond</span><span class="p">(</span><span class="n">slider</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmax</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmin</span><span class="p">))</span>

        <span class="c1"># make time-slice window</span>
        <span class="n">fluxPlot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">psi</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">timeSliderSub</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">add_title</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">fluxPlot</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># dummy plot to get x,ylims</span>
        <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span> <span class="n">zGrid</span><span class="p">,</span> <span class="n">psiRZ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># generate graphical mask for limiter wall</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="n">bound_verts</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">poly_verts</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">limx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">limy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">bound_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span>
            <span class="n">poly_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span>

            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span>
                <span class="n">bound_verts</span> <span class="o">+</span> <span class="n">poly_verts</span><span class="p">,</span> <span class="n">bound_codes</span> <span class="o">+</span> <span class="n">poly_codes</span>
            <span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span>
                <span class="n">path</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">updateTime</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">t_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timeSlider</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">add_title</span><span class="p">:</span>
                <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span>
                    <span class="s1">&#39;EFIT Reconstruction, $t = </span><span class="si">%(t).2f</span><span class="s1">$ s&#39;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]}</span>
                <span class="p">)</span>

            <span class="n">psi</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$R$ [m]&#39;</span><span class="p">)</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$Z$ [m]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">macx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">macx</span><span class="p">,</span> <span class="n">macy</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">limx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">limx</span><span class="p">,</span> <span class="n">limy</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="c1"># catch NaNs separating disjoint sections of R,ZLCFS in mask</span>
            <span class="n">maskarr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">RLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]))</span>
            <span class="p">)</span>
            <span class="n">RLCFSframe</span> <span class="o">=</span> <span class="n">RLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">maskarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ZLCFSframe</span> <span class="o">=</span> <span class="n">ZLCFS</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">maskarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">RLCFSframe</span><span class="p">,</span> <span class="n">ZLCFSframe</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">rGrid</span><span class="p">,</span> <span class="n">zGrid</span><span class="p">,</span> <span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
                    <span class="n">rGrid</span><span class="p">,</span> <span class="n">zGrid</span><span class="p">,</span> <span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                    <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
                    <span class="n">rGrid</span><span class="p">,</span> <span class="n">zGrid</span><span class="p">,</span> <span class="n">psiRZ</span><span class="p">[</span><span class="n">t_idx</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">patchdraw</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="n">patchdraw</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">fluxPlot</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="n">timeSlider</span> <span class="o">=</span> <span class="n">mplw</span><span class="o">.</span><span class="n">Slider</span><span class="p">(</span>
            <span class="n">timeSliderSub</span><span class="p">,</span> <span class="s1">&#39;t index&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">valinit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">valfmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">timeSlider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">updateTime</span><span class="p">)</span>
        <span class="n">updateTime</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fluxPlot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">fluxPlot</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
            <span class="s1">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">evt</span><span class="p">:</span> <span class="n">arrowRespond</span><span class="p">(</span><span class="n">timeSlider</span><span class="p">,</span> <span class="n">evt</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fluxPlot</span><span class="p">,</span> <span class="n">timeSlider</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">eqtools 1.3.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Mark Chilenski, Ian Faust and John Walk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>