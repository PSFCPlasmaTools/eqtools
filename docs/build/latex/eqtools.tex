% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\hypersetup{bookmarksdepth=3}

\title{eqtools Documentation}
\date{November 10, 2016}
\release{1.1}
\author{Mark Chilenski, Ian Faust and John Walk}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Homepage: \href{https://github.com/PSFCPlasmaTools/eqtools}{https://github.com/PSFCPlasmaTools/eqtools}


\chapter{Overview}
\label{index:overview}\label{index:eqtools-tools-for-interacting-with-magnetic-equilibria}
{\hyperref[eqtools:module-eqtools]{\code{eqtools}}} is a Python package for working with magnetic equilibrium reconstructions from magnetic plasma confinement devices. At present, interfaces exist for data from the Alcator C-Mod and NSTX MDSplus trees as well as eqdsk a- and g-files. {\hyperref[eqtools:module-eqtools]{\code{eqtools}}} is designed to be flexible and extensible such that it can become a uniform interface to perform mapping operations and accessing equilibrium data for any magnetic confinement device, regardless of how the data are accessed.

The main class of {\hyperref[eqtools:module-eqtools]{\code{eqtools}}} is the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}}, which contains all of the coordinate mapping functions as well as templates for methods to fetch data (primarily dictated to the quantities computed by EFIT). Subclasses such as {\hyperref[eqtools:eqtools.EFIT.EFITTree]{\code{EFITTree}}}, {\hyperref[eqtools:eqtools.CModEFIT.CModEFITTree]{\code{CModEFITTree}}}, {\hyperref[eqtools:eqtools.NSTXEFIT.NSTXEFITTree]{\code{NSTXEFITTree}}} and {\hyperref[eqtools:eqtools.eqdskreader.EqdskReader]{\code{EqdskReader}}} implement specific methods to access the data and convert it to the form needed for the routines in {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}}. These classes are smart about caching intermediate results, so you will get a performance boost by using the same instance throughout your analysis of a given shot.


\chapter{Installation}
\label{index:installation}
The easiest way to install the latest release version is with \emph{pip}:

\begin{Verbatim}[commandchars=\\\{\}]
pip install eqtools
\end{Verbatim}

To install from source, uncompress the source files and, from the directory containing \emph{setup.py}, run the following command:

\begin{Verbatim}[commandchars=\\\{\}]
python setup.py install
\end{Verbatim}

Or, to build in place, run:

\begin{Verbatim}[commandchars=\\\{\}]
python setup.py build\_ext --inplace
\end{Verbatim}


\chapter{Tutorial: Performing Coordinate Transforms on Alcator C-Mod Data}
\label{index:tutorial-performing-coordinate-transforms-on-alcator-c-mod-data}
The basic class for manipulating EFIT results stored in the Alcator C-Mod MDSplus tree is {\hyperref[eqtools:eqtools.CModEFIT.CModEFITTree]{\code{CModEFITTree}}}. To load the data from a specific shot, simply create the {\hyperref[eqtools:eqtools.CModEFIT.CModEFITTree]{\code{CModEFITTree}}} object with the shot number as the argument:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e} \PYG{o}{=} \PYG{n}{eqtools}\PYG{o}{.}\PYG{n}{CModEFITTree}\PYG{p}{(}\PYG{l+m+mi}{1140729030}\PYG{p}{)}
\end{Verbatim}

The default EFIT to use is ``ANALYSIS.'' If you want to use a different tree, such as ``EFIT20,'' then you simply set this with the \emph{tree} keyword:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e} \PYG{o}{=} \PYG{n}{eqtools}\PYG{o}{.}\PYG{n}{CModEFITTree}\PYG{p}{(}\PYG{l+m+mi}{1140729030}\PYG{p}{,} \PYG{n}{tree}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EFIT20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

{\hyperref[eqtools:module-eqtools]{\code{eqtools}}} understands units. The default is to convert all lengths to meters (whereas quantities in the tree are inconsistent -- some are meters, some centimeters). If you want to specify a different default unit, use the \emph{length\_unit} keyword:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e} \PYG{o}{=} \PYG{n}{eqtools}\PYG{o}{.}\PYG{n}{CModEFITTree}\PYG{p}{(}\PYG{l+m+mi}{1140729030}\PYG{p}{,} \PYG{n}{length\PYGZus{}unit}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Once this is loaded, you can access the data you would normally have to pull from specific nodes in the tree using convenient getter methods. For instance, to get the elongation as a function of time, you can run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{kappa} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{getElongation}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The timebase used for quantities like this is accessed with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{getTimeBase}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

For length/area/volume quantities, {\hyperref[eqtools:module-eqtools]{\code{eqtools}}} understands units. The default is to return in whatever units you specified when creating the {\hyperref[eqtools:eqtools.CModEFIT.CModEFITTree]{\code{CModEFITTree}}}, but you can override this with the \emph{length\_unit} keyword. For instance, to get the vertical position of the magnetic axis in mm, you can run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Z\PYGZus{}mag} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{getMagZ}\PYG{p}{(}\PYG{n}{length\PYGZus{}unit}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

{\hyperref[eqtools:module-eqtools]{\code{eqtools}}} can map from almost any coordinate to any common flux surface label. For instance, say you want to know what the square root of normalized toroidal flux corresponding to a normalized flux surface volume of 0.5 is at t=1.0s. You can simply call:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rho} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{volnorm2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{sqrt}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

If a list of times is provided, the default behavior is to evaluate all of the points to be converted at each of the times. So, to follow the mapping of normalized poloidal flux values {[}0.1, 0.5, 1.0{]} to outboard midplane major radius at time points {[}1.0, 1.25, 1.5, 1.75{]}, you could call:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.75}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

This will return a 4-by-3 array: one row for each time, one column for each location. If you want to override this behavior and instead consider a sequence of (psi, t) points, set the \emph{each\_t} keyword to False:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.35}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

This will return a two-element array with the Rmid values for (psinorm=0.3, t=1.0) and (psinorm=0.35, t=1.1).

For programmatically mapping between coordinates, the {\hyperref[eqtools:eqtools.core.Equilibrium.rho2rho]{\code{rho2rho()}}} method is quite useful. To map from outboard midplane major radius to normalized flux surface volume, you can simply call:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e}\PYG{o}{.}\PYG{n}{rho2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Rmid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volnorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\end{Verbatim}

Finally, to get a look at the flux surfaces, simply run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e}\PYG{o}{.}\PYG{n}{plotFlux}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{Package Reference}
\label{index:package-reference}

\section{eqtools package}
\label{eqtools::doc}\label{eqtools:eqtools-package}

\subsection{Submodules}
\label{eqtools:submodules}

\subsection{eqtools.CModEFIT module}
\label{eqtools:module-eqtools.CModEFIT}\label{eqtools:eqtools-cmodefit-module}\index{eqtools.CModEFIT (module)}
This module provides classes for working with C-Mod EFIT data.
\index{CModEFITTree (class in eqtools.CModEFIT)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree}\pysiglinewithargsret{\strong{class }\code{eqtools.CModEFIT.}\bfcode{CModEFITTree}}{\emph{shot}, \emph{tree='ANALYSIS'}, \emph{length\_unit='m'}, \emph{gfile='g\_eqdsk'}, \emph{afile='a\_eqdsk'}, \emph{tspline=False}, \emph{monotonic=False}}{}
Bases: {\hyperref[eqtools:eqtools.EFIT.EFITTree]{\code{eqtools.EFIT.EFITTree}}}

Inherits \code{EFITTree} class. Machine-specific data
handling class for Alcator C-Mod. Pulls EFIT data from selected MDS tree
and shot, stores as object attributes. Each EFIT variable or set of
variables is recovered with a corresponding getter method. Essential data
for EFIT mapping are pulled on initialization (e.g. psirz grid). Additional
data are pulled at the first request and stored for subsequent usage.

Intializes C-Mod version of EFITTree object.  Pulls data from MDS tree for storage
in instance attributes.  Core attributes are populated from the MDS tree on initialization.
Additional attributes are initialized as None, filled on the first request to the object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{shot} -- (long) int
C-Mod shot index (long)

\item {} 
\textbf{tree} -- str
Optional input for EFIT tree, defaults to `ANALYSIS'
(i.e., EFIT data are under analysis::top.efit.results).
For any string TREE (such as `EFIT20') other than `ANALYSIS',
data are taken from TREE::top.results.

\item {} 
\textbf{length\_unit} -- 
str
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
whatever the default in the tree is (no conversion is performed, units may be inconsistent)
\\
\hline\end{tabulary}

\end{quote}

Default is `m' (all units taken and returned in meters).


\item {} 
\textbf{gfile} -- str
Optional input for EFIT geqdsk location name, defaults to `g\_eqdsk'
(i.e., EFIT data are under tree::top.results.G\_EQDSK)

\item {} 
\textbf{afile} -- str
Optional input for EFIT aeqdsk location name, defaults to `a\_eqdsk'
(i.e., EFIT data are under tree::top.results.A\_EQDSK)

\item {} 
\textbf{tspline} -- Boolean
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).

\item {} 
\textbf{monotonic} -- Boolean
Sets whether or not the ``monotonic'' form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).

\end{itemize}

\end{description}\end{quote}
\index{getFluxVol() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getFluxVol}\pysiglinewithargsret{\bfcode{getFluxVol}}{\emph{length\_unit=3}}{}
returns volume within flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getRmidPsi() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getRmidPsi}\pysiglinewithargsret{\bfcode{getRmidPsi}}{\emph{length\_unit=1}}{}
returns maximum major radius of each flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getF() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getF}\pysiglinewithargsret{\bfcode{getF}}{}{}
returns F=RB\_\{Phi\}(Psi), often calculated for grad-shafranov solutions  {[}t,psi{]}

\end{fulllineitems}

\index{getFluxPres() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getFluxPres}\pysiglinewithargsret{\bfcode{getFluxPres}}{}{}
returns pressure at flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getFFPrime() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getFFPrime}\pysiglinewithargsret{\bfcode{getFFPrime}}{}{}
returns FF' function used for grad-shafranov solutions {[}t,psi{]}

\end{fulllineitems}

\index{getPPrime() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getPPrime}\pysiglinewithargsret{\bfcode{getPPrime}}{}{}
returns plasma pressure gradient as a function of psi {[}t,psi{]}

\end{fulllineitems}

\index{getQProfile() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getQProfile}\pysiglinewithargsret{\bfcode{getQProfile}}{}{}
returns safety factor q {[}t,psi{]}

\end{fulllineitems}

\index{getRLCFS() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getRLCFS}\pysiglinewithargsret{\bfcode{getRLCFS}}{\emph{length\_unit=1}}{}
returns R-values of LCFS position {[}t,n{]}

\end{fulllineitems}

\index{getZLCFS() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getZLCFS}\pysiglinewithargsret{\bfcode{getZLCFS}}{\emph{length\_unit=1}}{}
returns Z-values of LCFS position {[}t,n{]}

\end{fulllineitems}

\index{getMachineCrossSectionFull() (eqtools.CModEFIT.CModEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTree.getMachineCrossSectionFull}\pysiglinewithargsret{\bfcode{getMachineCrossSectionFull}}{}{}
Pulls C-Mod cross-section data from tree, converts to plottable
vector format for use in other plotting routines
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{shot} -- (long) int
C-Mod shot index (used for tree access)

\item[{Returns}] \leavevmode
The coordinates of the machine cross-section.

\item[{Return type}] \leavevmode
(x, y)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CModEFITTreeProp (class in eqtools.CModEFIT)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.CModEFIT.CModEFITTreeProp}\pysiglinewithargsret{\strong{class }\code{eqtools.CModEFIT.}\bfcode{CModEFITTreeProp}}{\emph{shot}, \emph{tree='ANALYSIS'}, \emph{length\_unit='m'}, \emph{gfile='g\_eqdsk'}, \emph{afile='a\_eqdsk'}, \emph{tspline=False}, \emph{monotonic=False}}{}
Bases: {\hyperref[eqtools:eqtools.CModEFIT.CModEFITTree]{\code{eqtools.CModEFIT.CModEFITTree}}}, {\hyperref[eqtools:eqtools.core.PropertyAccessMixin]{\code{eqtools.core.PropertyAccessMixin}}}

CModEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.

\end{fulllineitems}



\subsection{eqtools.D3DEFIT module}
\label{eqtools:eqtools-d3defit-module}

\subsection{eqtools.EFIT module}
\label{eqtools:eqtools-efit-module}\label{eqtools:module-eqtools.EFIT}\index{eqtools.EFIT (module)}\index{EFITTree (class in eqtools.EFIT)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree}\pysiglinewithargsret{\strong{class }\code{eqtools.EFIT.}\bfcode{EFITTree}}{\emph{shot}, \emph{tree}, \emph{root}, \emph{length\_unit='m'}, \emph{gfile='g\_eqdsk'}, \emph{afile='a\_eqdsk'}, \emph{tspline=False}, \emph{monotonic=False}}{}
Bases: {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{eqtools.core.Equilibrium}}}

Inherits Equilibrium class. EFIT-specific data handling class for machines using
standard EFIT tag names/tree structure with MDSplus. Constructor and/or data loading may
need overriding in a machine-specific implementation.
Pulls EFIT data from selected MDS tree and shot, stores as object attributes.
Each EFIT variable or set of variables is recovered with a corresponding getter method.
Essential data for EFIT mapping are pulled on initialization (e.g. psirz grid).
Additional data are pulled at the first request and stored for subsequent usage.

Intializes EFITTree object. Pulls data from MDS tree for storage in
instance attributes. Core attributes are populated from the MDS tree
on initialization. Additional attributes are initialized as None,
filled on the first request to the object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{shot} -- int
shot number

\item {} 
\textbf{tree} -- tree
MDSplus tree to open to fetch EFIT data.

\item {} 
\textbf{root} -- str
Root path for EFIT data in MDSplus tree.

\item {} 
\textbf{length\_unit} -- 
String.
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
whatever the default in the tree is (no conversion is performed, units may be inconsistent)
\\
\hline\end{tabulary}

\end{quote}

Default is `m' (all units taken and returned in meters).


\item {} 
\textbf{tspline} -- Boolean.
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).

\item {} 
\textbf{monotonic} -- Boolean.
Sets whether or not the ``monotonic'' form of time window
finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).

\end{itemize}

\end{description}\end{quote}
\index{getInfo() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getInfo}\pysiglinewithargsret{\bfcode{getInfo}}{}{}
returns namedtuple of shot information
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

namedtuple containing
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

shot
 & 
C-Mod shot index (long)
\\

tree
 & 
EFIT tree (string)
\\

nr
 & 
size of R-axis for spatial grid
\\

nz
 & 
size of Z-axis for spatial grid
\\

nt
 & 
size of timebase for flux grid
\\
\hline\end{tabulary}

\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{getTimeBase() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getTimeBase}\pysiglinewithargsret{\bfcode{getTimeBase}}{}{}
returns EFIT time base vector

\end{fulllineitems}

\index{getFluxGrid() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFluxGrid}\pysiglinewithargsret{\bfcode{getFluxGrid}}{}{}
returns EFIT flux grid, {[}t,z,r{]}

\end{fulllineitems}

\index{getRGrid() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getRGrid}\pysiglinewithargsret{\bfcode{getRGrid}}{\emph{length\_unit=1}}{}
returns EFIT R-axis {[}r{]}

\end{fulllineitems}

\index{getZGrid() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getZGrid}\pysiglinewithargsret{\bfcode{getZGrid}}{\emph{length\_unit=1}}{}
returns EFIT Z-axis {[}z{]}

\end{fulllineitems}

\index{getFluxAxis() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFluxAxis}\pysiglinewithargsret{\bfcode{getFluxAxis}}{}{}
returns psi on magnetic axis {[}t{]}

\end{fulllineitems}

\index{getFluxLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFluxLCFS}\pysiglinewithargsret{\bfcode{getFluxLCFS}}{}{}
returns psi at separatrix {[}t{]}

\end{fulllineitems}

\index{getFluxVol() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFluxVol}\pysiglinewithargsret{\bfcode{getFluxVol}}{\emph{length\_unit=3}}{}
returns volume within flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getVolLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getVolLCFS}\pysiglinewithargsret{\bfcode{getVolLCFS}}{\emph{length\_unit=3}}{}
returns volume within LCFS {[}t{]}

\end{fulllineitems}

\index{getRmidPsi() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getRmidPsi}\pysiglinewithargsret{\bfcode{getRmidPsi}}{\emph{length\_unit=1}}{}
returns maximum major radius of each flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getRLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getRLCFS}\pysiglinewithargsret{\bfcode{getRLCFS}}{\emph{length\_unit=1}}{}
returns R-values of LCFS position {[}t,n{]}

\end{fulllineitems}

\index{getZLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getZLCFS}\pysiglinewithargsret{\bfcode{getZLCFS}}{\emph{length\_unit=1}}{}
returns Z-values of LCFS position {[}t,n{]}

\end{fulllineitems}

\index{remapLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.remapLCFS}\pysiglinewithargsret{\bfcode{remapLCFS}}{\emph{mask=False}}{}
Overwrites RLCFS, ZLCFS values pulled from EFIT with explicitly-calculated contour
of psinorm=1 surface.  This is then masked down by the limiter array using core.inPolygon,
restricting the contour to the closed plasma surface and the divertor legs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{mask} -- Boolean.
Default False.  Set True to mask LCFS path to limiter outline (using inPolygon).
Set False to draw full contour of psi = psiLCFS.

\end{description}\end{quote}

\end{fulllineitems}

\index{getF() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getF}\pysiglinewithargsret{\bfcode{getF}}{}{}
returns F=RB\_\{Phi\}(Psi), often calculated for grad-shafranov solutions  {[}t,psi{]}

\end{fulllineitems}

\index{getFluxPres() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFluxPres}\pysiglinewithargsret{\bfcode{getFluxPres}}{}{}
returns pressure at flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getFFPrime() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFFPrime}\pysiglinewithargsret{\bfcode{getFFPrime}}{}{}
returns FF' function used for grad-shafranov solutions {[}t,psi{]}

\end{fulllineitems}

\index{getPPrime() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getPPrime}\pysiglinewithargsret{\bfcode{getPPrime}}{}{}
returns plasma pressure gradient as a function of psi {[}t,psi{]}

\end{fulllineitems}

\index{getElongation() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getElongation}\pysiglinewithargsret{\bfcode{getElongation}}{}{}
returns LCFS elongation {[}t{]}

\end{fulllineitems}

\index{getUpperTriangularity() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getUpperTriangularity}\pysiglinewithargsret{\bfcode{getUpperTriangularity}}{}{}
returns LCFS upper triangularity {[}t{]}

\end{fulllineitems}

\index{getLowerTriangularity() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getLowerTriangularity}\pysiglinewithargsret{\bfcode{getLowerTriangularity}}{}{}
returns LCFS lower triangularity {[}t{]}

\end{fulllineitems}

\index{getSlhaping() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getSlhaping}\pysiglinewithargsret{\bfcode{getSlhaping}}{}{}
pulls LCFS elongation and upper/lower triangularity
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{kappa, delta\_u, delta\_l\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getMagR() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getMagR}\pysiglinewithargsret{\bfcode{getMagR}}{\emph{length\_unit=1}}{}
returns magnetic-axis major radius {[}t{]}

\end{fulllineitems}

\index{getMagZ() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getMagZ}\pysiglinewithargsret{\bfcode{getMagZ}}{\emph{length\_unit=1}}{}
returns magnetic-axis Z {[}t{]}

\end{fulllineitems}

\index{getAreaLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getAreaLCFS}\pysiglinewithargsret{\bfcode{getAreaLCFS}}{\emph{length\_unit=2}}{}
returns LCFS cross-sectional area {[}t{]}

\end{fulllineitems}

\index{getAOut() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getAOut}\pysiglinewithargsret{\bfcode{getAOut}}{\emph{length\_unit=1}}{}
returns outboard-midplane minor radius at LCFS {[}t{]}

\end{fulllineitems}

\index{getRmidOut() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getRmidOut}\pysiglinewithargsret{\bfcode{getRmidOut}}{\emph{length\_unit=1}}{}
returns outboard-midplane major radius {[}t{]}

\end{fulllineitems}

\index{getGeometry() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getGeometry}\pysiglinewithargsret{\bfcode{getGeometry}}{\emph{length\_unit=None}}{}
pulls dimensional geometry parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{magnetic-axis R,Z, LCFS area, outboard-midplane LCFS a,R\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getQProfile() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQProfile}\pysiglinewithargsret{\bfcode{getQProfile}}{}{}
returns safety factor q {[}t,psi{]}

\end{fulllineitems}

\index{getQ0() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQ0}\pysiglinewithargsret{\bfcode{getQ0}}{}{}
returns q on magnetic axis {[}t{]}

\end{fulllineitems}

\index{getQ95() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQ95}\pysiglinewithargsret{\bfcode{getQ95}}{}{}
returns q at 95\% flux surface {[}t{]}

\end{fulllineitems}

\index{getQLCFS() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQLCFS}\pysiglinewithargsret{\bfcode{getQLCFS}}{}{}
returns q on LCFS {[}t{]}

\end{fulllineitems}

\index{getQ1Surf() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQ1Surf}\pysiglinewithargsret{\bfcode{getQ1Surf}}{\emph{length\_unit=1}}{}
returns outboard-midplane minor radius of q=1 surface {[}t{]}

\end{fulllineitems}

\index{getQ2Surf() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQ2Surf}\pysiglinewithargsret{\bfcode{getQ2Surf}}{\emph{length\_unit=1}}{}
returns outboard-midplane minor radius of q=2 surface {[}t{]}

\end{fulllineitems}

\index{getQ3Surf() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQ3Surf}\pysiglinewithargsret{\bfcode{getQ3Surf}}{\emph{length\_unit=1}}{}
returns outboard-midplane minor radius of q=3 surface {[}t{]}

\end{fulllineitems}

\index{getQs() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getQs}\pysiglinewithargsret{\bfcode{getQs}}{\emph{length\_unit=1}}{}
pulls q values
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{q0,q95,qLCFS,rq1,rq2,rq3\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getBtVac() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getBtVac}\pysiglinewithargsret{\bfcode{getBtVac}}{}{}
returns on-axis vacuum toroidal field {[}t{]}

\end{fulllineitems}

\index{getBtPla() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getBtPla}\pysiglinewithargsret{\bfcode{getBtPla}}{}{}
returns on-axis plasma toroidal field {[}t{]}

\end{fulllineitems}

\index{getBpAvg() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getBpAvg}\pysiglinewithargsret{\bfcode{getBpAvg}}{}{}
returns average poloidal field {[}t{]}

\end{fulllineitems}

\index{getFields() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getFields}\pysiglinewithargsret{\bfcode{getFields}}{}{}
pulls vacuum and plasma toroidal field, avg poloidal field
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{btaxv,btaxp,bpolav\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getIpCalc() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getIpCalc}\pysiglinewithargsret{\bfcode{getIpCalc}}{}{}
returns EFIT-calculated plasma current {[}t{]}

\end{fulllineitems}

\index{getIpMeas() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getIpMeas}\pysiglinewithargsret{\bfcode{getIpMeas}}{}{}
returns magnetics-measured plasma current {[}t{]}

\end{fulllineitems}

\index{getJp() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getJp}\pysiglinewithargsret{\bfcode{getJp}}{}{}
returns EFIT-calculated plasma current density Jp on flux grid {[}t,r,z{]}

\end{fulllineitems}

\index{getBetaT() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getBetaT}\pysiglinewithargsret{\bfcode{getBetaT}}{}{}
returns EFIT-calculated toroidal beta {[}t{]}

\end{fulllineitems}

\index{getBetaP() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getBetaP}\pysiglinewithargsret{\bfcode{getBetaP}}{}{}
returns EFIT-calculated poloidal beta {[}t{]}

\end{fulllineitems}

\index{getLi() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getLi}\pysiglinewithargsret{\bfcode{getLi}}{}{}
returns EFIT-calculated internal inductance {[}t{]}

\end{fulllineitems}

\index{getBetas() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getBetas}\pysiglinewithargsret{\bfcode{getBetas}}{}{}
pulls calculated betap, betat, internal inductance
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{betat,betap,Li\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamagFlux() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getDiamagFlux}\pysiglinewithargsret{\bfcode{getDiamagFlux}}{}{}
returns measured diamagnetic-loop flux {[}t{]}

\end{fulllineitems}

\index{getDiamagBetaT() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getDiamagBetaT}\pysiglinewithargsret{\bfcode{getDiamagBetaT}}{}{}
returns diamagnetic-loop toroidal beta {[}t{]}

\end{fulllineitems}

\index{getDiamagBetaP() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getDiamagBetaP}\pysiglinewithargsret{\bfcode{getDiamagBetaP}}{}{}
returns diamagnetic-loop avg poloidal beta {[}t{]}

\end{fulllineitems}

\index{getDiamagTauE() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getDiamagTauE}\pysiglinewithargsret{\bfcode{getDiamagTauE}}{}{}
returns diamagnetic-loop energy confinement time {[}t{]}

\end{fulllineitems}

\index{getDiamagWp() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getDiamagWp}\pysiglinewithargsret{\bfcode{getDiamagWp}}{}{}
returns diamagnetic-loop plasma stored energy {[}t{]}

\end{fulllineitems}

\index{getDiamag() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getDiamag}\pysiglinewithargsret{\bfcode{getDiamag}}{}{}
pulls diamagnetic flux measurements, toroidal and poloidal beta, energy confinement time and stored energy
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{diamag. flux, betatd, betapd, tauDiamag, WDiamag\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getWMHD() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getWMHD}\pysiglinewithargsret{\bfcode{getWMHD}}{}{}
returns EFIT-calculated MHD stored energy {[}t{]}

\end{fulllineitems}

\index{getTauMHD() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getTauMHD}\pysiglinewithargsret{\bfcode{getTauMHD}}{}{}
returns EFIT-calculated MHD energy confinement time {[}t{]}

\end{fulllineitems}

\index{getPinj() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getPinj}\pysiglinewithargsret{\bfcode{getPinj}}{}{}
returns EFIT-calculated injected power {[}t{]}

\end{fulllineitems}

\index{getWbdot() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getWbdot}\pysiglinewithargsret{\bfcode{getWbdot}}{}{}
returns EFIT-calculated d/dt of magnetic stored energy {[}t{]}

\end{fulllineitems}

\index{getWpdot() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getWpdot}\pysiglinewithargsret{\bfcode{getWpdot}}{}{}
returns EFIT-calculated d/dt of plasma stored energy {[}t{]}

\end{fulllineitems}

\index{getEnergy() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getEnergy}\pysiglinewithargsret{\bfcode{getEnergy}}{}{}
pulls EFIT-calculated energy parameters - stored energy, tau\_E, injected power, d/dt of magnetic and plasma stored energy
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing \{WMHD,tauMHD,Pinj,Wbdot,Wpdot\}

\end{description}\end{quote}

\end{fulllineitems}

\index{getMachineCrossSection() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getMachineCrossSection}\pysiglinewithargsret{\bfcode{getMachineCrossSection}}{}{}
Returns R,Z coordinates of vacuum-vessel wall for masking, plotting routines.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The requested data.

\end{description}\end{quote}

\end{fulllineitems}

\index{getMachineCrossSectionFull() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getMachineCrossSectionFull}\pysiglinewithargsret{\bfcode{getMachineCrossSectionFull}}{}{}
Returns R,Z coordinates of vacuum-vessel wall for plotting routines.

Absent additional vector-graphic data on machine cross-section, returns
self.getMachineCrossSection().
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The requested data.

\end{description}\end{quote}

\end{fulllineitems}

\index{getCurrentSign() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getCurrentSign}\pysiglinewithargsret{\bfcode{getCurrentSign}}{}{}
Returns the sign of the current, based on the check in Steve Wolfe's IDL implementation efit\_rz2psi.pro.

\end{fulllineitems}

\index{getParam() (eqtools.EFIT.EFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.EFIT.EFITTree.getParam}\pysiglinewithargsret{\bfcode{getParam}}{\emph{path}}{}
backup function - path to parameter as input, returns desired variable acts as wrapper for MDS call
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{path} -- str
The path to the MDSplus node you wish to pull in.

\item[{Returns}] \leavevmode
The requested data.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{eqtools.FromArrays module}
\label{eqtools:module-eqtools.FromArrays}\label{eqtools:eqtools-fromarrays-module}\index{eqtools.FromArrays (module)}\index{ArrayEquilibrium (class in eqtools.FromArrays)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium}\pysiglinewithargsret{\strong{class }\code{eqtools.FromArrays.}\bfcode{ArrayEquilibrium}}{\emph{psiRZ}, \emph{rGrid}, \emph{zGrid}, \emph{time}, \emph{q}, \emph{fluxVol}, \emph{psiLCFS}, \emph{psiAxis}, \emph{rmag}, \emph{zmag}, \emph{Rout}, \emph{**kwargs}}{}
Bases: {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{eqtools.core.Equilibrium}}}

Class to represent an equilibrium specified as arrays of data.

Create ArrayEquilibrium instance from arrays of data.

Has very little checking on the shape/type of the arrays at this point.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psiRZ} -- Array-like, (M, N, P).
Flux values at M times, N Z locations and P R locations.

\item {} 
\textbf{rGrid} -- Array-like, (P,).
R coordinates that psiRZ is given at.

\item {} 
\textbf{zGrid} -- Array-like, (N,).
Z coordinates that psiRZ is given at.

\item {} 
\textbf{time} -- Array-like, (M,).
Times that psiRZ is given at.

\item {} 
\textbf{q} -- Array-like, (S, M).
q profile evaluated at S values of psinorm from 0 to 1, given at M
times.

\item {} 
\textbf{fluxVol} -- Array-like, (S, M).
Flux surface volumes evaluated at S values of psinorm from 0 to 1,
given at M times.

\item {} 
\textbf{psiLCFS} -- Array-like, (M,).
Flux at the last closed flux surface, given at M times.

\item {} 
\textbf{psiAxis} -- Array-like, (M,).
Flux at the magnetic axis, given at M times.

\item {} 
\textbf{rmag} -- Array-like, (M,).
Radial coordinate of the magnetic axis, given at M times.

\item {} 
\textbf{zmag} -- Array-like, (M,).
Vertical coordinate of the magnetic axis, given at M times.

\item {} 
\textbf{Rout} -- Outboard midplane radius of the last closed flux surface.

\item {} 
\textbf{length\_unit} -- 
String.
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
whatever the default in the tree is (no conversion is performed, units may be inconsistent)
\\
\hline\end{tabulary}

\end{quote}

Default is `m' (all units taken and returned in meters).


\item {} 
\textbf{tspline} -- Boolean.
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).

\item {} 
\textbf{monotonic} -- Boolean.
Sets whether or not the ``monotonic'' form of time window
finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).

\item {} 
\textbf{verbose} -- Boolean.
Allows or blocks console readout during operation.  Defaults to True,
displaying useful information for the user.  Set to False for quiet
usage or to avoid console clutter for multiple instances.

\end{itemize}

\end{description}\end{quote}
\index{getTimeBase() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getTimeBase}\pysiglinewithargsret{\bfcode{getTimeBase}}{}{}
Returns a copy of the time base vector, array dimensions are (M,).

\end{fulllineitems}

\index{getFluxGrid() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getFluxGrid}\pysiglinewithargsret{\bfcode{getFluxGrid}}{}{}
Returns a copy of the flux array, dimensions are (M, N, P), corresponding to (time, Z, R).

\end{fulllineitems}

\index{getRGrid() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getRGrid}\pysiglinewithargsret{\bfcode{getRGrid}}{\emph{length\_unit=1}}{}
Returns a copy of the radial grid, dimensions are (P,).

\end{fulllineitems}

\index{getZGrid() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getZGrid}\pysiglinewithargsret{\bfcode{getZGrid}}{\emph{length\_unit=1}}{}
Returns a copy of the vertical grid, dimensions are (N,).

\end{fulllineitems}

\index{getQProfile() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getQProfile}\pysiglinewithargsret{\bfcode{getQProfile}}{}{}
Returns safety factor q profile (over Q values of psinorm from 0 to 1), dimensions are (Q, M)

\end{fulllineitems}

\index{getFluxVol() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getFluxVol}\pysiglinewithargsret{\bfcode{getFluxVol}}{\emph{length\_unit=3}}{}
returns volume within flux surface {[}psi,t{]}

\end{fulllineitems}

\index{getFluxLCFS() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getFluxLCFS}\pysiglinewithargsret{\bfcode{getFluxLCFS}}{}{}
returns psi at separatrix {[}t{]}

\end{fulllineitems}

\index{getFluxAxis() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getFluxAxis}\pysiglinewithargsret{\bfcode{getFluxAxis}}{}{}
returns psi on magnetic axis {[}t{]}

\end{fulllineitems}

\index{getMagR() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getMagR}\pysiglinewithargsret{\bfcode{getMagR}}{\emph{length\_unit=1}}{}
returns magnetic-axis major radius {[}t{]}

\end{fulllineitems}

\index{getMagZ() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getMagZ}\pysiglinewithargsret{\bfcode{getMagZ}}{\emph{length\_unit=1}}{}
returns magnetic-axis Z {[}t{]}

\end{fulllineitems}

\index{getRmidOut() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getRmidOut}\pysiglinewithargsret{\bfcode{getRmidOut}}{\emph{length\_unit=1}}{}
returns outboard-midplane major radius {[}t{]}

\end{fulllineitems}

\index{getRLCFS() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getRLCFS}\pysiglinewithargsret{\bfcode{getRLCFS}}{\emph{length\_unit=1}}{}
\end{fulllineitems}

\index{getZLCFS() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getZLCFS}\pysiglinewithargsret{\bfcode{getZLCFS}}{\emph{length\_unit=1}}{}
\end{fulllineitems}

\index{getCurrentSign() (eqtools.FromArrays.ArrayEquilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.FromArrays.ArrayEquilibrium.getCurrentSign}\pysiglinewithargsret{\bfcode{getCurrentSign}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{eqtools.NSTXEFIT module}
\label{eqtools:module-eqtools.NSTXEFIT}\label{eqtools:eqtools-nstxefit-module}\index{eqtools.NSTXEFIT (module)}
This module provides classes for working with NSTX EFIT data.
\index{NSTXEFITTree (class in eqtools.NSTXEFIT)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree}\pysiglinewithargsret{\strong{class }\code{eqtools.NSTXEFIT.}\bfcode{NSTXEFITTree}}{\emph{shot}, \emph{tree='EFIT01'}, \emph{length\_unit='m'}, \emph{gfile='geqdsk'}, \emph{afile='aeqdsk'}, \emph{tspline=False}, \emph{monotonic=False}}{}
Bases: {\hyperref[eqtools:eqtools.EFIT.EFITTree]{\code{eqtools.EFIT.EFITTree}}}

Inherits \code{EFITTree} class. Machine-specific data
handling class for the National Spherical Torus Experiment (NSTX). Pulls EFIT
data from selected MDS tree and shot, stores as object attributes. Each EFIT
variable or set of variables is recovered with a corresponding getter method.
Essential data for EFIT mapping are pulled on initialization (e.g. psirz grid).
Additional data are pulled at the first request and stored for subsequent usage.

Intializes NSTX version of EFITTree object.  Pulls data from MDS tree for storage
in instance attributes.  Core attributes are populated from the MDS tree on initialization.
Additional attributes are initialized as None, filled on the first request to the object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{shot} -- (long) int
NSTX shot index (long)

\item {} 
\textbf{tree} -- str
Optional input for EFIT tree, defaults to `EFIT01'
(i.e., EFIT data are under EFIT01::top.results).

\item {} 
\textbf{length\_unit} -- 
str
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
whatever the default in the tree is (no conversion is performed, units may be inconsistent)
\\
\hline\end{tabulary}

\end{quote}

Default is `m' (all units taken and returned in meters).


\item {} 
\textbf{gfile} -- str
Optional input for EFIT geqdsk location name, defaults to `g\_eqdsk'
(i.e., EFIT data are under tree::top.results.G\_EQDSK)

\item {} 
\textbf{afile} -- str
Optional input for EFIT aeqdsk location name, defaults to `a\_eqdsk'
(i.e., EFIT data are under tree::top.results.A\_EQDSK)

\item {} 
\textbf{tspline} -- Boolean
Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor
interpolation. Tricubic spline interpolation requires at least
four complete equilibria at different times. It is also assumed
that they are functionally correlated, and that parameters do
not vary out of their boundaries (derivative = 0 boundary
condition). Default is False (use nearest neighbor interpolation).

\item {} 
\textbf{monotonic} -- Boolean
Sets whether or not the ``monotonic'' form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).

\end{itemize}

\end{description}\end{quote}
\index{getFluxGrid() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getFluxGrid}\pysiglinewithargsret{\bfcode{getFluxGrid}}{}{}
returns EFIT flux grid, {[}t,z,r{]}

\end{fulllineitems}

\index{getMachineCrossSection() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getMachineCrossSection}\pysiglinewithargsret{\bfcode{getMachineCrossSection}}{}{}
Returns R,Z coordinates of vacuum-vessel wall for masking, plotting routines.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The requested data.

\end{description}\end{quote}

\end{fulllineitems}

\index{getFluxVol() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getFluxVol}\pysiglinewithargsret{\bfcode{getFluxVol}}{}{}
Not implemented in NSTXEFIT tree.

Returns volume within flux surface {[}psi,t{]}

\end{fulllineitems}

\index{getRmidPsi() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getRmidPsi}\pysiglinewithargsret{\bfcode{getRmidPsi}}{\emph{length\_unit=1}}{}
returns maximum major radius of each flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getIpCalc() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getIpCalc}\pysiglinewithargsret{\bfcode{getIpCalc}}{}{}
returns EFIT-calculated plasma current {[}t{]}

\end{fulllineitems}

\index{getVolLCFS() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getVolLCFS}\pysiglinewithargsret{\bfcode{getVolLCFS}}{\emph{length\_unit=3}}{}
returns volume within LCFS {[}t{]}

\end{fulllineitems}

\index{getJp() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.getJp}\pysiglinewithargsret{\bfcode{getJp}}{}{}
Not implemented in NSTXEFIT tree.

returns EFIT-calculated plasma current density Jp on flux grid {[}t,r,z{]}

\end{fulllineitems}

\index{rz2volnorm() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.rz2volnorm}\pysiglinewithargsret{\bfcode{rz2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculated normalized volume of flux surfaces not stored in NSTX EFIT. All maping with Volnorm
not implemented

\end{fulllineitems}

\index{psinorm2volnorm() (eqtools.NSTXEFIT.NSTXEFITTree method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTree.psinorm2volnorm}\pysiglinewithargsret{\bfcode{psinorm2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculated normalized volume of flux surfaces not stored in NSTX EFIT. All maping with Volnorm
not implemented

\end{fulllineitems}


\end{fulllineitems}

\index{NSTXEFITTreeProp (class in eqtools.NSTXEFIT)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.NSTXEFIT.NSTXEFITTreeProp}\pysiglinewithargsret{\strong{class }\code{eqtools.NSTXEFIT.}\bfcode{NSTXEFITTreeProp}}{\emph{shot}, \emph{tree='EFIT01'}, \emph{length\_unit='m'}, \emph{gfile='geqdsk'}, \emph{afile='aeqdsk'}, \emph{tspline=False}, \emph{monotonic=False}}{}
Bases: {\hyperref[eqtools:eqtools.NSTXEFIT.NSTXEFITTree]{\code{eqtools.NSTXEFIT.NSTXEFITTree}}}, {\hyperref[eqtools:eqtools.core.PropertyAccessMixin]{\code{eqtools.core.PropertyAccessMixin}}}

NSTXEFITTree with the PropertyAccessMixin added to enable property-style
access. This is good for interactive use, but may drag the performance down.

\end{fulllineitems}



\subsection{eqtools.TCVLIUQE module}
\label{eqtools:eqtools-tcvliuqe-module}

\subsection{eqtools.AUGDATA module}
\label{eqtools:eqtools-augdata-module}

\subsection{eqtools.afilereader module}
\label{eqtools:eqtools-afilereader-module}\label{eqtools:module-eqtools.afilereader}\index{eqtools.afilereader (module)}
This module contains the AFileReader class, a lightweight data
handler for a-file (time-history) datasets.
\begin{description}
\item[{Classes:}] \leavevmode\begin{description}
\item[{AFileReader: Data-storage class for a-file data.  Reads}] \leavevmode
data from ASCII a-file, storing as copy-safe object
attributes.

\end{description}

\end{description}
\index{AFileReader (class in eqtools.afilereader)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.afilereader.AFileReader}\pysiglinewithargsret{\strong{class }\code{eqtools.afilereader.}\bfcode{AFileReader}}{\emph{afile}}{}
Bases: \code{object}

Class to read ASCII a-file (time-history data storage) into lightweight, user-friendly data structure.

A-files store data blocks of scalar time-history data for EFIT plasma equilibrium.  Each parameter is
read into a pseudo-private object attribute (marked by a leading underscore), followed by the standard
EFIT variable names.

initialize object, reading from file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{afile} -- str
path to a-file

\end{description}\end{quote}

\end{fulllineitems}



\subsection{eqtools.core module}
\label{eqtools:module-eqtools.core}\label{eqtools:eqtools-core-module}\index{eqtools.core (module)}
This module provides the core classes for {\hyperref[eqtools:module-eqtools]{\code{eqtools}}}, including the
base {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} class.
\index{ModuleWarning}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.ModuleWarning}\pysigline{\strong{exception }\code{eqtools.core.}\bfcode{ModuleWarning}}
Bases: \code{exceptions.Warning}

Warning class to notify the user of unavailable modules.

x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\end{fulllineitems}

\index{PropertyAccessMixin (class in eqtools.core)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.PropertyAccessMixin}\pysigline{\strong{class }\code{eqtools.core.}\bfcode{PropertyAccessMixin}}
Bases: \code{object}

Mixin to implement access of getter methods through a property-type
interface without the need to apply a decorator to every property.

For any getter \emph{obj.getSomething()}, the call \emph{obj.Something} will do the
same thing.

This is accomplished by overriding \code{\_\_getattribute\_\_()} such that if
an attribute \emph{ATTR} does not exist it then attempts to call \emph{self.getATTR()}.
If \emph{self.getATTR()} does not exist, an \code{AttributeError} will be
raised as usual.

Also overrides \code{\_\_setattr\_\_()} such that it will raise an
\code{AttributeError} when attempting to write an attribute \emph{ATTR} for
which there is already a method \emph{getATTR}.

x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\end{fulllineitems}

\index{inPolygon() (in module eqtools.core)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.inPolygon}\pysiglinewithargsret{\code{eqtools.core.}\bfcode{inPolygon}}{\emph{polyx}, \emph{polyy}, \emph{pointx}, \emph{pointy}}{}
Function calculating whether a given point is within a 2D polygon.

Given an array of X,Y coordinates describing a 2D polygon, checks whether a
point given by x,y coordinates lies within the polygon. Operates via a
ray-casting approach - the function projects a semi-infinite ray parallel to
the positive horizontal axis, and counts how many edges of the polygon this
ray intersects. For a simply-connected polygon, this determines whether the
point is inside (even number of crossings) or outside (odd number of
crossings) the polygon, by the Jordan Curve Theorem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{polyx} (\emph{Array-like}) -- Array of x-coordinates of the vertices of the polygon.

\item {} 
\textbf{polyy} (\emph{Array-like}) -- Array of y-coordinates of the vertices of the polygon.

\item {} 
\textbf{pointx} (\emph{Int or float}) -- x-coordinate of test point.

\item {} 
\textbf{pointy} (\emph{Int or float}) -- y-coordinate of test point.

\end{itemize}

\item[{Returns}] \leavevmode
True/False result for whether the point is contained within the polygon.

\item[{Return type}] \leavevmode
result (Boolean)

\end{description}\end{quote}

\end{fulllineitems}

\index{Equilibrium (class in eqtools.core)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium}\pysiglinewithargsret{\strong{class }\code{eqtools.core.}\bfcode{Equilibrium}}{\emph{length\_unit='m'}, \emph{tspline=False}, \emph{monotonic=False}, \emph{verbose=True}}{}
Bases: \code{object}

Abstract class of data handling object for magnetic reconstruction outputs.

Defines the mapping routines and method fingerprints necessary. Each
variable or set of variables is recovered with a corresponding getter method.
Essential data for mapping are pulled on initialization (psirz grid, for
example) to frontload overhead. Additional data are pulled at the first
request and stored for subsequent usage.

\begin{notice}{note}{Note:}
This abstract class should not be used directly. Device- and code-
specific subclasses are set up to account for inter-device/-code
differences in data storage.
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{length\_unit} -- 
Sets the base unit used for any quantity whose
dimensions are length to any power. Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
whatever the default in the tree is (no conversion is performed, units may be inconsistent)
\\
\hline\end{tabulary}

\end{quote}

Default is `m' (all units taken and returned in meters).


\item {} 
\textbf{tspline} -- Sets whether or not interpolation in time is
performed using a tricubic spline or nearest-neighbor interpolation.
Tricubic spline interpolation requires at least four complete
equilibria at different times. It is also assumed that they are
functionally correlated, and that parameters do not vary out of
their boundaries (derivative = 0 boundary condition). Default is
False (use nearest-neighbor interpolation).

\item {} 
\textbf{monotonic} -- Sets whether or not the ``monotonic'' form of time
window finding is used. If True, the timebase must be monotonically
increasing. Default is False (use slower, safer method).

\item {} 
\textbf{verbose} -- Allows or blocks console readout during operation.
Defaults to True, displaying useful information for the user. Set to
False for quiet usage or to avoid console clutter for multiple
instances.

\end{itemize}

\item[{Kwtype length\_unit}] \leavevmode
String

\item[{Kwtype tspline}] \leavevmode
Boolean

\item[{Kwtype monotonic}] \leavevmode
Boolean

\item[{Kwtype verbose}] \leavevmode
Boolean

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\code{ValueError} -- If \emph{length\_unit} is not a valid unit specifier.

\item {} 
\code{ValueError} -- If \emph{tspline} is True but module trispline did not load
successfully.

\end{itemize}

\end{description}\end{quote}
\index{rho2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rho2rho}\pysiglinewithargsret{\bfcode{rho2rho}}{\emph{origin}, \emph{destination}, \emph{*args}, \emph{**kwargs}}{}
Convert from one coordinate to another.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{origin} (\emph{String}) -- 
Indicates which coordinates the data are given in.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

RZ
 & 
R,Z coordinates
\\

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\

Rmid
 & 
Midplane major radius
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{destination} (\emph{String}) -- 
Indicates which coordinates to convert to.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\

Rmid
 & 
Midplane major radius
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{rho} (\emph{Array-like or scalar float}) -- Values of the starting coordinate
to map to the new coordinate. Will be two arguments \emph{R}, \emph{Z} if
\emph{origin} is `RZ'.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{rho}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{rho} (or the meshgrid of \emph{R}
and \emph{Z} if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of \emph{rho}. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{rho} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{rho} or be
a scalar. Default is True (evaluate ALL \emph{rho} at EACH element in
\emph{t}).

\item {} 
\textbf{make\_grid} -- Only applicable if \emph{origin} is `RZ'. Set to
True to pass \emph{R} and \emph{Z} through \code{scipy.meshgrid()}
before evaluating. If this is set to True, \emph{R} and \emph{Z} must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid when \emph{destination} is Rmid. Default is False
(return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that quantities are
given/returned in, as applicable. If a string is given, it must
be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\item[{Raises}] \leavevmode
\code{ValueError} -- If \emph{origin} is not one of the supported values.

\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at r/a=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rho2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r/a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rho2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r/a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at r/a of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rho2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r/a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rho2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r/a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2psi() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2psi}\pysiglinewithargsret{\bfcode{rz2psi}}{\emph{R}, \emph{Z}, \emph{t}, \emph{return\_t=False}, \emph{make\_grid=False}, \emph{each\_t=True}, \emph{length\_unit=1}}{}
Converts the passed R, Z, t arrays to psi (unnormalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to poloidal flux. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to poloidal flux. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{psi} or (\emph{psi}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{psi} (\emph{Array or scalar float}) - The unnormalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If \emph{R} and \emph{Z}
both have the same shape then \emph{psi} has this shape as well,
unless the \emph{make\_grid} keyword was True, in which case \emph{psi} has
shape (len(\emph{Z}), len(\emph{R})).

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{psi}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psi value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psi}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the \emph{Z} vector must be fully
specified, even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psi}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psi values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psi}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and
(0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psi}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find psi values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psi}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2psinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2psinorm}\pysiglinewithargsret{\bfcode{rz2psinorm}}{\emph{R}, \emph{Z}, \emph{t}, \emph{return\_t=False}, \emph{sqrt=False}, \emph{make\_grid=False}, \emph{each\_t=True}, \emph{length\_unit=1}}{}
Calculates the normalized poloidal flux at the given (R, Z, t).

Uses the definition:
\begin{gather}
\begin{split}\texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}\end{split}\notag
\end{gather}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to psinorm. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to psinorm. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{psinorm} or (\emph{psinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{psinorm} (\emph{Array or scalar float}) - The normalized poloidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If \emph{R} and \emph{Z}
both have the same shape then \emph{psinorm} has this shape as well,
unless the \emph{make\_grid} keyword was True, in which case \emph{psinorm}
has shape (len(\emph{Z}), len(\emph{R})).

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{psinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the
appropriate extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the \emph{Z} vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find psinorm values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2phinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2phinorm}\pysiglinewithargsret{\bfcode{rz2phinorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized toroidal flux.

Uses the definitions:
\begin{gather}
\begin{split}\texttt{phi} &= \int q(\psi)\,d\psi\end{split}\notag\\\begin{split}\texttt{phi\_norm} &= \frac{\phi}{\phi(a)}\end{split}\notag
\end{gather}
This is based on the IDL version efit\_rz2rho.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to phinorm. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to phinorm. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{phinorm} or (\emph{phinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array or scalar float}) - The normalized toroidal
flux. If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If \emph{R} and \emph{Z}
both have the same shape then \emph{phinorm} has this shape as well,
unless the \emph{make\_grid} keyword was True, in which case \emph{phinorm}
has shape (len(\emph{Z}), len(\emph{R})).

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{phinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the \emph{Z} vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find phinorm values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2volnorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2volnorm}\pysiglinewithargsret{\bfcode{rz2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized flux surface volume.

Based on the IDL version efit\_rz2rho.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to volnorm. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to volnorm. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{volnorm} or (\emph{volnorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array or scalar float}) - The normalized volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned. If \emph{R} and \emph{Z}
both have the same shape then \emph{volnorm} has this shape as well,
unless the \emph{make\_grid} keyword was True, in which case \emph{volnorm}
has shape (len(\emph{Z}), len(\emph{R})).

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{volnorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the \emph{Z} vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find volnorm values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2volnorm}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2rmid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2rmid}\pysiglinewithargsret{\bfcode{rz2rmid}}{\emph{*args}, \emph{**kwargs}}{}
Maps the given points to the outboard midplane major radius, Rmid.

Based on the IDL version efit\_rz2rmid.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to Rmid. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to Rmid. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in,
AND that \emph{Rmid} is returned in. If a string is given, it must
be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{Rmid} or (\emph{Rmid}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{Rmid} (\emph{Array or scalar float}) - The outboard midplan major
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If \emph{R} and \emph{Z}
both have the same shape then \emph{Rmid} has this shape as well,
unless the \emph{make\_grid} keyword was True, in which case \emph{Rmid}
has shape (len(\emph{Z}), len(\emph{R})).

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{Rmid}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single Rmid value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the \emph{Z} vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find Rmid values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2roa() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2roa}\pysiglinewithargsret{\bfcode{rz2roa}}{\emph{*args}, \emph{**kwargs}}{}
Maps the given points to the normalized minor radius, r/a.

Based on the IDL version efit\_rz2rmid.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to r/a. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to r/a. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{roa} or (\emph{roa}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array or scalar float}) - The normalized minor radius.
If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned. If \emph{R} and \emph{Z}
both have the same shape then \emph{roa} has this shape as well,
unless the \emph{make\_grid} keyword was True, in which case \emph{roa}
has shape (len(\emph{Z}), len(\emph{R})).

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{roa}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single r/a value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2roa}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the Z vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2roa}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find r/a values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2roa}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rz2rho}\pysiglinewithargsret{\bfcode{rz2rho}}{\emph{method}, \emph{*args}, \emph{**kwargs}}{}
Convert the passed (R, Z, t) coordinates into one of several coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} (\emph{String}) -- 
Indicates which coordinates to convert to. Valid
options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\

Rmid
 & 
Midplane major radius
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{R} (\emph{Array-like or scalar float}) -- Values of the radial coordinate to
map to \emph{rho}. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{Z} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{R} must
have exactly one dimension.

\item {} 
\textbf{Z} (\emph{Array-like or scalar float}) -- Values of the vertical coordinate to
map to \emph{rho}. If \emph{R} and \emph{Z} are both scalar values,
they are used as the coordinate pair for all of the values in
\emph{t}. Must have the same shape as \emph{R} unless the \emph{make\_grid}
keyword is set. If the \emph{make\_grid} keyword is True, \emph{Z} must
have exactly one dimension.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R}, \emph{Z}. If the \emph{each\_t} keyword is True, then \emph{t} must be
scalar or have exactly one dimension. If the \emph{each\_t} keyword is
False, \emph{t} must have the same shape as \emph{R} and \emph{Z} (or their
meshgrid if \emph{make\_grid} is True).

\item {} 
\textbf{sqrt} -- Set to True to return the square root of \emph{rho}.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R}, \emph{Z} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R} and
\emph{Z} or be a scalar. Default is True (evaluate ALL \emph{R}, \emph{Z} at
EACH element in \emph{t}).

\item {} 
\textbf{make\_grid} -- Set to True to pass \emph{R} and \emph{Z} through
\code{scipy.meshgrid()} before evaluating. If this is set to
True, \emph{R} and \emph{Z} must each only have a single dimension, but
can have different lengths. Default is False (do not form
meshgrid).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid when \emph{destination} is Rmid. Default is False
(return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R}, \emph{Z} are given in,
AND that \emph{Rmid} is returned in. If a string is given, it must
be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype make\_grid}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\item[{Raises}] \leavevmode
\code{ValueError} -- If \emph{method} is not one of the supported values.

\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
single time t=0.26s. Note that the \emph{Z} vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z) points (0.6m, 0m) at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Find psinorm values on grid defined by 1D vector of radial positions \emph{R}
and 1D vector of vertical positions \emph{Z} at time t=0.2s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rmid2roa() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rmid2roa}\pysiglinewithargsret{\bfcode{rmid2roa}}{\emph{R\_mid}, \emph{t}, \emph{each\_t=True}, \emph{return\_t=False}, \emph{sqrt=False}, \emph{time\_idxs=None}, \emph{length\_unit=1}}{}
Convert the passed (R\_mid, t) coordinates into r/a.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R\_mid} (\emph{Array-like or scalar float}) -- Values of the outboard midplane
major radius to map to r/a.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R\_mid}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{R\_mid}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R\_mid} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R\_mid}
or be a scalar. Default is True (evaluate ALL \emph{R\_mid} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R\_mid} is given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{roa} or (\emph{roa}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array or scalar float}) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{roa}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single r/a value at R\_mid=0.6m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2roa}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find roa values at R\_mid points 0.6m and 0.8m at the
single time t=0.26s.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find roa values at R\_mid of 0.6m at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2roa}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (R\_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rmid2psinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rmid2psinorm}\pysiglinewithargsret{\bfcode{rmid2psinorm}}{\emph{R\_mid}, \emph{t}, \emph{**kwargs}}{}
Calculates the normalized poloidal flux corresponding to the passed R\_mid (mapped outboard midplane major radius) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R\_mid} (\emph{Array-like or scalar float}) -- Values of the outboard midplane
major radius to map to psinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R\_mid}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{R\_mid}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R\_mid} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R\_mid}
or be a scalar. Default is True (evaluate ALL \emph{R\_mid} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R\_mid} is given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{psinorm} or (\emph{psinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{psinorm} (\emph{Array or scalar float}) - Normalized poloidal flux.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{psinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value for Rmid=0.7m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at R\_mid values of 0.5m and 0.7m at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at R\_mid=0.5m at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R\_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rmid2phinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rmid2phinorm}\pysiglinewithargsret{\bfcode{rmid2phinorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized toroidal flux.

Uses the definitions:
\begin{gather}
\begin{split}\texttt{phi} &= \int q(\psi)\,d\psi\end{split}\notag\\\begin{split}\texttt{phi\_norm} &= \frac{\phi}{\phi(a)}\end{split}\notag
\end{gather}
This is based on the IDL version efit\_rz2rho.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R\_mid} (\emph{Array-like or scalar float}) -- Values of the outboard midplane
major radius to map to phinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R\_mid}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{R\_mid}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R\_mid} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R\_mid}
or be a scalar. Default is True (evaluate ALL \emph{R\_mid} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R\_mid} is given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{phinorm} or (\emph{phinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array or scalar float}) - Normalized toroidal flux.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{phinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single phinorm value at R\_mid=0.6m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at R\_mid points 0.6m and 0.8m at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at R\_mid point 0.6m at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (R, t) points (0.6m, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rmid2volnorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rmid2volnorm}\pysiglinewithargsret{\bfcode{rmid2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized flux surface volume.

Based on the IDL version efit\_rz2rho.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R\_mid} (\emph{Array-like or scalar float}) -- Values of the outboard midplane
major radius to map to volnorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R\_mid}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{R\_mid}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R\_mid} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R\_mid}
or be a scalar. Default is True (evaluate ALL \emph{R\_mid} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R\_mid} is given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{volnorm} or (\emph{volnorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array or scalar float}) - Normalized volume.
If all of the input arguments are scalar, then a scalar is
returned. Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{volnorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single volnorm value at R\_mid=0.6m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at R\_mid points 0.6m and 0.8m at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at R\_mid points 0.6m at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (R\_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vol\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rmid2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.rmid2rho}\pysiglinewithargsret{\bfcode{rmid2rho}}{\emph{method}, \emph{R\_mid}, \emph{t}, \emph{**kwargs}}{}
Convert the passed (R\_mid, t) coordinates into one of several coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} (\emph{String}) -- 
Indicates which coordinates to convert to. Valid
options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{R\_mid} (\emph{Array-like or scalar float}) -- Values of the outboard midplane
major radius to map to rho.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{R\_mid}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{R\_mid}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of rho.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{R\_mid} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{R\_mid}
or be a scalar. Default is True (evaluate ALL \emph{R\_mid} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{R\_mid} is given in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at R\_mid=0.6m, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at R\_mid points 0.6m and 0.8m at the
single time t=0.26s.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at R\_mid of 0.6m at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R\_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rmid2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{roa2rmid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.roa2rmid}\pysiglinewithargsret{\bfcode{roa2rmid}}{\emph{roa}, \emph{t}, \emph{each\_t=True}, \emph{return\_t=False}, \emph{time\_idxs=None}, \emph{length\_unit=1}}{}
Convert the passed (r/a, t) coordinates into Rmid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array-like or scalar float}) -- Values of the normalized minor
radius to map to Rmid.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{roa}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{roa}.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{roa} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{roa}
or be a scalar. Default is True (evaluate ALL \emph{roa} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{Rmid} or (\emph{Rmid}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{Rmid} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{Rmid}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single R\_mid value at r/a=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at r/a of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{roa2psinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.roa2psinorm}\pysiglinewithargsret{\bfcode{roa2psinorm}}{\emph{*args}, \emph{**kwargs}}{}
Convert the passed (r/a, t) coordinates into psinorm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array-like or scalar float}) -- Values of the normalized minor
radius to map to psinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{roa}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{roa}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{roa} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{roa}
or be a scalar. Default is True (evaluate ALL \emph{roa} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{psinorm} or (\emph{psinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{psinorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{psinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at r/a=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at r/a of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{roa2phinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.roa2phinorm}\pysiglinewithargsret{\bfcode{roa2phinorm}}{\emph{*args}, \emph{**kwargs}}{}
Convert the passed (r/a, t) coordinates into phinorm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array-like or scalar float}) -- Values of the normalized minor
radius to map to phinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{roa}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{roa}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{roa} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{roa}
or be a scalar. Default is True (evaluate ALL \emph{roa} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{phinorm} or (\emph{phinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{phinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single phinorm value at r/a=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at r/a of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{roa2volnorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.roa2volnorm}\pysiglinewithargsret{\bfcode{roa2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Convert the passed (r/a, t) coordinates into volnorm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array-like or scalar float}) -- Values of the normalized minor
radius to map to volnorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{roa}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{roa}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{roa} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{roa}
or be a scalar. Default is True (evaluate ALL \emph{roa} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{volnorm} or (\emph{volnorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{volnorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single volnorm value at r/a=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at r/a of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{roa2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.roa2rho}\pysiglinewithargsret{\bfcode{roa2rho}}{\emph{method}, \emph{*args}, \emph{**kwargs}}{}
Convert the passed (r/a, t) coordinates into one of several coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} (\emph{String}) -- 
Indicates which coordinates to convert to.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\

Rmid
 & 
Midplane major radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{roa} (\emph{Array-like or scalar float}) -- Values of the normalized minor
radius to map to rho.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{roa}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{roa}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of rho.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{roa} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{roa}
or be a scalar. Default is True (evaluate ALL \emph{roa} at EACH
element in \emph{t}).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from Rmid to
psinorm and psinorm to volnorm or phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at r/a=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at r/a points 0.6 and 0.8 at the
single time t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at r/a of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{roa2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2rmid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.psinorm2rmid}\pysiglinewithargsret{\bfcode{psinorm2rmid}}{\emph{psi\_norm}, \emph{t}, \emph{**kwargs}}{}
Calculates the outboard R\_mid location corresponding to the passed psinorm (normalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psi\_norm} (\emph{Array-like or scalar float}) -- Values of the normalized
poloidal flux to map to Rmid.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{psi\_norm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{psi\_norm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of Rmid. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{psi\_norm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{psi\_norm} or be
a scalar. Default is True (evaluate ALL \emph{psi\_norm} at EACH element in
\emph{t}).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{Rmid} or (\emph{Rmid}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{Rmid} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{Rmid}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single R\_mid value for psinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at psi\_norm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at psi\_norm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2roa() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.psinorm2roa}\pysiglinewithargsret{\bfcode{psinorm2roa}}{\emph{psi\_norm}, \emph{t}, \emph{**kwargs}}{}
Calculates the normalized minor radius location corresponding to the passed psi\_norm (normalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psi\_norm} (\emph{Array-like or scalar float}) -- Values of the normalized
poloidal flux to map to r/a.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{psi\_norm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{psi\_norm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of r/a. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{psi\_norm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{psi\_norm} or be
a scalar. Default is True (evaluate ALL \emph{psi\_norm} at EACH element in
\emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{roa} or (\emph{roa}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array or scalar float}) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{roa}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single r/a value for psinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2roa}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at psi\_norm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at psi\_norm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2roa}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2volnorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.psinorm2volnorm}\pysiglinewithargsret{\bfcode{psinorm2volnorm}}{\emph{psi\_norm}, \emph{t}, \emph{**kwargs}}{}
Calculates the normalized volume corresponding to the passed psi\_norm (normalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psi\_norm} (\emph{Array-like or scalar float}) -- Values of the normalized
poloidal flux to map to volnorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{psi\_norm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{psi\_norm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of volnorm. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{psi\_norm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{psi\_norm} or be
a scalar. Default is True (evaluate ALL \emph{psi\_norm} at EACH element in
\emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{volnorm} or (\emph{volnorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{volnorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single volnorm value for psinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at psi\_norm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at psi\_norm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2phinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.psinorm2phinorm}\pysiglinewithargsret{\bfcode{psinorm2phinorm}}{\emph{psi\_norm}, \emph{t}, \emph{**kwargs}}{}
Calculates the normalized toroidal flux corresponding to the passed psi\_norm (normalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psi\_norm} (\emph{Array-like or scalar float}) -- Values of the normalized
poloidal flux to map to phinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{psi\_norm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{psi\_norm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of phinorm. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{psi\_norm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{psi\_norm} or be
a scalar. Default is True (evaluate ALL \emph{psi\_norm} at EACH element in
\emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{phinorm} or (\emph{phinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{phinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single phinorm value for psinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at psi\_norm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at psi\_norm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.psinorm2rho}\pysiglinewithargsret{\bfcode{psinorm2rho}}{\emph{method}, \emph{*args}, \emph{**kwargs}}{}
Convert the passed (psinorm, t) coordinates into one of several coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} (\emph{String}) -- 
Indicates which coordinates to convert to.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\

Rmid
 & 
Midplane major radius
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{psi\_norm} (\emph{Array-like or scalar float}) -- Values of the normalized
poloidal flux to map to rho.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{psi\_norm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{psi\_norm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{psi\_norm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{psi\_norm} or be
a scalar. Default is True (evaluate ALL \emph{psi\_norm} at EACH element in
\emph{t}).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\item[{Raises}] \leavevmode
\code{ValueError} -- If \emph{method} is not one of the supported values.

\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single phinorm value at psinorm=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{phinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at phinorm of 0.6 and 0.8 at the
single time t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{phinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at psinorm of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{phinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{phinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phinorm2psinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.phinorm2psinorm}\pysiglinewithargsret{\bfcode{phinorm2psinorm}}{\emph{phinorm}, \emph{t}, \emph{**kwargs}}{}
Calculates the normalized poloidal flux corresponding to the passed phinorm (normalized toroidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array-like or scalar float}) -- Values of the normalized
toroidal flux to map to psinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{phinorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{phinorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{phinorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{phinorm}
or be a scalar. Default is True (evaluate ALL \emph{phinorm} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{psinorm} or (\emph{psinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{psinorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{psinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value for phinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at phinorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phinorm2volnorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.phinorm2volnorm}\pysiglinewithargsret{\bfcode{phinorm2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array-like or scalar float}) -- Values of the normalized
toroidal flux to map to volnorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{phinorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{phinorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of volnorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{phinorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{phinorm}
or be a scalar. Default is True (evaluate ALL \emph{phinorm} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm and psinorm to volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{volnorm} or (\emph{volnorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{volnorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single volnorm value for phinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at phinorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2volnorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find volnorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{volnorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2volnorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phinorm2rmid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.phinorm2rmid}\pysiglinewithargsret{\bfcode{phinorm2rmid}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the mapped outboard midplane major radius corresponding to the passed phinorm (normalized toroidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array-like or scalar float}) -- Values of the normalized
toroidal flux to map to Rmid.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{phinorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{phinorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{phinorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{phinorm}
or be a scalar. Default is True (evaluate ALL \emph{phinorm} at EACH
element in \emph{t}).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm and psinorm to Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{Rmid} or (\emph{Rmid}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{Rmid} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{Rmid}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single Rmid value for phinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at phinorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phinorm2roa() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.phinorm2roa}\pysiglinewithargsret{\bfcode{phinorm2roa}}{\emph{phi\_norm}, \emph{t}, \emph{**kwargs}}{}
Calculates the normalized minor radius corresponding to the passed phinorm (normalized toroidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array-like or scalar float}) -- Values of the normalized
toroidal flux to map to r/a.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{phinorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{phinorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{phinorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{phinorm}
or be a scalar. Default is True (evaluate ALL \emph{phinorm} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from phinorm to
psinorm and psinorm to Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{roa} or (\emph{roa}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array or scalar float}) - Normalized midplane minor
radius. If all of the input arguments are scalar, then a scalar
is returned. Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{roa}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single r/a value for phinorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2roa}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at phinorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at phinorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2roa}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phinorm2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.phinorm2rho}\pysiglinewithargsret{\bfcode{phinorm2rho}}{\emph{method}, \emph{*args}, \emph{**kwargs}}{}
Convert the passed (phinorm, t) coordinates into one of several coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} (\emph{String}) -- 
Indicates which coordinates to convert to.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

volnorm
 & 
Normalized volume
\\

Rmid
 & 
Midplane major radius
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{phinorm} (\emph{Array-like or scalar float}) -- Values of the normalized
toroidal flux to map to rho.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{phinorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{phinorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{phinorm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{phinorm} or be
a scalar. Default is True (evaluate ALL \emph{phinorm} at EACH element in
\emph{t}).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from psinorm to
Rmid/phinorm/volnorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\item[{Raises}] \leavevmode
\code{ValueError} -- If \emph{method} is not one of the supported values.

\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at phinorm=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at phinorm of 0.6 and 0.8 at the
single time t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at phinorm of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{phinorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{volnorm2psinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.volnorm2psinorm}\pysiglinewithargsret{\bfcode{volnorm2psinorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized poloidal flux corresponding to the passed volnorm (normalized flux surface volume) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array-like or scalar float}) -- Values of the normalized
flux surface volume to map to psinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{volnorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{volnorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of psinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{volnorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{volnorm}
or be a scalar. Default is True (evaluate ALL \emph{volnorm} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{psinorm} or (\emph{psinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{psinorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{psinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value for volnorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at volnorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{volnorm2phinorm() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.volnorm2phinorm}\pysiglinewithargsret{\bfcode{volnorm2phinorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized toroidal flux corresponding to the passed volnorm (normalized flux surface volume) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array-like or scalar float}) -- Values of the normalized
flux surface volume to map to phinorm.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{volnorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{volnorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of phinorm.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{volnorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{volnorm}
or be a scalar. Default is True (evaluate ALL \emph{volnorm} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm and psinorm to phinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{phinorm} or (\emph{phinorm}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{phinorm} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{phinorm}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single phinorm value for volnorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at volnorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{volnorm2rmid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.volnorm2rmid}\pysiglinewithargsret{\bfcode{volnorm2rmid}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the mapped outboard midplane major radius corresponding to the passed volnorm (normalized flux surface volume) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array-like or scalar float}) -- Values of the normalized
flux surface volume to map to Rmid.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{volnorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{volnorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of Rmid.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{volnorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{volnorm}
or be a scalar. Default is True (evaluate ALL \emph{volnorm} at EACH
element in \emph{t}).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm and psinorm to Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{Rmid} or (\emph{Rmid}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{Rmid} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{Rmid}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single Rmid value for volnorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at volnorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find Rmid values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rmid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{volnorm2roa() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.volnorm2roa}\pysiglinewithargsret{\bfcode{volnorm2roa}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized minor radius corresponding to the passed volnorm (normalized flux surface volume) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{volnorm} (\emph{Array-like or scalar float}) -- Values of the normalized
flux surface volume to map to r/a.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{volnorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{volnorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of r/a.
Only the square root of positive values is taken. Negative
values are replaced with zeros, consistent with Steve Wolfe's
IDL implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{volnorm} are evaluated
at each value in \emph{t}. If True, \emph{t} must have only one dimension
(or be a scalar). If False, \emph{t} must match the shape of \emph{volnorm}
or be a scalar. Default is True (evaluate ALL \emph{volnorm} at EACH
element in \emph{t}).

\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from volnorm to
psinorm and psinorm to Rmid. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{roa} or (\emph{roa}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{roa} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{roa}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single r/a value for volnorm=0.7, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2roa}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at volnorm values of 0.5 and 0.7 at the single time
t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find r/a values at volnorm=0.5 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2roa}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find r/a values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{roa\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2roa}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{volnorm2rho() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.volnorm2rho}\pysiglinewithargsret{\bfcode{volnorm2rho}}{\emph{method}, \emph{*args}, \emph{**kwargs}}{}
Convert the passed (volnorm, t) coordinates into one of several coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} (\emph{String}) -- 
Indicates which coordinates to convert to.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

Rmid
 & 
Midplane major radius
\\

r/a
 & 
Normalized minor radius
\\
\hline\end{tabulary}

\end{quote}

Additionally, each valid option may be prepended with `sqrt'
to specify the square root of the desired unit.


\item {} 
\textbf{volnorm} (\emph{Array-like or scalar float}) -- Values of the normalized
flux surface volume to map to rho.

\item {} 
\textbf{t} (\emph{Array-like or scalar float}) -- Times to perform the conversion at.
If \emph{t} is a single value, it is used for all of the elements of
\emph{volnorm}. If the \emph{each\_t} keyword is True, then \emph{t} must be scalar
or have exactly one dimension. If the \emph{each\_t} keyword is False,
\emph{t} must have the same shape as \emph{volnorm}.

\item {} 
\textbf{sqrt} -- Set to True to return the square root of rho. Only
the square root of positive values is taken. Negative values are
replaced with zeros, consistent with Steve Wolfe's IDL
implementation efit\_rz2rho.pro. Default is False.

\item {} 
\textbf{each\_t} -- When True, the elements in \emph{volnorm} are evaluated at
each value in \emph{t}. If True, \emph{t} must have only one dimension (or
be a scalar). If False, \emph{t} must match the shape of \emph{volnorm} or be
a scalar. Default is True (evaluate ALL \emph{volnorm} at EACH element in
\emph{t}).

\item {} 
\textbf{rho} -- Set to True to return r/a (normalized minor radius)
instead of Rmid. Default is False (return major radius, Rmid).

\item {} 
\textbf{length\_unit} -- 
Length unit that \emph{Rmid} is returned in.
If a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (use meters).


\item {} 
\textbf{kind} -- Specifies the type of
interpolation to be performed in getting from volnorm to
Rmid/phinorm/psinorm. This is passed to
\code{scipy.interpolate.interp1d}. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for \code{interp1d} for more
details. Default value is `cubic' (3rd order spline
interpolation). On some builds of scipy, this can cause problems,
in which case you should try `linear' until you can rebuild your
scipy install.

\item {} 
\textbf{return\_t} -- Set to True to return a tuple of (\emph{rho},
\emph{time\_idxs}), where \emph{time\_idxs} is the array of time indices
actually used in evaluating \emph{rho} with nearest-neighbor
interpolation. (This is mostly present as an internal helper.)
Default is False (only return \emph{rho}).

\end{itemize}

\item[{Kwtype sqrt}] \leavevmode
Boolean

\item[{Kwtype each\_t}] \leavevmode
Boolean

\item[{Kwtype rho}] \leavevmode
Boolean

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Kwtype return\_t}] \leavevmode
Boolean

\item[{Returns}] \leavevmode

\emph{rho} or (\emph{rho}, \emph{time\_idxs})
\begin{itemize}
\item {} 
\textbf{rho} (\emph{Array or scalar float}) - The converted coordinates. If
all of the input arguments are scalar, then a scalar is returned.
Otherwise, a scipy Array is returned.

\item {} 
\textbf{time\_idxs} (Array with same shape as \emph{rho}) - The indices
(in \code{self.getTimeBase()}) that were used for
nearest-neighbor interpolation. Only returned if \emph{return\_t} is
True.

\end{itemize}


\item[{Raises}] \leavevmode
\code{ValueError} -- If \emph{method} is not one of the supported values.

\end{description}\end{quote}
\paragraph{Examples}

All assume that \emph{Eq\_instance} is a valid instance of the appropriate
extension of the {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{Equilibrium}}} abstract class.

Find single psinorm value at volnorm=0.6, t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at volnorm of 0.6 and 0.8 at the
single time t=0.26s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at volnorm of 0.6 at times t={[}0.2s, 0.3s{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5m, 0.3s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{volnorm2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{each\PYGZus{}t}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{getMagRSpline() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getMagRSpline}\pysiglinewithargsret{\bfcode{getMagRSpline}}{\emph{length\_unit=1}, \emph{kind='nearest'}}{}
Gets the univariate spline to interpolate R\_mag as a function of time.

Only used if the instance was created with keyword tspline=True.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{length\_unit} -- 
Length unit that R\_mag is returned in. If
a string is given, it must be a valid unit specifier:
\begin{quote}

`m'         meters
`cm'        centimeters
`mm'        millimeters
`in'        inches
`ft'        feet
`yd'        yards
`smoot'     smoots
`cubit'     cubits
`hand'      hands
`default'   meters
\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R\_out returned in meters).


\item {} 
\textbf{kind} -- Specifies the type of interpolation
to be performed in getting from t to R\_mag. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\end{itemize}

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Returns}] \leavevmode
scipy.interpolate.interp1d to convert from t to R\_mid.

\end{description}\end{quote}

\end{fulllineitems}

\index{getMagZSpline() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getMagZSpline}\pysiglinewithargsret{\bfcode{getMagZSpline}}{\emph{length\_unit=1}, \emph{kind='nearest'}}{}
Gets the univariate spline to interpolate Z\_mag as a function of time.

Generated for completeness of the core position calculation when using
tspline = True
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{length\_unit} -- 
Length unit that R\_mag is returned in. If
a string is given, it must be a valid unit specifier:
\begin{quote}

`m'         meters
`cm'        centimeters
`mm'        millimeters
`in'        inches
`ft'        feet
`yd'        yards
`smoot'     smoots
`cubit'     cubits
`hand'      hands
`default'   meters
\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R\_out returned in meters).


\item {} 
\textbf{kind} -- Specifies the type of interpolation
to be performed in getting from t to R\_mag. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\end{itemize}

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Returns}] \leavevmode
scipy.interpolate.interp1d to convert from t to R\_mid.

\end{description}\end{quote}

\end{fulllineitems}

\index{getRmidOutSpline() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getRmidOutSpline}\pysiglinewithargsret{\bfcode{getRmidOutSpline}}{\emph{length\_unit=1}, \emph{kind='nearest'}}{}
Gets the univariate spline to interpolate R\_mid\_out as a function of time.

Generated for completeness of the core position calculation when using
tspline = True
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{length\_unit} -- 
Length unit that R\_mag is returned in. If
a string is given, it must be a valid unit specifier:
\begin{quote}

`m'         meters
`cm'        centimeters
`mm'        millimeters
`in'        inches
`ft'        feet
`yd'        yards
`smoot'     smoots
`cubit'     cubits
`hand'      hands
`default'   meters
\end{quote}

If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R\_out returned in meters).


\item {} 
\textbf{kind} -- Specifies the type of interpolation
to be performed in getting from t to R\_mag. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\end{itemize}

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Returns}] \leavevmode
scipy.interpolate.interp1d to convert from t to R\_mid.

\end{description}\end{quote}

\end{fulllineitems}

\index{getAOutSpline() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getAOutSpline}\pysiglinewithargsret{\bfcode{getAOutSpline}}{\emph{length\_unit=1}, \emph{kind='nearest'}}{}
Gets the univariate spline to interpolate a\_out as a function of time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{length\_unit} -- 
Length unit that a\_out is returned in. If
a string is given, it must be a valid unit specifier:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}

\end{quote}

If \emph{length\_unit} is 1 or None, meters are assumed. The default
value is 1 (a\_out returned in meters).


\item {} 
\textbf{kind} -- Specifies the type of interpolation
to be performed in getting from t to a\_out. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\end{itemize}

\item[{Kwtype length\_unit}] \leavevmode
String or 1

\item[{Kwtype kind}] \leavevmode
String or non-negative int

\item[{Returns}] \leavevmode
scipy.interpolate.interp1d to convert from t to a\_out.

\end{description}\end{quote}

\end{fulllineitems}

\index{getInfo() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getInfo}\pysiglinewithargsret{\bfcode{getInfo}}{}{}
Abstract method.  See child classes for implementation.

Returns namedtuple of instance parameters (shot, equilibrium type, size, timebase, etc.)

\end{fulllineitems}

\index{getTimeBase() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getTimeBase}\pysiglinewithargsret{\bfcode{getTimeBase}}{}{}
Abstract method.  See child classes for implementation.

Returns timebase array {[}t{]}

\end{fulllineitems}

\index{getFluxGrid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFluxGrid}\pysiglinewithargsret{\bfcode{getFluxGrid}}{}{}
Abstract method.  See child classes for implementation.
\begin{description}
\item[{returns 3D grid of psi(r,z,t)}] \leavevmode\begin{description}
\item[{The array returned should have the following dimensions:}] \leavevmode
First dimension: time
Second dimension: Z
Third dimension: R

\end{description}

\end{description}

\end{fulllineitems}

\index{getRGrid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getRGrid}\pysiglinewithargsret{\bfcode{getRGrid}}{}{}
Abstract method.  See child classes for implementation.

Returns vector of R-values for psiRZ grid {[}r{]}

\end{fulllineitems}

\index{getZGrid() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getZGrid}\pysiglinewithargsret{\bfcode{getZGrid}}{}{}
Abstract method.  See child classes for implementation.

Returns vector of Z-values for psiRZ grid {[}z{]}

\end{fulllineitems}

\index{getFluxAxis() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFluxAxis}\pysiglinewithargsret{\bfcode{getFluxAxis}}{}{}
Abstract method.  See child classes for implementation.

Returns psi at magnetic axis {[}t{]}

\end{fulllineitems}

\index{getFluxLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFluxLCFS}\pysiglinewithargsret{\bfcode{getFluxLCFS}}{}{}
Abstract method.  See child classes for implementation.

Returns psi a separatrix {[}t{]}

\end{fulllineitems}

\index{getRLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getRLCFS}\pysiglinewithargsret{\bfcode{getRLCFS}}{}{}
Abstract method.  See child classes for implementation.

Returns R-positions (n points) mapping LCFS {[}t,n{]}

\end{fulllineitems}

\index{getZLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getZLCFS}\pysiglinewithargsret{\bfcode{getZLCFS}}{}{}
Abstract method.  See child classes for implementation.

Returns Z-positions (n points) mapping LCFS {[}t,n{]}

\end{fulllineitems}

\index{remapLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.remapLCFS}\pysiglinewithargsret{\bfcode{remapLCFS}}{}{}
Abstract method.  See child classes for implementation.

Overwrites stored R,Z positions of LCFS with explicitly calculated psinorm=1
surface.  This surface is then masked using core.inPolygon() to only draw within
vacuum vessel, the end result replacing RLCFS, ZLCFS with an R,Z array showing
the divertor legs of the flux surface in addition to the core-enclosing closed
flux surface.

\end{fulllineitems}

\index{getFluxVol() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFluxVol}\pysiglinewithargsret{\bfcode{getFluxVol}}{}{}
Abstract method.  See child classes for implementation.

Returns volume contained within flux surface as function of psi {[}psi,t{]}.
Psi assumed to be evenly-spaced grid on {[}0,1{]}

\end{fulllineitems}

\index{getVolLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getVolLCFS}\pysiglinewithargsret{\bfcode{getVolLCFS}}{}{}
Abstract method.  See child classes for implementation.

Returns plasma volume within LCFS {[}t{]}

\end{fulllineitems}

\index{getRmidPsi() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getRmidPsi}\pysiglinewithargsret{\bfcode{getRmidPsi}}{}{}
Abstract method.  See child classes for implementation.

Returns outboard-midplane major radius of flux surface {[}t,psi{]}

\end{fulllineitems}

\index{getF() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getF}\pysiglinewithargsret{\bfcode{getF}}{}{}
Abstract method.  See child classes for implementation.

Returns F=RB\_\{Phi\}(Psi), often calculated for grad-shafranov solutions  {[}psi,t{]}

\end{fulllineitems}

\index{getFluxPres() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFluxPres}\pysiglinewithargsret{\bfcode{getFluxPres}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated pressure profile {[}psi,t{]}.
Psi assumed to be evenly-spaced grid on {[}0,1{]}

\end{fulllineitems}

\index{getFFPrime() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFFPrime}\pysiglinewithargsret{\bfcode{getFFPrime}}{}{}
Abstract method.  See child classes for implementation.

Returns FF' function used for grad-shafranov solutions {[}psi,t{]}

\end{fulllineitems}

\index{getPPrime() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getPPrime}\pysiglinewithargsret{\bfcode{getPPrime}}{}{}
Abstract method.  See child classes for implementation.

Returns plasma pressure gradient as a function of psi {[}psi,t{]}

\end{fulllineitems}

\index{getElongation() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getElongation}\pysiglinewithargsret{\bfcode{getElongation}}{}{}
Abstract method.  See child classes for implementation.

Returns LCFS elongation {[}t{]}

\end{fulllineitems}

\index{getUpperTriangularity() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getUpperTriangularity}\pysiglinewithargsret{\bfcode{getUpperTriangularity}}{}{}
Abstract method.  See child classes for implementation.

Returns LCFS upper triangularity {[}t{]}

\end{fulllineitems}

\index{getLowerTriangularity() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getLowerTriangularity}\pysiglinewithargsret{\bfcode{getLowerTriangularity}}{}{}
Abstract method.  See child classes for implementation.

Returns LCFS lower triangularity {[}t{]}

\end{fulllineitems}

\index{getShaping() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getShaping}\pysiglinewithargsret{\bfcode{getShaping}}{}{}
Abstract method.  See child classes for implementation.

Returns dimensionless shaping parameters for plasma.
Namedtuple containing \{LCFS elongation, LCFS upper/lower triangularity\}

\end{fulllineitems}

\index{getMagR() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getMagR}\pysiglinewithargsret{\bfcode{getMagR}}{}{}
Abstract method.  See child classes for implementation.

Returns magnetic-axis major radius {[}t{]}

\end{fulllineitems}

\index{getMagZ() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getMagZ}\pysiglinewithargsret{\bfcode{getMagZ}}{}{}
Abstract method.  See child classes for implementation.

Returns magnetic-axis Z {[}t{]}

\end{fulllineitems}

\index{getAreaLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getAreaLCFS}\pysiglinewithargsret{\bfcode{getAreaLCFS}}{}{}
Abstract method.  See child classes for implementation.

Returns LCFS surface area {[}t{]}

\end{fulllineitems}

\index{getAOut() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getAOut}\pysiglinewithargsret{\bfcode{getAOut}}{}{}
Abstract method.  See child classes for implementation.

Returns outboard-midplane minor radius {[}t{]}

\end{fulllineitems}

\index{getRmidOut() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getRmidOut}\pysiglinewithargsret{\bfcode{getRmidOut}}{}{}
Abstract method.  See child classes for implementation.

Returns outboard-midplane major radius {[}t{]}

\end{fulllineitems}

\index{getGeometry() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getGeometry}\pysiglinewithargsret{\bfcode{getGeometry}}{}{}
Abstract method.  See child classes for implementation.

Returns dimensional geometry parameters
Namedtuple containing \{mag axis R,Z, LCFS area, volume, outboard-midplane major radius\}

\end{fulllineitems}

\index{getQProfile() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQProfile}\pysiglinewithargsret{\bfcode{getQProfile}}{}{}
Abstract method.  See child classes for implementation.

Returns safety factor q profile {[}psi,t{]}
Psi assumed to be evenly-spaced grid on {[}0,1{]}

\end{fulllineitems}

\index{getQ0() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQ0}\pysiglinewithargsret{\bfcode{getQ0}}{}{}
Abstract method.  See child classes for implementation.

Returns q on magnetic axis {[}t{]}

\end{fulllineitems}

\index{getQ95() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQ95}\pysiglinewithargsret{\bfcode{getQ95}}{}{}
Abstract method.  See child classes for implementation.

Returns q on 95\% flux surface {[}t{]}

\end{fulllineitems}

\index{getQLCFS() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQLCFS}\pysiglinewithargsret{\bfcode{getQLCFS}}{}{}
Abstract method.  See child classes for implementation.

Returns q on LCFS {[}t{]}

\end{fulllineitems}

\index{getQ1Surf() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQ1Surf}\pysiglinewithargsret{\bfcode{getQ1Surf}}{}{}
Abstract method.  See child classes for implementation.

Returns outboard-midplane minor radius of q=1 surface {[}t{]}

\end{fulllineitems}

\index{getQ2Surf() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQ2Surf}\pysiglinewithargsret{\bfcode{getQ2Surf}}{}{}
Abstract method.  See child classes for implementation.

Returns outboard-midplane minor radius of q=2 surface {[}t{]}

\end{fulllineitems}

\index{getQ3Surf() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQ3Surf}\pysiglinewithargsret{\bfcode{getQ3Surf}}{}{}
Abstract method.  See child classes for implementation.

Returns outboard-midplane minor radius of q=3 surface {[}t{]}

\end{fulllineitems}

\index{getQs() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getQs}\pysiglinewithargsret{\bfcode{getQs}}{}{}
Abstract method.  See child classes for implementation.

Returns specific q-profile values.
Namedtuple containing \{q0, q95, qLCFS, minor radius of q=1,2,3 surfaces\}

\end{fulllineitems}

\index{getBtVac() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getBtVac}\pysiglinewithargsret{\bfcode{getBtVac}}{}{}
Abstract method.  See child classes for implementation.

Returns vacuum on-axis toroidal field {[}t{]}

\end{fulllineitems}

\index{getBtPla() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getBtPla}\pysiglinewithargsret{\bfcode{getBtPla}}{}{}
Abstract method.  See child classes for implementation.

Returns plasma on-axis toroidal field {[}t{]}

\end{fulllineitems}

\index{getBpAvg() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getBpAvg}\pysiglinewithargsret{\bfcode{getBpAvg}}{}{}
Abstract method.  See child classes for implementation.

Returns average poloidal field {[}t{]}

\end{fulllineitems}

\index{getFields() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getFields}\pysiglinewithargsret{\bfcode{getFields}}{}{}
Abstract method.  See child classes for implementation.

Returns magnetic-field values.
Namedtuple containing \{Btor on magnetic axis (plasma and vacuum), avg Bpol\}

\end{fulllineitems}

\index{getIpCalc() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getIpCalc}\pysiglinewithargsret{\bfcode{getIpCalc}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated plasma current {[}t{]}

\end{fulllineitems}

\index{getIpMeas() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getIpMeas}\pysiglinewithargsret{\bfcode{getIpMeas}}{}{}
Abstract method.  See child classes for implementation.

Returns measured plasma current {[}t{]}

\end{fulllineitems}

\index{getJp() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getJp}\pysiglinewithargsret{\bfcode{getJp}}{}{}
Abstract method.  See child classes for implementation.

Returns grid of calculated toroidal current density {[}t,z,r{]}

\end{fulllineitems}

\index{getBetaT() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getBetaT}\pysiglinewithargsret{\bfcode{getBetaT}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated global toroidal beta {[}t{]}

\end{fulllineitems}

\index{getBetaP() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getBetaP}\pysiglinewithargsret{\bfcode{getBetaP}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated global poloidal beta {[}t{]}

\end{fulllineitems}

\index{getLi() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getLi}\pysiglinewithargsret{\bfcode{getLi}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated internal inductance of plasma {[}t{]}

\end{fulllineitems}

\index{getBetas() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getBetas}\pysiglinewithargsret{\bfcode{getBetas}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated betas and inductance.
Namedtuple of \{betat,betap,Li\}

\end{fulllineitems}

\index{getDiamagFlux() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getDiamagFlux}\pysiglinewithargsret{\bfcode{getDiamagFlux}}{}{}
Abstract method.  See child classes for implementation.

Returns diamagnetic flux {[}t{]}

\end{fulllineitems}

\index{getDiamagBetaT() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getDiamagBetaT}\pysiglinewithargsret{\bfcode{getDiamagBetaT}}{}{}
Abstract method.  See child classes for implementation.

Returns diamagnetic-loop toroidal beta {[}t{]}

\end{fulllineitems}

\index{getDiamagBetaP() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getDiamagBetaP}\pysiglinewithargsret{\bfcode{getDiamagBetaP}}{}{}
Abstract method.  See child classes for implementation.

Returns diamagnetic-loop poloidal beta {[}t{]}

\end{fulllineitems}

\index{getDiamagTauE() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getDiamagTauE}\pysiglinewithargsret{\bfcode{getDiamagTauE}}{}{}
Abstract method.  See child classes for implementation.

Returns diamagnetic-loop energy confinement time {[}t{]}

\end{fulllineitems}

\index{getDiamagWp() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getDiamagWp}\pysiglinewithargsret{\bfcode{getDiamagWp}}{}{}
Abstract method.  See child classes for implementation.

Returns diamagnetic-loop plasma stored energy {[}t{]}

\end{fulllineitems}

\index{getDiamag() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getDiamag}\pysiglinewithargsret{\bfcode{getDiamag}}{}{}
Abstract method.  See child classes for implementation.

Returns diamagnetic measurements of plasma parameters.
Namedtuple of \{diamag. flux, betat, betap from coils, tau\_E from diamag., diamag. stored energy\}

\end{fulllineitems}

\index{getWMHD() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getWMHD}\pysiglinewithargsret{\bfcode{getWMHD}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated MHD stored energy {[}t{]}

\end{fulllineitems}

\index{getTauMHD() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getTauMHD}\pysiglinewithargsret{\bfcode{getTauMHD}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated MHD energy confinement time {[}t{]}

\end{fulllineitems}

\index{getPinj() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getPinj}\pysiglinewithargsret{\bfcode{getPinj}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated injected power {[}t{]}

\end{fulllineitems}

\index{getCurrentSign() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getCurrentSign}\pysiglinewithargsret{\bfcode{getCurrentSign}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated current direction, where CCW = +

\end{fulllineitems}

\index{getWbdot() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getWbdot}\pysiglinewithargsret{\bfcode{getWbdot}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated d/dt of magnetic stored energy {[}t{]}

\end{fulllineitems}

\index{getWpdot() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getWpdot}\pysiglinewithargsret{\bfcode{getWpdot}}{}{}
Abstract method.  See child classes for implementation.

Returns calculated d/dt of plasma stored energy {[}t{]}

\end{fulllineitems}

\index{getEnergy() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getEnergy}\pysiglinewithargsret{\bfcode{getEnergy}}{}{}
Abstract method.  See child classes for implementation.

Returns stored-energy parameters.
Namedtuple of \{stored energy, confinement time, injected power, d/dt of magnetic, plasma stored energy\}

\end{fulllineitems}

\index{getParam() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getParam}\pysiglinewithargsret{\bfcode{getParam}}{\emph{path}}{}
Abstract method.  See child classes for implementation.

Backup function: takes parameter name for variable, returns variable directly.
Acts as wrapper to direct data-access routines from within object.

\end{fulllineitems}

\index{getMachineCrossSection() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getMachineCrossSection}\pysiglinewithargsret{\bfcode{getMachineCrossSection}}{}{}
Abstract method.  See child classes for implementation.

Returns (R,Z) coordinates of vacuum wall cross-section for plotting/masking routines.

\end{fulllineitems}

\index{getMachineCrossSectionFull() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.getMachineCrossSectionFull}\pysiglinewithargsret{\bfcode{getMachineCrossSectionFull}}{}{}
Abstract method.  See child classes for implementation.

Returns (R,Z) coordinates of machine wall cross-section for plotting routines.
Returns a more detailed cross-section than getLimiter(), generally a vector map
displaying non-critical cross-section information.  If this is unavailable, this
should point to self.getMachineCrossSection(), which pulls the limiter outline
stored by default in data files e.g. g-eqdsk files.

\end{fulllineitems}

\index{gfile() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.gfile}\pysiglinewithargsret{\bfcode{gfile}}{\emph{time=None}, \emph{nw=None}, \emph{nh=None}, \emph{shot=None}, \emph{name=None}, \emph{tunit='ms'}, \emph{title='EQTOOLS'}, \emph{nbbbs=100}}{}
\end{fulllineitems}

\index{plotFlux() (eqtools.core.Equilibrium method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.core.Equilibrium.plotFlux}\pysiglinewithargsret{\bfcode{plotFlux}}{\emph{fill=True}, \emph{mask=True}}{}
Plots flux contours directly from psi grid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{fill} -- Set True to plot filled contours.  Set False (default) to plot white-background
color contours.

\item[{Kwtype fill}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{eqtools.eqdskreader module}
\label{eqtools:eqtools-eqdskreader-module}\label{eqtools:module-eqtools.eqdskreader}\index{eqtools.eqdskreader (module)}
This module contains the EqdskReader class, which creates Equilibrium class
functionality for equilibria stored in eqdsk files from EFIT(a- and g-files).
\begin{description}
\item[{Classes:}] \leavevmode\begin{description}
\item[{EqdskReader: class inheriting Equilibrium reading g- and a-files for}] \leavevmode
equilibrium data.

\end{description}

\end{description}
\index{EqdskReader (class in eqtools.eqdskreader)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader}\pysiglinewithargsret{\strong{class }\code{eqtools.eqdskreader.}\bfcode{EqdskReader}}{\emph{shot=None}, \emph{time=None}, \emph{gfile=None}, \emph{afile=None}, \emph{length\_unit='m'}, \emph{verbose=True}}{}
Bases: {\hyperref[eqtools:eqtools.core.Equilibrium]{\code{eqtools.core.Equilibrium}}}

Equilibrium subclass working from eqdsk ASCII-file equilibria.

Inherits mapping and structural data from Equilibrium, populates equilibrium
and profile data from g- and a-files for a selected shot and time window.

Create instance of EqdskReader.

Generates object and reads data from selected g-file (either manually set or
autodetected based on user shot and time selection), storing as object
attributes for usage in Equilibrium mapping methods.

Calling structure - user may call class with shot and time (ms) values, set by keywords
(or positional placement allows calling without explicit keyword syntax).  EqdskReader
then attempts to construct filenames from the shot/time, of the form `g{[}shot{]}.{[}time{]}' and
`a{[}shot{]}.{[}time{]}'.  Alternately, the user may skip this input and explicitly set paths to
the g- and/or a-files, using the gfile and afile keyword arguments.  If both types of calls
are set, the explicit g-file and a-file paths override the auto-generated filenames from
the shot and time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{shot} -- Int.
Shot index.

\item {} 
\textbf{time} -- Int.
Time index (typically ms).  Shot and Time used to autogenerate filenames.

\item {} 
\textbf{gfile} -- String.
Manually selects ASCII file for equilibrium read.

\item {} 
\textbf{afile} -- String.
Manually selects ASCII file for time-history read.

\item {} 
\textbf{length\_unit} -- String.
Flag setting length unit for equilibrium scales.
Defaults to `m' for lengths in meters.

\item {} 
\textbf{verbose} -- Boolean.
When set to False, suppresses terminal outputs during CSV read.
Defaults to True (prints terminal output).

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\code{IOError} -- if both name/shot and explicit filenames are not set.

\item {} 
\code{ValueError} -- if the g-file cannot be found, or if multiple valid g/a-files are found.

\end{itemize}

\end{description}\end{quote}
\index{getInfo() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getInfo}\pysiglinewithargsret{\bfcode{getInfo}}{}{}
returns namedtuple of equilibrium information
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

namedtuple containing
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

shot
 & 
shot index
\\

time
 & 
time point of g-file
\\

nr
 & 
size of R-axis of spatial grid
\\

nz
 & 
size of Z-axis of spatial grid
\\

efittype
 & 
EFIT calculation type (magnetic, kinetic, MSE)
\\
\hline\end{tabulary}

\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{readAFile() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.readAFile}\pysiglinewithargsret{\bfcode{readAFile}}{\emph{afile}}{}
Reads a-file (scalar time-history data) to pull additional equilibrium data
not found in g-file, populates remaining data (initialized as None) in object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{afile} -- String.
Path to ASCII a-file.

\item[{Raises}] \leavevmode
\code{IOError} -- If afile is not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{rz2psi() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.rz2psi}\pysiglinewithargsret{\bfcode{rz2psi}}{\emph{R}, \emph{Z}, \emph{*args}, \emph{**kwargs}}{}
Converts passed, R,Z arrays to psi values.

Wrapper for Equilibrium.rz2psi masking out timebase dependence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} -- Array-like or scalar float.
Values of the radial coordinate to
map to poloidal flux. If the make\_grid keyword is True, R must
have shape (len\_R,).

\item {} 
\textbf{Z} -- Array-like or scalar float.
Values of the vertical coordinate to
map to poloidal flux. Must have the same shape as R unless the
make\_grid keyword is set. If the make\_grid keyword is True, Z
must have shape (len\_Z,).

\item {} 
\textbf{*args} -- Slot for time input for consistent syntax with Equilibrium.rz2psi.
will return dummy value for time if input in EqdskReader.

\item {} 
\textbf{make\_grid} -- Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).

\item {} 
\textbf{length\_unit} -- 
String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}


If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).


\item {} 
\textbf{**kwargs} -- Other keywords (i.e., return\_t) to rz2psi are valid
(necessary for proper inheritance and usage in other mapping routines)
but will return dummy values.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are scalar,}] \leavevmode
then a scalar is returned. Otherwise, a scipy Array instance is
returned. If R and Z both have the same shape then psi has this
shape as well. If the make\_grid keyword was True then psi has
shape (len(Z), len(R)).

\end{description}


\item[{Return type}] \leavevmode
psi

\end{description}\end{quote}

\end{fulllineitems}

\index{rz2psinorm() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.rz2psinorm}\pysiglinewithargsret{\bfcode{rz2psinorm}}{\emph{R}, \emph{Z}, \emph{*args}, \emph{**kwargs}}{}
Calculates the normalized poloidal flux at the given (R,Z).
Wrapper for Equilibrium.rz2psinorm masking out timebase dependence.

Uses the definition:
psi\_norm = (psi - psi(0)) / (psi(a) - psi(0))
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} -- Array-like or scalar float.
Values of the radial coordinate to
map to normalized poloidal flux. If R and Z are both scalar
values, they are used as the coordinate pair for all of the
values in t. Must have the same shape as Z unless the make\_grid
keyword is set. If the make\_grid keyword is True, R must have
shape (len\_R,).

\item {} 
\textbf{Z} -- Array-like or scalar float.
Values of the vertical coordinate to
map to normalized poloidal flux. If R and Z are both scalar
values, they are used as the coordinate pair for all of the
values in t. Must have the same shape as R unless the make\_grid
keyword is set. If the make\_grid keyword is True, Z must have
shape (len\_Z,).

\item {} 
\textbf{*args} -- Slot for time input for consistent syntax with Equilibrium.rz2psinorm.
will return dummy value for time if input in EqdskReader.

\item {} 
\textbf{sqrt} -- Boolean.
Set to True to return the square root of normalized
flux. Only the square root of positive psi\_norm values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe's IDL implementation efit\_rz2rho.pro. Default is False
(return psinorm).

\item {} 
\textbf{make\_grid} -- Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).

\item {} 
\textbf{length\_unit} -- 
String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}


If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).


\item {} 
\textbf{**kwargs} -- Other keywords passed to Equilibrium.rz2psinorm are valid,
but will return dummy values (i.e. for timebase keywords)

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are}] \leavevmode
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
psinorm has this shape as well. If the make\_grid keyword was
True then psinorm has shape (len(Z), len(R)).

\end{description}


\item[{Return type}] \leavevmode
psinorm

\end{description}\end{quote}
\paragraph{Examples}

All assume that Eq\_instance is a valid instance EqdskReader:

Find single psinorm value at R=0.6m, Z=0.0m:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2psinorm}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2phinorm() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.rz2phinorm}\pysiglinewithargsret{\bfcode{rz2phinorm}}{\emph{R}, \emph{Z}, \emph{*args}, \emph{**kwargs}}{}
Calculates normalized toroidal flux at a given (R,Z).

Wrapper for Equilibrium.rz2phinorm masking out timebase dependence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} -- Array-like or scalar float.
Values of the radial coordinate to
map to normalized toroidal flux. Must have the same shape as Z
unless the make\_grid keyword is set. If the make\_grid keyword
is True, R must have shape (len\_R,).

\item {} 
\textbf{Z} -- Array-like or scalar float.
Values of the vertical coordinate to
map to normalized toroidal flux. Must have the same shape as R
unless the make\_grid keyword is set. If the make\_grid keyword
is True, Z must have shape (len\_Z,).

\item {} 
\textbf{*args} -- Slot for time input for consistent syntax with Equilibrium.rz2phinorm.
will return dummy value for time if input in EqdskReader.

\item {} 
\textbf{sqrt} -- Boolean.
Set to True to return the square root of normalized
flux. Only the square root of positive phi\_norm values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe's IDL implementation efit\_rz2rho.pro. Default is False
(return phinorm).

\item {} 
\textbf{make\_grid} -- Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).

\item {} 
\textbf{kind} -- String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to phinorm. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\item {} 
\textbf{length\_unit} -- 
String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}


If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).


\item {} 
\textbf{**kwargs} -- Other keywords passed to Equilibrium.rz2phinorm are valid,
but will return dummy values (i.e. for timebase keywords)

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are}] \leavevmode
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
phinorm has this shape as well. If the make\_grid keyword was
True then phinorm has shape (len(Z), len(R)).

\end{description}


\item[{Return type}] \leavevmode
phinorm

\end{description}\end{quote}
\paragraph{Examples}

All assume that Eq\_instance is a valid instance of EqdskReader.

Find single phinorm value at R=0.6m, Z=0.0m:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find phinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2phinorm}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2volnorm() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.rz2volnorm}\pysiglinewithargsret{\bfcode{rz2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the normalized flux surface volume.

Not implemented for EqdskReader, as necessary parameter
is not read from a/g-files.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{NotImplementedError} -- in all cases.

\end{description}\end{quote}

\end{fulllineitems}

\index{rz2rho() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.rz2rho}\pysiglinewithargsret{\bfcode{rz2rho}}{\emph{method}, \emph{R}, \emph{Z}, \emph{t=False}, \emph{sqrt=False}, \emph{make\_grid=False}, \emph{kind='cubic'}, \emph{length\_unit=1}}{}
Convert the passed (R, Z) coordinates into one of several normalized coordinates.
Wrapper for Equilibrium.rz2rho masking timebase dependence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{method} -- 
String.
Indicates which normalized coordinates to use.
Valid options are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

psinorm
 & 
Normalized poloidal flux
\\

phinorm
 & 
Normalized toroidal flux
\\

volnorm
 & 
Normalized volume
\\
\hline\end{tabulary}

\end{quote}


\item {} 
\textbf{R} -- Array-like or scalar float.
Values of the radial coordinate to
map to normalized coordinate. Must have the same shape as Z
unless the make\_grid keyword is set. If the make\_grid keyword
is True, R must have shape (len\_R,).

\item {} 
\textbf{Z} -- Array-like or scalar float.
Values of the vertical coordinate to
map to normalized coordinate. Must have the same shape as R
unless the make\_grid keyword is set. If the make\_grid keyword
is True, Z must have shape (len\_Z,).

\item {} 
\textbf{t} -- indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.

\item {} 
\textbf{sqrt} -- Boolean.
Set to True to return the square root of normalized
coordinate. Only the square root of positive values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe's IDL implementation efit\_rz2rho.pro. Default is False
(return normalized coordinate itself).

\item {} 
\textbf{make\_grid} -- Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).

\item {} 
\textbf{kind} -- String or non-negative int.
Specifies the type of interpolation to be performed in getting
from psinorm to phinorm or volnorm. This is passed to
scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\item {} 
\textbf{length\_unit} -- 
String or 1.
Length unit that R and Z are being given
in. If a string is given, it must be a valid unit specifier:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}


If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R and Z given in meters).


\end{itemize}

\item[{Kwtype kind}] \leavevmode
phinorm and volnorm only

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are}] \leavevmode
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
rho has this shape as well. If the make\_grid keyword was True
then rho has shape (len(Z), len(R)).

\end{description}


\item[{Return type}] \leavevmode
rho

\item[{Raises}] \leavevmode
\code{ValueError} -- If method is not one of the supported values.

\end{description}\end{quote}
\paragraph{Examples}

All assume that Eq\_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.

Find single psinorm value at R=0.6m, Z=0.0m:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find psinorm values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rho}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psinorm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{rz2rmid() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.rz2rmid}\pysiglinewithargsret{\bfcode{rz2rmid}}{\emph{R}, \emph{Z}, \emph{t=False}, \emph{sqrt=False}, \emph{make\_grid=False}, \emph{rho=False}, \emph{kind='cubic'}, \emph{length\_unit=1}}{}
Maps the given points to the outboard midplane major radius, R\_mid.
Wrapper for Equilibrium.rz2rmid masking timebase dependence.

Based on the IDL version efit\_rz2rmid.pro by Steve Wolfe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{R} -- Array-like or scalar float.
Values of the radial coordinate to
map to midplane radius. Must have the same shape as Z unless
the make\_grid keyword is set. If the make\_grid keyword is True,
R must have shape (len\_R,).

\item {} 
\textbf{Z} -- Array-like or scalar float.
Values of the vertical coordinate to
map to midplane radius. Must have the same shape as R unless the
make\_grid keyword is set. If the make\_grid keyword is True, Z
must have shape (len\_Z,).

\item {} 
\textbf{t} -- indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.

\item {} 
\textbf{sqrt} -- Boolean.
Set to True to return the square root of midplane
radius. Only the square root of positive values is taken.
Negative values are replaced with zeros, consistent with Steve
Wolfe's IDL implementation efit\_rz2rho.pro. Default is False
(return R\_mid itself).

\item {} 
\textbf{make\_grid} -- Boolean.
Set to True to pass R and Z through meshgrid
before evaluating. If this is set to True, R and Z must each
only have a single dimension, but can have different lengths.
Default is False (do not form meshgrid).

\item {} 
\textbf{rho} -- Boolean.
Set to True to return r/a (normalized minor radius)
instead of R\_mid. Default is False (return major radius, R\_mid).

\item {} 
\textbf{kind} -- String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to R\_mid. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\item {} 
\textbf{length\_unit} -- \begin{description}
\item[{String or 1.}] \leavevmode
Length unit that R and Z are being given
in AND that R\_mid is returned in. If a string is given, it
must be a valid unit specifier:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}


\item[{If length\_unit is 1 or None, meters are assumed. The default}] \leavevmode
value is 1 (R and Z given in meters, R\_mid returned in meters).

\end{description}


\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are}] \leavevmode
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned. If R and Z both have the same shape then
R\_mid has this shape as well. If the make\_grid keyword was True
then R\_mid has shape (len(Z), len(R)).

\end{description}


\item[{Return type}] \leavevmode
R\_mid

\end{description}\end{quote}
\paragraph{Examples}

All assume that Eq\_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.

Find single R\_mid value at R=0.6m, Z=0.0m:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m).
Note that the Z vector must be fully specified,
even if the values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values on grid defined by 1D vector of radial positions R
and 1D vector of vertical positions Z:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}mat} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{rz2rmid}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{make\PYGZus{}grid}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2rmid() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.psinorm2rmid}\pysiglinewithargsret{\bfcode{psinorm2rmid}}{\emph{psi\_norm}, \emph{t=False}, \emph{rho=False}, \emph{kind='cubic'}, \emph{length\_unit=1}}{}
Calculates the outboard R\_mid location corresponding to the passed psi\_norm (normalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psi\_norm} -- Array-like or scalar float.
Values of the normalized
poloidal flux to map to midplane radius.

\item {} 
\textbf{t} -- indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.

\item {} 
\textbf{rho} -- Boolean.
Set to True to return r/a (normalized minor radius)
instead of R\_mid. Default is False (return major radius, R\_mid).

\item {} 
\textbf{kind} -- String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to R\_mid. This is
passed to scipy.interpolate.interp1d. Valid options are:
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\item {} 
\textbf{length\_unit} -- 
String or 1.
Length unit that R\_mid is returned in. If
a string is given, it must be a valid unit specifier:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

`m'
 & 
meters
\\

`cm'
 & 
centimeters
\\

`mm'
 & 
millimeters
\\

`in'
 & 
inches
\\

`ft'
 & 
feet
\\

`yd'
 & 
yards
\\

`smoot'
 & 
smoots
\\

`cubit'
 & 
cubits
\\

`hand'
 & 
hands
\\

`default'
 & 
meters
\\
\hline\end{tabulary}


If length\_unit is 1 or None, meters are assumed. The default
value is 1 (R\_mid returned in meters).


\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are}] \leavevmode
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned.

\end{description}


\item[{Return type}] \leavevmode
R\_mid

\end{description}\end{quote}
\paragraph{Examples}

All assume that Eq\_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.

Find single R\_mid value for psinorm=0.7:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{)}
\end{Verbatim}

Find R\_mid values at psi\_norm values of 0.5 and 0.7.
Note that the Z vector must be fully specified, even if the
values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{R\PYGZus{}mid\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2rmid}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{psinorm2volnorm() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.psinorm2volnorm}\pysiglinewithargsret{\bfcode{psinorm2volnorm}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the outboard R\_mid location corresponding to psi\_norm (normalized poloidal flux) values.
Not implemented for EqdskReader, as necessary parameter
is not read from a/g-files.

\end{fulllineitems}

\index{psinorm2phinorm() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.psinorm2phinorm}\pysiglinewithargsret{\bfcode{psinorm2phinorm}}{\emph{psi\_norm}, \emph{t=False}, \emph{kind='cubic'}}{}
Calculates the normalized toroidal flux corresponding to the passed psi\_norm (normalized poloidal flux) values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{psi\_norm} -- Array-like or scalar float.
Values of the normalized
poloidal flux to map to normalized toroidal flux.

\item {} 
\textbf{t} -- indeterminant.
Provides duck typing for inclusion of t values. Passed t values
either as an Arg or Kwarg are neglected.

\item {} 
\textbf{kind} -- String or non-negative int.
Specifies the type of interpolation
to be performed in getting from psinorm to phinorm. This is
`linear', `nearest', `zero', `slinear', `quadratic', `cubic'
passed to scipy.interpolate.interp1d. Valid options are:
If this keyword is an integer, it specifies the order of spline
to use. See the documentation for interp1d for more details.
Default value is `cubic' (3rd order spline interpolation). On
some builds of scipy, this can cause problems, in which case
you should try `linear' until you can rebuild your scipy install.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Array or scalar float. If all of the input arguments are}] \leavevmode
scalar, then a scalar is returned. Otherwise, a scipy Array
instance is returned.

\end{description}


\item[{Return type}] \leavevmode
phinorm

\end{description}\end{quote}
\paragraph{Examples}

All assume that Eq\_instance is a valid instance of the appropriate
extension of the Equilibrium abstract class.

Find single phinorm value for psinorm=0.7:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}val} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2phinorm}\PYG{p}{(}\PYG{l+m+mf}{0.7}\PYG{p}{)}
\end{Verbatim}

Find phinorm values at psi\_norm values of 0.5 and 0.7.
Note that the Z vector must be fully specified, even if the
values are all the same:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{phinorm\PYGZus{}arr} \PYG{o}{=} \PYG{n}{Eq\PYGZus{}instance}\PYG{o}{.}\PYG{n}{psinorm2phinorm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{getTimeBase() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getTimeBase}\pysiglinewithargsret{\bfcode{getTimeBase}}{}{}
Returns EFIT time point

\end{fulllineitems}

\index{getCurrentSign() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getCurrentSign}\pysiglinewithargsret{\bfcode{getCurrentSign}}{}{}
Returns the sign of the current, based on the check in Steve Wolfe's IDL implementation efit\_rz2psi.pro.

\end{fulllineitems}

\index{getFluxGrid() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFluxGrid}\pysiglinewithargsret{\bfcode{getFluxGrid}}{}{}
Returns EFIT flux grid, {[}r,z{]}

\end{fulllineitems}

\index{getRGrid() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getRGrid}\pysiglinewithargsret{\bfcode{getRGrid}}{\emph{length\_unit=1}}{}
Returns EFIT R-axis {[}r{]}

\end{fulllineitems}

\index{getZGrid() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getZGrid}\pysiglinewithargsret{\bfcode{getZGrid}}{\emph{length\_unit=1}}{}
Returns EFIT Z-axis {[}z{]}

\end{fulllineitems}

\index{getFluxAxis() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFluxAxis}\pysiglinewithargsret{\bfcode{getFluxAxis}}{}{}
Returns psi on magnetic axis

\end{fulllineitems}

\index{getFluxLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFluxLCFS}\pysiglinewithargsret{\bfcode{getFluxLCFS}}{}{}
Returns psi at separatrix

\end{fulllineitems}

\index{getRLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getRLCFS}\pysiglinewithargsret{\bfcode{getRLCFS}}{\emph{length\_unit=1}}{}
Returns array of R-values of LCFS

\end{fulllineitems}

\index{getZLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getZLCFS}\pysiglinewithargsret{\bfcode{getZLCFS}}{\emph{length\_unit=1}}{}
Returns array of Z-values of LCFS

\end{fulllineitems}

\index{remapLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.remapLCFS}\pysiglinewithargsret{\bfcode{remapLCFS}}{\emph{mask=False}}{}
Overwrites RLCFS, ZLCFS values pulled from EFIT with explicitly-calculated contour
of psinorm=1 surface.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{mask} -- Boolean.
Default False.  Set True to mask LCFS path to limiter outline (using inPolygon).
Set False to draw full contour of psi = psiLCFS.

\end{description}\end{quote}

\end{fulllineitems}

\index{getFluxVol() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFluxVol}\pysiglinewithargsret{\bfcode{getFluxVol}}{}{}
\end{fulllineitems}

\index{getVolLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getVolLCFS}\pysiglinewithargsret{\bfcode{getVolLCFS}}{\emph{length\_unit=3}}{}
Returns volume with LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getRmidPsi() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getRmidPsi}\pysiglinewithargsret{\bfcode{getRmidPsi}}{}{}
Returns outboard-midplane major radius of flux surfaces.

Data not read from a/g-files, not implemented for EqdskReader.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{NotImplementedError} -- RmidPsi not read from a/g-files.

\end{description}\end{quote}

\end{fulllineitems}

\index{getF() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getF}\pysiglinewithargsret{\bfcode{getF}}{}{}
returns F=RB\_\{Phi\}(Psi), often calculated for grad-shafranov solutions  {[}psi,t{]}

\end{fulllineitems}

\index{getFluxPres() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFluxPres}\pysiglinewithargsret{\bfcode{getFluxPres}}{}{}
Returns pressure on flux surface p(psi)

\end{fulllineitems}

\index{getFFPrime() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFFPrime}\pysiglinewithargsret{\bfcode{getFFPrime}}{}{}
returns FF' function used for grad-shafranov solutions {[}psi,t{]}

\end{fulllineitems}

\index{getPPrime() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getPPrime}\pysiglinewithargsret{\bfcode{getPPrime}}{}{}
returns plasma pressure gradient as a function of psi {[}psi,t{]}

\end{fulllineitems}

\index{getElongation() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getElongation}\pysiglinewithargsret{\bfcode{getElongation}}{}{}
Returns elongation of LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getUpperTriangularity() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getUpperTriangularity}\pysiglinewithargsret{\bfcode{getUpperTriangularity}}{}{}
Returns upper triangularity of LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getLowerTriangularity() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getLowerTriangularity}\pysiglinewithargsret{\bfcode{getLowerTriangularity}}{}{}
Returns lower triangularity of LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getShaping() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getShaping}\pysiglinewithargsret{\bfcode{getShaping}}{}{}
Pulls LCFS elongation, upper/lower triangularity.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}kappa,delta\_u,delta\_l{]}.

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getMagR() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getMagR}\pysiglinewithargsret{\bfcode{getMagR}}{\emph{length\_unit=1}}{}
Returns major radius of magnetic axis.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getMagZ() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getMagZ}\pysiglinewithargsret{\bfcode{getMagZ}}{\emph{length\_unit=1}}{}
Returns Z of magnetic axis.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getAreaLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getAreaLCFS}\pysiglinewithargsret{\bfcode{getAreaLCFS}}{\emph{length\_unit=2}}{}
Returns surface area of LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getAOut() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getAOut}\pysiglinewithargsret{\bfcode{getAOut}}{\emph{length\_unit=1}}{}
Returns outboard-midplane minor radius of LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getRmidOut() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getRmidOut}\pysiglinewithargsret{\bfcode{getRmidOut}}{\emph{length\_unit=1}}{}
Returns outboard-midplane major radius of LCFS.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getGeometry() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getGeometry}\pysiglinewithargsret{\bfcode{getGeometry}}{\emph{length\_unit=None}}{}
Pulls dimensional geometry parameters.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}Rmag,Zmag,AreaLCFS,aOut,RmidOut{]}

\item[{Parameters}] \leavevmode
\textbf{length\_unit} -- TODO

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQProfile() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQProfile}\pysiglinewithargsret{\bfcode{getQProfile}}{}{}
Returns safety factor q(psi).

\end{fulllineitems}

\index{getQ0() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQ0}\pysiglinewithargsret{\bfcode{getQ0}}{}{}
Returns safety factor q on-axis, q0.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQ95() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQ95}\pysiglinewithargsret{\bfcode{getQ95}}{}{}
Returns safety factor q at 95\% flux surface.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQLCFS() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQLCFS}\pysiglinewithargsret{\bfcode{getQLCFS}}{}{}
Returns safety factor q at LCFS (interpolated).
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not loaded.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQ1Surf() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQ1Surf}\pysiglinewithargsret{\bfcode{getQ1Surf}}{\emph{length\_unit=1}}{}
Returns outboard-midplane minor radius of q=1 surface.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQ2Surf() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQ2Surf}\pysiglinewithargsret{\bfcode{getQ2Surf}}{\emph{length\_unit=1}}{}
Returns outboard-midplane minor radius of q=2 surface.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQ3Surf() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQ3Surf}\pysiglinewithargsret{\bfcode{getQ3Surf}}{\emph{length\_unit=1}}{}
Returns outboard-midplane minor radius of q=3 surface.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getQs() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getQs}\pysiglinewithargsret{\bfcode{getQs}}{\emph{length\_unit=1}}{}
Pulls q-profile data.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}q0,q95,qLCFS,rq1,rq2,rq3{]}

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getBtVac() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getBtVac}\pysiglinewithargsret{\bfcode{getBtVac}}{}{}
Returns vacuum toroidal field on-axis.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getBtPla() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getBtPla}\pysiglinewithargsret{\bfcode{getBtPla}}{}{}
Returns plasma toroidal field on-axis.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getBpAvg() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getBpAvg}\pysiglinewithargsret{\bfcode{getBpAvg}}{}{}
Returns average poloidal field.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getFields() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getFields}\pysiglinewithargsret{\bfcode{getFields}}{}{}
Pulls vacuum and plasma toroidal field, poloidal field data.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}BtVac,BtPla,BpAvg{]}

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getIpCalc() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getIpCalc}\pysiglinewithargsret{\bfcode{getIpCalc}}{}{}
Returns EFIT-calculated plasma current.

\end{fulllineitems}

\index{getIpMeas() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getIpMeas}\pysiglinewithargsret{\bfcode{getIpMeas}}{}{}
Returns measured plasma current.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getJp() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getJp}\pysiglinewithargsret{\bfcode{getJp}}{}{}
Returns (r,z) grid of toroidal plasma current density.

Data not read from g-file, not implemented for EqdskReader.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{NotImplementedError} -- Jp not read from g-file.

\end{description}\end{quote}

\end{fulllineitems}

\index{getBetaT() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getBetaT}\pysiglinewithargsret{\bfcode{getBetaT}}{}{}
Returns EFIT-calculated toroidal beta.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getBetaP() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getBetaP}\pysiglinewithargsret{\bfcode{getBetaP}}{}{}
Returns EFIT-calculated poloidal beta.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read

\end{description}\end{quote}

\end{fulllineitems}

\index{getLi() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getLi}\pysiglinewithargsret{\bfcode{getLi}}{}{}
Returns internal inductance of plasma.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getBetas() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getBetas}\pysiglinewithargsret{\bfcode{getBetas}}{}{}
Pulls EFIT-calculated betas and internal inductance.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}betat,betap,Li{]}

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamagFlux() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getDiamagFlux}\pysiglinewithargsret{\bfcode{getDiamagFlux}}{}{}
Returns diamagnetic flux.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamagBetaT() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getDiamagBetaT}\pysiglinewithargsret{\bfcode{getDiamagBetaT}}{}{}
Returns diamagnetic-loop measured toroidal beta.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamagBetaP() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getDiamagBetaP}\pysiglinewithargsret{\bfcode{getDiamagBetaP}}{}{}
Returns diamagnetic-loop measured poloidal beta.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamagTauE() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getDiamagTauE}\pysiglinewithargsret{\bfcode{getDiamagTauE}}{}{}
Returns diamagnetic-loop energy confinement time.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamagWp() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getDiamagWp}\pysiglinewithargsret{\bfcode{getDiamagWp}}{}{}
Returns diamagnetic-loop measured stored energy.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getDiamag() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getDiamag}\pysiglinewithargsret{\bfcode{getDiamag}}{}{}
Pulls diamagnetic flux, diamag. measured toroidal and poloidal beta, stored energy, and energy confinement time.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}diaFlux,diaBetat,diaBetap,diaTauE,diaWp{]}

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read

\end{description}\end{quote}

\end{fulllineitems}

\index{getWMHD() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getWMHD}\pysiglinewithargsret{\bfcode{getWMHD}}{}{}
Returns EFIT-calculated stored energy.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getTauMHD() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getTauMHD}\pysiglinewithargsret{\bfcode{getTauMHD}}{}{}
Returns EFIT-calculated energy confinement time.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getPinj() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getPinj}\pysiglinewithargsret{\bfcode{getPinj}}{}{}
Returns EFIT injected power.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getWbdot() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getWbdot}\pysiglinewithargsret{\bfcode{getWbdot}}{}{}
Returns EFIT d/dt of magnetic stored energy
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getWpdot() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getWpdot}\pysiglinewithargsret{\bfcode{getWpdot}}{}{}
Returns EFIT d/dt of plasma stored energy.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getEnergy() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getEnergy}\pysiglinewithargsret{\bfcode{getEnergy}}{}{}
Pulls EFIT stored energy, energy confinement time, injected power, and d/dt of magnetic and plasma stored energy.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
namedtuple containing {[}WMHD,tauMHD,Pinj,Wbdot,Wpdot{]}

\item[{Raises}] \leavevmode
\code{ValueError} -- if a-file data is not read.

\end{description}\end{quote}

\end{fulllineitems}

\index{getParam() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getParam}\pysiglinewithargsret{\bfcode{getParam}}{\emph{name}}{}
Backup function, applying a direct path input for tree-like data storage access
for parameters not typically found in Equilbrium object.  Directly calls attributes
read from g/a-files in copy-safe manner.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{name} -- String.
Parameter name for value stored in EqdskReader instance.

\item[{Raises}] \leavevmode
\code{AttributeError} -- raised if no attribute is found.

\end{description}\end{quote}

\end{fulllineitems}

\index{getMachineCrossSection() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getMachineCrossSection}\pysiglinewithargsret{\bfcode{getMachineCrossSection}}{}{}
Method to pull machine cross-section from data storage, convert to standard format for plotting routine.

\end{fulllineitems}

\index{getMachineCrossSectionFull() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.getMachineCrossSectionFull}\pysiglinewithargsret{\bfcode{getMachineCrossSectionFull}}{}{}
Returns vectorization of machine cross-section.

Absent additional data (not found in eqdsks) simply returns self.getMachineCrossSection().

\end{fulllineitems}

\index{gfile() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.gfile}\pysiglinewithargsret{\bfcode{gfile}}{\emph{time=None}, \emph{nw=None}, \emph{nh=None}, \emph{shot=None}, \emph{name=None}, \emph{tunit='ms'}, \emph{title='EQTOOLS'}, \emph{nbbbs=100}}{}
\end{fulllineitems}

\index{plotFlux() (eqtools.eqdskreader.EqdskReader method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.eqdskreader.EqdskReader.plotFlux}\pysiglinewithargsret{\bfcode{plotFlux}}{\emph{fill=True}, \emph{mask=True}}{}
streamlined plotting of flux contours directly from psi grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fill} -- Boolean.
Default True.  Set True to plot filled contours of flux delineated by black outlines.
Set False to instead plot color-coded line contours on a blank background.

\item {} 
\textbf{mask} -- Boolean.
Default True.  Set True to draw a clipping mask based on the limiter outline for the flux contours.
Set False to draw the full RZ grid.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{eqtools.filewriter module}
\label{eqtools:module-eqtools.filewriter}\label{eqtools:eqtools-filewriter-module}\index{eqtools.filewriter (module)}\index{gfile() (in module eqtools.filewriter)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.filewriter.gfile}\pysiglinewithargsret{\code{eqtools.filewriter.}\bfcode{gfile}}{\emph{obj}, \emph{tin}, \emph{nw=None}, \emph{nh=None}, \emph{shot=None}, \emph{name=None}, \emph{tunit='ms'}, \emph{title='EQTOOLS'}, \emph{nbbbs=100}}{}
\end{fulllineitems}

\index{findLCFS() (in module eqtools.filewriter)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.filewriter.findLCFS}\pysiglinewithargsret{\code{eqtools.filewriter.}\bfcode{findLCFS}}{\emph{rgrid}, \emph{zgrid}, \emph{psiRZ}, \emph{rcent}, \emph{zcent}, \emph{psiLCFS}, \emph{nbbbs=100}}{}
\end{fulllineitems}



\subsection{eqtools.pfilereader module}
\label{eqtools:eqtools-pfilereader-module}\label{eqtools:module-eqtools.pfilereader}\index{eqtools.pfilereader (module)}
This module contains the PFileReader class, a lightweight data
handler for p-file (radial profile) datasets.
\begin{description}
\item[{Classes:}] \leavevmode\begin{description}
\item[{PFileReader: Data-storage class for p-file data.  Reads}] \leavevmode
data from ASCII p-file, storing as copy-safe object
attributes.

\end{description}

\end{description}
\index{PFileReader (class in eqtools.pfilereader)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.pfilereader.PFileReader}\pysiglinewithargsret{\strong{class }\code{eqtools.pfilereader.}\bfcode{PFileReader}}{\emph{pfile}, \emph{verbose=True}}{}
Bases: \code{object}

Class to read ASCII p-file (profile data storage) into lightweight, user-friendly data structure.

P-files store data blocks containing the following: a header with parameter
name, parameter units, x-axis units, and number of data points, followed by values of
axis x, parameter y, and derivative dy/dx.  Each parameter block is read into a
namedtuple storing {[}'name','npts','units','xunits','x','y','dydx'{]}, with each namedtuple
stored as an attribute of the PFileReader instance.  This gracefully handles variable
formats of p-files (differing versions of p-files will have different parameters stored).
Data blocks are accessed as attributes in a copy-safe manner.

Creates instance of PFileReader.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pfile} -- String.
Path to ASCII p-file to be loaded.

\item {} 
\textbf{verbose} -- Boolean.
Option to print message on object creation listing available data
parameters. Defaults to True.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{eqtools.trispline module}
\label{eqtools:eqtools-trispline-module}\label{eqtools:module-eqtools.trispline}\index{eqtools.trispline (module)}
This module provides interface to the tricubic spline interpolator. It also
contains an enhanced bivariate spline which generates bounds errors.
\index{Spline (class in eqtools.trispline)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.trispline.Spline}\pysiglinewithargsret{\strong{class }\code{eqtools.trispline.}\bfcode{Spline}}{\emph{z}, \emph{y}, \emph{x}, \emph{f}, \emph{regular=True}, \emph{fast=False}}{}
Tricubic interpolating spline with forced edge derivative equal zero
conditions.  It assumes a cartesian grid.

Create a new Spline instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{z} (\emph{1-dimensional float array}) -- Values of the positions of the 1st
Dimension of f. Must be monotonic without duplicates.

\item {} 
\textbf{y} (\emph{1-dimensional float array}) -- Values of the positions of the 2nd
dimension of f. Must be monotonic without duplicates.

\item {} 
\textbf{x} (\emph{1-dimensional float array}) -- Values of the positions of the 3rd
dimension of f. Must be monotonic without duplicates.

\item {} 
\textbf{f} (\emph{3-dimensional float array}) -- f{[}z,y,x{]}. NaN and Inf will hamper
performance and affect interpolation in 4x4x4 space about its value.

\item {} 
\textbf{regular} -- If the grid is known to be regular, forces
matrix-based fast evaluation of interpolation.

\item {} 
\textbf{fast} -- Outdated input to test the indexing performance of the
c code vs internal python handling.

\end{itemize}

\item[{Kwtype regular}] \leavevmode
Boolean

\item[{Kwtype fast}] \leavevmode
Boolean

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\code{ValueError} -- If any of the dimensions do not match specified f dim

\item {} 
\code{ValueError} -- If x,y, or z are not monotonic

\end{itemize}

\end{description}\end{quote}
\paragraph{Examples}

temp
\index{ev() (eqtools.trispline.Spline method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.trispline.Spline.ev}\pysiglinewithargsret{\bfcode{ev}}{\emph{z1}, \emph{y1}, \emph{x1}}{}
evaluates tricubic spline at point (x1,y1,z1) which is f{[}z1,y1,x1{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{z1} (\emph{scalar float or 1-dimensional float}) -- Position in z dimension. (First dimension of 3d valued grid)

\item {} 
\textbf{y1} (\emph{scalar float or 1-dimensional float}) -- Position in y dimension. (Second dimension of 3d valued grid)

\item {} 
\textbf{x1} (\emph{scalar float or 1-dimensional float}) -- Position in x dimension. (Third dimension of 3d valued grid)

\end{itemize}

\item[{Returns}] \leavevmode

\emph{val}
\begin{itemize}
\item {} 
\textbf{val} (\emph{array or scalar float}) - The interpolated value at

\end{itemize}

(x1,y1,z1).


\item[{Raises}] \leavevmode
\code{ValueError} -- If any of the dimensions exceed the evaluation boundary
of the grid

\end{description}\end{quote}
\paragraph{Examples}
\begin{description}
\item[{Data is grouped into the grid voxels so as to reuse calculated}] \leavevmode
spline coefficents, thus speeding evaluation.  It is
recommended that it is evaluated outside of for loops to best
utilize this feature.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{RectBivariateSpline (class in eqtools.trispline)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.trispline.RectBivariateSpline}\pysiglinewithargsret{\strong{class }\code{eqtools.trispline.}\bfcode{RectBivariateSpline}}{\emph{x, y, z, bbox={[}None, None, None, None{]}, kx=3, ky=3, s=0, bounds\_error=True, fill\_value=nan}}{}
Bases: \code{scipy.interpolate.fitpack2.RectBivariateSpline}

the lack of a graceful bounds error causes the fortran to fail hard.
This masks scipy.interpolate.RectBivariateSpline with a proper bound
checker and value filler such that it will not fail in use for EqTools

Can be used for both smoothing and interpolating data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} (\emph{1-dimensional float array}) -- 1-D array of coordinates in monotonically increasing order.

\item {} 
\textbf{y} (\emph{1-dimensional float array}) -- 1-D array of coordinates in monotonically increasing order.

\item {} 
\textbf{z} (\emph{2-dimensional float array}) -- 2-D array of data with shape (x.size,y.size).

\item {} 
\textbf{bbox} -- Sequence of length 4 specifying the
boundary of the rectangular approximation domain.  By default,
\code{bbox={[}min(x,tx),max(x,tx), min(y,ty),max(y,ty){]}}.

\item {} 
\textbf{kx} -- Degrees of the bivariate spline. Default is 3.

\item {} 
\textbf{ky} -- Degrees of the bivariate spline. Default is 3.

\item {} 
\textbf{s} -- Positive smoothing factor defined for estimation condition,
\code{sum((w{[}i{]}*(z{[}i{]}-s(x{[}i{]}, y{[}i{]})))**2, axis=0) \textless{}= s}
Default is \code{s=0}, which is for interpolation.

\end{itemize}

\item[{Kwtype bbox}] \leavevmode
1-dimensional float

\item[{Kwtype kx}] \leavevmode
integer

\item[{Kwtype ky}] \leavevmode
integer

\item[{Kwtype s}] \leavevmode
float

\end{description}\end{quote}
\index{ev() (eqtools.trispline.RectBivariateSpline method)}

\begin{fulllineitems}
\phantomsection\label{eqtools:eqtools.trispline.RectBivariateSpline.ev}\pysiglinewithargsret{\bfcode{ev}}{\emph{xi}, \emph{yi}}{}~\begin{description}
\item[{Evaluate the rectBiVariateSpline at (xi,yi).  (x,y)values are}] \leavevmode
checked for being in the bounds of the interpolated data.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{xi} (\emph{float array}) -- input x dimensional values

\item {} 
\textbf{yi} (\emph{float array}) -- input x dimensional values

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{evaluated spline at points}] \leavevmode
(x{[}i{]}, y{[}i{]}), i=0,...,len(x)-1

\end{description}


\item[{Return type}] \leavevmode
val (float array)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Module contents}
\label{eqtools:module-eqtools}\label{eqtools:module-contents}\index{eqtools (module)}
Provides classes for interacting with magnetic equilibrium data in a variety of formats.


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{e}
\item {\texttt{eqtools}}, \pageref{eqtools:module-eqtools}
\item {\texttt{eqtools.afilereader}}, \pageref{eqtools:module-eqtools.afilereader}
\item {\texttt{eqtools.CModEFIT}}, \pageref{eqtools:module-eqtools.CModEFIT}
\item {\texttt{eqtools.core}}, \pageref{eqtools:module-eqtools.core}
\item {\texttt{eqtools.EFIT}}, \pageref{eqtools:module-eqtools.EFIT}
\item {\texttt{eqtools.eqdskreader}}, \pageref{eqtools:module-eqtools.eqdskreader}
\item {\texttt{eqtools.filewriter}}, \pageref{eqtools:module-eqtools.filewriter}
\item {\texttt{eqtools.FromArrays}}, \pageref{eqtools:module-eqtools.FromArrays}
\item {\texttt{eqtools.NSTXEFIT}}, \pageref{eqtools:module-eqtools.NSTXEFIT}
\item {\texttt{eqtools.pfilereader}}, \pageref{eqtools:module-eqtools.pfilereader}
\item {\texttt{eqtools.trispline}}, \pageref{eqtools:module-eqtools.trispline}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
