import numpy as np
import csv
import re
from collections import namedtuple


class PFileReader(object):
    """
    class to read p-file (profile data storage) generated by Osborne tools
    into a python-usable data structure.  P-file stores blocks of (abscissa, data, gradient)
    for ne, Te, ni, Ti, beam ion density(?), beam pressure, total pressure, omeg(?), omegp(?),
    omgvb(?), omgpp(?) omgeb(?), ommvb(?), ommpp(?), omevb(?), omepp(?), Er, kpol(?).
    """
    def __init__(self,pfile,verbose=True):
        """
        initialize data-storage object and read data from supplied p-file.

        INPUTS:
        pfile:      (str) path to p-file
        verbose:    (bool, def True) print available parameters on load
        """
        self._pfile = pfile
        self._params = []

        with open(pfile,'r') as readfile:
            dia = csv.excel()
            dia.skipinitialspace = True
            reader = csv.reader(readfile,dia,delimiter=' ')

            # define data structure as named tuple for storing parameter values
            data = namedtuple('DataStruct',['name','npts','units','xunits','x','y','dydx'])

            # iterate through lines of file, checking for a header line; 
            # at each header, read the next npts lines of data into appropriate arrays.
            # continue until no headerline is found (throws StopIteration).  Populate list
            # of params with available variables.
            while True:
                try:
                    headerline = next(reader)
                except StopIteration:
                    break

                npts = int(headerline[0])               # size of abscissa, data arrays
                abscis = headerline[1]                  # string name of abscissa variable (e.g. 'psinorm')
                var = re.split('[\(\)]',headerline[2])
                param = var[0]                          # string name of parameter (e.g. 'ne')
                units = var[1]                          # string name of units (e.g. '10^20/m^3')

                # read npts next lines, populate arrays
                x = []
                val = []
                gradval = []
                for j in range(npts):
                    dataline = next(reader)
                    x.append(float(dataline[0]))
                    val.append(float(dataline[1]))
                    gradval.append(float(dataline[2]))
                x = np.array(x)
                val = np.array(val)
                gradval = np.array(gradval)

                # collate into storage structure
                vars(self)['_'+param] = data(name=param,npts=npts,units=units,xunits=abscis,x=x,y=val,dydx=gradval)
                self._params.append(param)

        print('P-file data loaded.')
        if verbose:
            print('Available parameters:')
            for par in self._params:
                un = vars(self)['_'+par].units
                xun = vars(self)['_'+par].xunits
                print(str(par).ljust(8)+str(xun).ljust(12)+str(un))

    def __str__(self):
        mes = 'P-file data from '+self._pfile+' containing parameters:\n'
        for par in self._params:
            un = vars(self)['_'+par].units
            xun = vars(self)['_'+par].xunits
            mes += str(par).ljust(8)+str(xun).ljust(12)+str(un)+'\n'
        return mes

    def __getattribute__(self, name):
        """
        Tries to get attribute as written.  If this fails, trys to call the attribute
        with preceding underscore, marking a pseudo-private variable.  If this exists,
        returns a copy-safe value.  If this fails, raises AttributeError.  Generates a
        copy-safe version of each data attribute.
        """
        try:
            return super(PFileReader,self).__getattribute__(name)
        except AttributeError:
            try:
                attr = super(PFileReader,self).__getattribute__('_'+name)
                if type(attr) is namedtuple:
                    return attr.copy()
                elif type(attr) is list:
                    return attr[:]
                else:
                    return attr
            except AttributeError:
                raise AttributeError('No attribute "%s" found' % name)

    def __setattr__(self, name, value):
        """
        Raises AttributeError if the object already has a method get[name], as
        creation of such an attribute would interfere with the automatic
        property generation in __getattribute__.
        """
        if hasattr(self, '_'+name):
            raise AttributeError("PFileReader object already has data attribute "
                                 "'_%(n)s', creating attribute '%(n)s' will"
                                 " conflict with automatic property generation."
                                 % {'n': name})
        else:
            super(PFileReader, self).__setattr__(name, value)

            

            












            
